---
title: 14.4 제너레이터
layout: post
date: '2020-05-21 16:16'
categories:
- lj
---

## 14.4 제너레이터

12장에서 설명했듯 제너레이터는 함수와 호출자 사이의 **양방향 통신**을 가능하게 합니다.  
제너레이터는 원래 동기적인 성격을 가졌지만, 프로미스와 결합하면 비동기 코드를 효율적으로 관리할 수 있습니다.

**비동기 코드에서 가장 어려운 부분이 무엇일까요?**  
동기적인 코드에 비해 만들기가 어렵다는 점입니다.  
어려운 문제를 해결해야 할 때 우리는 대개 동기적으로 생각합니다.  
1단계, 2단계, 3단계 하는 식으로 말입니다.  
하지만 이렇게 하면 성능 문제가 있습니다.  
비동기 코드는 성능 문제를 해결하기 위해 등장했습니다.  
비동기 코드의 난해함은 젖혀놓고 성능 개선만 누릴 수 있다면 정말 좋지 않을까요?  
제너레이터를 사용하면 일정 부분 가능해집니다.

앞에서 잠시 언급한 **콜백 헬**을 다시 살펴봅시다.  
파일 세 개를 읽고 1분간 기다린 다음 그 내용을 합쳐서 네 번째 파일에 쓰는 문제였습니다.  
사람은 **대개** 이런 식으로 하려고 합니다.

```javascript
dataA = read contents of 'a.txt'
dataB = read contents of 'b.txt'
dataC = read contents of 'c.txt'
wait 60 seconds
write dataA + dataB + dataC
```

**제너레이터를 사용하면 이런 자연스러운 발상과 비슷한 코드를 작성할 수 있습니다.**  
물론 제너레이터를 쓴다고 바로 되는 것은 아니고, 선행 작업이 약간 필요하긴 합니다.  
가장 먼저 할 일은 **노드의 오류 우선 콜백을 프로미스로 바꾸는 겁니다.**  
이 기능을 nfcall(Node function call) 함수로 만들겠습니다.

```javascript
function nfcall(f, ...args) {
    return new Promise(function(resolve, reject) {
        f.call(null, ...args, function(err, ...args) {
            if(err) return reject(err);
            resolve(args.length < 2 ? args[0] : args);
        })
    })
}
```

>**NOTE_**  
>이 함수는 Q 프로미스 라이브러리[https://github.com/kriskowal/q](https://github.com/kriskowal/q){:target="_blank"}의 nfcall 메서드를 참고해 만들었고 
>같은 이름을 붙였습니다.  
>이런 기능이 필요하다면 Q 라이브러리를 쓰는 걸 고려할 만 합니다.  
>Q 라이브러리에는 이 메서드 뿐만 아니라 프로미스에 관련된 좋은 메서드가 많이 있습니다.

이제 콜백을 받는 노드 스타일 메서드를 모두 프로미스로 바꿀 수 있습니다.  
`setTimeout`을 써야 하는데, setTimeout은 노드보다 먼저 나왔고 오류 우선 콜백의 패턴을 따르지 않습니다.  
그러니 같은 기능을 가진 `ptimeout(promise timeout)`함수를 새로 만듭니다.

```javascript
function ptimeout(delay) {
    return new Promise(function(resolve, reject) {
        setTimeout(resolve, delay)
    })
}
```

다음에 필요한 것은 **제너레이터 실행기**입니다.  
**제너레이터는 원래 <span style="color:red">동기적</span>입니다.**  
하지만 제너레이터는 호출자와 통신할 수 있으므로 제너레이터와의 통신을 관리하고 비동기적 호출을 처리하는 함수를 만들 수 있습니다.  
이런 역할을 할 함수 `grun(generator run)`을 만들겠습니다.

```javascript
function grun(g) {
    const it = g();
    (function iterate(val) {
        const x = it.next(val);
        if (!x.done) {
            if (x.value instanceof Promise) {
                x.value.then(iterate).catch(err => it.throw(err));
            } else {
                // 세번째 이후 매개변수 : 타이머가 만료되고 func에 전달되는 추가적인 매개변수들입니다.
                setTimeout(iterate, 0, x.value);
            }
        }
    })();
}
```

>**NOTE_**  
>grun은 카일 심슨(Kyle Simpson)이 제너레이터에 관해 쓴 글