---
title: 2. FLOW CONTROL STATEMENT
layout: post
date: '2020-06-15 00:36'
categories:
- codespitz
---

## 2. FLOW CONTROL STATEMENT

제어문 : 무엇을 제어하냐? 바로 FLOW를 제어한다는 것.  
메모리에 적재되어 실행되면 그때부터 우리는 관여를 할 수 없는데 **FLOW CONTROL**은 여기에 관여를 하겠다는 것이다.

## RECORD, COMPLETION RECORD

우선 자바스크립트의 기본적인 '문'처리 방식을 배울 필요가 있다.  
자바스크립트는 '문'을 해석할 때 '식'하고는 다르게 해석한다.  
'식'은 하나의 '값'으로 처리될 뿐이다.  
**그런데 '문'은 하나의 실행 단위로 해석이 된다.**  
그래서 우리가 문을 10개를 작성하면 10개의 실행 단위가 생긴다.  
그에비해 '식'은 아무리 많이 써봐야 '값'으로 수렴할 뿐이다.  
자바스크립트는 우리가 '문'의 갯수를 늘리면 '문'의 갯수만큼 우리가 처리해야할 과제로 삼는다.  
따라서 한줄한줄 '문'이 생길 때마다 자바스크립트는 이를 '과제'로 등록한다.  
이 '과제'를 **RECORD**라고 부른다.
즉 자바스크립트는 문을 레코드로 등록하고 이 레코드를 하나하나 소비해나가며 과제를 해결한다.  

>자바스크립트 엔진의 주 작동 원리  
>'문'을 레코드로 만들어 적재한 후 순차적으로 실행한다.

자바스크립트 예전 책 - 좋은 책이다. 하지만 현재 자바스크립트랑은 맞지 않는 책이다.  
현재 ES6 자바스크립트는 예전 자바스크립트 3.1 엔진처럼 전혀 그렇게 돌아가지 않는다.  
스펙 문서 자체가 다르다.  

자바스크립트 엔진 구동 원리 같은 걸 깊이 파고들지 마라.  
자바스크립트 엔진은 해마다 엔진 스펙에 변화가 있기 때문에 어떤 엔진 스펙을 깊게 알았다는 것이 강점이 되지 않는다.  
내년도에 완전히 달라질 수 있다.  
이런 기저층의 작동원리를 배우기 보다는 이 개념이 무엇을 의미하는지 추상적인 의미를 공부하는 것이 훨씬 좋다.  

![](/static/img/codespitz/image74.jpg)

**COMPLETION RECORD들은 RECORD를 뭘로 할지 FLOW에 관여할 수 있다.**  
COMPLETION RECORD이 하는 일 : 어떤 RECORD를 선택할지를 고민한다.  

'문'은 컴파일러에게 주는 '힌트'일 뿐이다.  
IF문이나 FOR문을 쓰면 COMPLETION RECORD가 어떻게 작동할지를 알려주는 힌트가 될 뿐이다.  

## DIRECT FLOW CONTROL (직접 흐름 제어) - 역사 굉장히 오래됨

플로우 컨트롤을 하기 위한 별도의 언어 : if, switch, for, while...

### LABEL (유일한 직접 흐름 제어 방법)

현재 자바스크립트에서 사용할 수 있는 **DIRECT FLOW CONTROL**은 **LABEL**이다.  
다중 for 문을 썼을 때 바깥쪽 for 문으로 빠져나오고 싶을 때, break를 걸려면 LABEL이란 걸 써야한다.  

* identifier : 자바스크립트 변수 이름 규칙과 한가지만 다르다. $를 LABEL 이름에 쓸 수 없다는 점.  

![](/static/img/codespitz/image75.jpg)
![](/static/img/codespitz/image76.jpg)
![](/static/img/codespitz/image77.jpg)

LABEL 외에 실제로 존재하는 '문'이 하나도 없으면 에러가 발생한다.  
LABEL은 내부적으로 '문'이 아니라는 뜻이다.  
LABEL은 브라우저 해석기가 볼 때는 '문'이 아니라는 것.  

LABEL은 레코드에 달아주는 일종의 TAG(꼬리표) 같은 녀석인 것이다.  

![](/static/img/codespitz/image78.jpg)
![](/static/img/codespitz/image79.jpg)

원래 LABEL은 같은 스코프 안에 동일한게 두 개가 나오면 에러가 뜨는데, 안뜨네?  
파이어폭스로 확인해도 안 뜬다.  
원래는 오류 뜨는 게 맞음~!

![](/static/img/codespitz/image80.jpg)

### LABEL의 SCOPE

BLOCK SCOPE?  
FUNCTION SCOPE?  

LABEL은 '문'도 아니고 '식'도 아닌데 무엇으로 SCOPE가 결정될까?  
**LABEL의 SCOPE는 FUNCTION으로 결정된다.**

>LABEL 스코프 만드는 방법  
>![](/static/img/codespitz/image81.jpg)  
>LABEL 뒤에 {}를 하면 된다.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // 이런식으로 LABEL SCOPE를 나눠주면 아래처럼 작성 가능
    // 원래 이렇게 하면 바깥 LABEL의 스코프와 안쪽 LABEL의 스코프가 다르므로 스코프에 대한 쉐도윙이 일어난다.
    // 함수 지역변수도 바깥 지역변수를 가릴 수 있는 것처럼 아래 내부 abc도 바깥 abc LABEL을 가릴 수 있다.
    abc:{
        abc:{

        }
    }
</script>
</body>
</html>
```

영상에서 사파리는 LABEL SCOPE를 아예 인정하지 않는다고 에러문구가 뜸.  
LABEL은 그만큼 오래된 기법이다보니.. 스펙이 계속 바뀌기도하고 그런가 봄.  

LABEL은 빠져나오기 위해 존재한다.  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    abc:{
        console.log('start');
        if (true) break abc;
        console.log('end');
    }
</script>
</body>
</html>
```

![](/static/img/codespitz/image82.jpg)
![](/static/img/codespitz/image83.jpg)

FLOW 제어에 성공하였다.  
LABEL 스코프를 생성하고나면, LABEL 스코프에선 LABEL을 빠져나올 수 있는 권리가 주어진다.  
LOOP 문은 아니라 continue 문은 사용하지 못하지만 break 문은 사용할 수 있다.

이것이 우리가 할 수 있는 가장 원초적인 FLOW CONTROL이다.

LABEL이 아닌 곳에서도 이것을 할 수 있을까?  
그럴려면 LABEL을 나눠줘야된다.  
이것을 **LABEL RANGE**라고 한다.

### LABEL RANGE & SET

LABEL RANGE를 이해하려면 SET을 먼저 인식해야 한다.  
어떻게해서 LABEL이 LABEL 영역을 가지는지를 알아야된다는 것이다.  
위에선 LABEL SCOPE를 생성해주었지만 SCOPE를 생성해주지 않았을 때, 하나의 LABEL이 어디까지 영역을 잡느냐는 것이다.  

1. LABEL에 특별한 무언가가 없다면 다음 LABEL까지를 범위로 삼는다.
2. LABEL 다음에 Iteration(for, while..)이 오거나 Switch가 오면 범위를 한정짓는다.  
   LABEL 다음에 for문이면 해당 LABEL의 범위는 그 for문까지~! 다음 LABEL이 없어도~!

![](/static/img/codespitz/image84.jpg)

break abc;를 했어도 다음으로 넘어가질 않는다.
위에서 LABEL RANGE는 특별한 경우가 없는 이상 다음 LABEL 까지라고 했다.  
하지만 `break`가 에러는 안 났지만 건너뛰진 않는다.  

그래서 `break`로 건너뛸 수 있게 하려면 반드시 다음 3가지 구문 중 한 가지를 사용하여 LABEL을 써야된다.

1. LABEL SCOPE를 선언하라.
2. Iteration LABEL이 되어라. 
3. Switch LABEL이 되어라.

이렇게 써야 break 또는 루프구문 한정 continue를 쓸 수 있다.  
LABEL은 if문이나 for 문이 있기 전에 개발자들이 직접 FLOW를 컨트롤하던 흔적이다.  
**LABEL은 break, continue와 같은 문밖에 사용 못한다. 즉, 아래로 내려가는 FLOW 제어밖에 못한다.**  
LABEL만 가지고 LOOP 문은 못 만든다. 아래로만 흐르기 때문에.  

LABEL SCOPE만 잘 생성해주면 LABEL만 가지고 건너뛰는 FLOW를 만들 수 있다. 함수처럼.  
단지 반복적인 실행은 못한다. 위로는 못 올라가니깐.  

>**break**  
>위에 LABEL에선 break 뒤에 LABEL 이름을 붙여줘야 했다.  
>그런데 for나 while문에선 그런거 없이 왜 break 문만으로 빠져나갈 수 있는 걸까?  

![](/static/img/codespitz/image85.jpg)

위 break 문은 왜 실행이 되는거야?  
아까 위에서 break 문에 LABEL 이름을 안 주면 Syntax Error 가 발생했잖아?  

>**LABEL문을 권장하는 이유**  
>다른 문은 Run time에서 에러가 잡힌다.  
>그런데 LABEL은 바로 Syntax Error로 떨어진다.  
>Parsing할 때 다 검사한다는 것이다.  
>훨씬 더 에러를 빨리 찾을 수 있다.

![](/static/img/codespitz/image86.jpg)

자바스크립트 엔진이 위와 같이 알아서 LABEL 이름을 생성해서 넣어준 것이다.  
우리가 이름을 직접 줘도 되지만, 이름을 생략하면 break 문 뒤에, 그리고 for문 앞에 이름이 임의로 들어가게 된다.  
이것이 바로 **AUTO LABEL** 기능이다.  

### AUTO LABEL

이런 AUTO LABEL 기능은 ITERATION(FOR, WHILE), SWITCH 문에서 발동된다.  
그래서 이런 AUTO LABEL이 만들어낸 이름을 **UNDEFINED NAMED LABEL**이라고 한다.  
LABEL SCOPE는 자동으로 만들어지지 않는다. (명심!)

### AS COMMENT

LABEL을 COMMENT로 사용하는 경우도 있다.  
LABEL을 왜 주석 대신 사용하지?  

```javascript
console.log('abcd'); // a
console.log('adfjasl;dfjals;dfjsa;ldf'); // b
console.log('asdfkldjsdfdsfsdf;'); // c
```

주석이 지저분하게 달려있다.  

```javascript
a: console.log('abcd');
b: console.log('adfjasl;dfjals;dfjsa;ldf');
c: console.log('asdfkldjsdfdsfsdf;');
```

그래서 이렇게 앞 주석으로 사용하기 위해 LABEL을 사용하는 경우가 많다.  
LABEL은 코드에 부하를 걸지 않는다.  
어차피 만들어진 레코드에 달리는 태그이기 때문이다.  

```javascript
for (let i=0; i<10; i++) {
    console.log(i);    
}

function a() {
    console.log('함수a');
}
a();

temp38:
for (let i=0; i<10; i++) {
    if (i === 5) break temp38;    
}
```

![](/static/img/codespitz/image87.jpg)

이것이 abc 언어의 유일한 예외.  
의외로 강력한 LABEL 구문.  
의외로 많이 쓰인다.  

## SWITCH

* SPECIAL LABEL BLOCK

```javascript
// for문 다음에 나오는 중괄호는 단문, 중문 각각 경우에 따라 맞게 써준다.
for (let i=0; i<10; i++) {
    console.log(i);    
}

// switch 문의 중괄호는 반드시 있어야 한다. 
// 단문, 중문의 의미가 아니다.
// 이것은 문법적인 token이다.  
// 이건 함수의 몸체를 나타내는 것도 아니고 중문을 의미하는 것도 아니다. 
// 단지 switch의 몸체를 나타내는 전용 토큰일 뿐이다.
// 이 switch 뒤에 오는 {} 은 스페셜 LABEL BLOCK을 만든다. case1, case2, ..., default를 쓸 수 있는..
// switch 문 : 특별한 레이블 영역을 선언할 수 있는 공간을 만들어주는 문법이다.
// 일반 LABEL과 똑같다. 소괄호안에 내용과 case 뒤에 내용을 서로 비교한다는 것 빼곤.
switch (true) {
  
}
```

* Fall Through

`case` 뒤에 `break` 문을 안 쓰면 밑에 case들이 계속해서 실행되는 현상이다.  
`switch` 문에 case마다 break가 없으면 아래 case들이 실행되면 안되는데 실행된다고 해서 switch 문을 굉장히 낮게 평가하는 사람들이 있다.  
하지만 그건 모르는 소리다.  
LABEL의 기본 특성만 이해하면 이런 소리가 안 나온다.  
Fall Through는 너무나도 당연한 작동인거고, switch case에서 break를 걸면 어디로 빠져나온다?  
**UNDEFINED NAMED LABEL**로 빠져나오게 된다는 것이다.  
switch문 앞에 **AUTO LABEL** 만들어준다고 했으니깐.  

![](/static/img/codespitz/image88.jpg)

special label block에 이상한 label 구문을 써서 오류가 난다.  
special label block 안에 쓸 수 있는 label은 case와 default 뿐이다.  

```javascript
// switch 문이 어려운 이유
// switch {} 안에 문들을 처리하는 방식이 '언어'마다 다르다.
// 자바스크립트는 위에서 아래로 처리한다.
switch (true) {
    default: console.log('c');
    case true: console.log('a');
    case false: console.log('b');
}
```

![](/static/img/codespitz/image89.jpg)

현재 크롬 작동법을 보면 `default`는 따로 처리하는 것 같다.  

![](/static/img/codespitz/image90.jpg)
![](/static/img/codespitz/image91.jpg)
![](/static/img/codespitz/image92.jpg)

값평가에서 default는 우선순위가 낮다.  
case에도 일치하는 값이 없으면 default 부터 아래로 실행된다.  
case와 일치하는 부분이 생기면 그 부분부터 실행된다.

```javascript
temp17 :
switch (true) {
    default: console.log('c');
    case true: console.log('a'); break temp17;
    case false: console.log('b');
}
```

![](/static/img/codespitz/image93.jpg)
![](/static/img/codespitz/image94.jpg)

break 뒤에 LABEL 이름 안 붙이는 게 더 신기한 상황이다.  
우리는 항상 for, while, switch 같은 문만 써와서 몰랐을 뿐이다.  

### RUNTIME SWITCH

자바스크립트의 case 문은 런타임에서 해석한다.

47:17