---
title: 3. iterator generator 공부
layout: post
date: '2020-06-15 18:38'
categories:
- codespitz
---

## 3. iterator generator 공부

![](/static/img/codespitz/image17.jpg)

자바스크립트 인터페이스란?

![](/static/img/codespitz/image18.jpg)

```javascript
// 키 : function(){}  
// function과 콜론은 생략 가능
{
    test(str){return true;}
}
```

![](/static/img/codespitz/image19.jpg)

인터페이스가 제시하는 조건대로만 만들면 된다.

![](/static/img/codespitz/image20.jpg)

Symbol - ES6 에 추가된 primitive 타입. 값이라는 뜻. 객체가 아니다.  
typeof로 찍으면 symbol 반환  
Symbol은 primitive 값이긴 하지만 **객체의 키로 사용할 수 있다는 특징**이 있다.  
대괄호를 통해 정의 또는 호출한다.  

```javascript
let a = {}
a[Symbol];
```

![](/static/img/codespitz/image21.jpg)

### 이터레이터만 있으면 되는 거 아니야? 왜 이터러블 객체가 필요하지?

![](/static/img/codespitz/image19.jpg)

위 이터레이트를 다시 보면, pop으로 배열을 한번만 다 빼내면 다시는 못씀.  
데이터의 원본도 사라짐.  
하지만 위 이터레이터가 데이터의 사본을 만들고 데이터의 사본을 가지고 반복문을 돈다고 생각하면, 
리셋만 하면 얼마든지 여러번 돌 수 있겠죠?

그래서 루프를 다시 돌 수 있는 리셋타이밍이 필요해.  
그것이 바로 이터러블.
어터러블에게 이터레이터 객체를 요청할 때 이터레이터 객체를 리셋하거나 다시 만들어줄 찬스가 생기는 것.  

**그래서 여러번 루프를 돌 때마다 루프를 위한 변수와 원본 데이터를 구분해서 
이터레이터를 잘 구축하라고 이터러블이 한번 개입하는 것**  
이터러블이 이터레이터를 한번 요청하는 행위에서 새로운 이터레이터 객체를 만들던지, 아니면 데이터를 리셋할 기회를 주던지.  
이렇게 하면 루프를 여러번 돌려도 객체가 안 깨지기 때문에 이걸 구현하라고 이터러블을 통해서 이터레이터 객체를 얻게 되어있다.  

---

이런 패턴은 거의 모든 언어에 있다.  
디자인 패턴의 한 종류  
이터레이터 패턴을 준수하는 언어는 대부분 이런 게 되고, 이거를 사용하는 특별한 루프문을 제공해준다.  

![](/static/img/codespitz/image22.jpg)

### 그러면 우리는 왜 이터레이터를 쓰지? 우리에게는 멋있는 abc 언어인 for, while, do while이 있는데 왜 이런걸 쓰는거야?

1. statement : 문 - 엔진한테 주는 힌트. 실행한번되면 흔적도 없이 사라진다.
2. expression : 값 - 메모리에 남는다. 따라서 언제든지 조회할 수 있고 참조할 수 있다.

즉, for, while, do..while 문은 '문(statement)'이기 때문에 흔적도 없이 사라진다.  
두 번 다시 이 '문'을 반복시킬 수 없다.  
두 번 다시 쓸 수 없기 때문에 또 반복'문'을 작성하던지, 아니면 함수로 만들어서 다시 호출하던지, 
이 방법밖엔 없다. 

**그래서 우리는 루프를 '식'으로 바꾸고 싶다.**  
왜?  
여러번 재현하거나, 중간에 멈추거나 아니면, 이 루프라는 행위 자체를 객체화 시킬 수 있기 때문이다.  

**현대 언어의 중요한 패러다임**은 '문'을 제거하고 죄다 '식'으로 바꾸는 것이다.  
기존에 '문'만이 할 수 있었던 것들을 '식', '값'으로 바꾸려고 한다.  
그렇다면, 모든 '문'을 '식(값)'으로 바꾸기 위해 죄다 함수에 집어넣어버리면 
우리는 함수를 값으로 잡을 수 있기 때문에 해당 함수를 호출하면 실행되겠지?  

그러면 여러번 그 '문'을 반복해서 실행할 수 있네?  

원래 '문'은 메모리에 적재돼서 한번 실행되고 나면 폰노이만 머신 모델에서 말했듯이 
메모리에서 사라진다.  
하지만 함수에 담아놓으면 메모리에서 사라지지 않기 때문에 몇번이고 다시 실행할 수 있다.  
기본적인 FLOW 흐름에 따라 실행하는 것이 아닌 내가 원할 때 아무때나 불러서 실행할 수 있다.  

이러한 기저에서 보면 현대 언어는 '문'을 죄다 '식(값)'으로 바꾸려고 한다.  
디자인 패턴 깊게 공부하시면 커멘드 패턴이라는 게 있는데 이 패턴이 우리가 생각하는 '문'을 
'값'으로 바꿔서 우리가 마음대로 호출할 수 있게 해주는 패턴이다.  

이러한 철학 하에서 보면, for문과 while문을 식으로 바꾸고 싶어.  
그런데 얘네는 특수한 경우니까 커멘드 패턴추룸 일반적인 객체로 바꿀 필요는 없고 
(사실 커멘트 패턴으로 이터레이터 대체 가능)  
하지만 거기까지 갈 필요 없고 **반복 전용에 해당되는 객체**로만 바꿔주면 될 듯.

이것이 바로 **이터레이터 패턴**

---

![](/static/img/codespitz/image23.jpg)
![](/static/img/codespitz/image24.jpg)

이터레이터 객체와 next 객체가 **반복 자체를 하지는 않는다.**
반복 자체를 하진 않지만, 외부에서 이를 이용해 반복하려고 하면, 이제는 위 iterator interface 안에 반복을 할지말지 내용도 들어있고 
반복했을 때 어떤일을 해야할지의 내용도 위의 iterator interface 안에 들어있다.  
이를 **Self Description**이라고 부른다.  
내가 내 자신을 설명하는 것.

![](/static/img/codespitz/image25.jpg)

위에서는 내가 내 자신을 설명하지 못하고 문에 있는 내용이 나를 설명한다.  
'문'이 루프를 어떻게 돌릴지를 알고 있는 것.  
하지만, 위의 iterator interface는 나 자신이 루프를 얼만큼 돌릴지를 알고 있다.

![](/static/img/codespitz/image23.jpg)

따라서 왼쪽의 제어문은 자기 주도 하에 자기가 적극적으로 루프를 돌리고 있는데,  
iterator interface에서는 반대로 스스로가 주도권을 갖고 있으니까, 반대로

![](/static/img/codespitz/image24.jpg)

iterator interface에 의존한 루프밖에 못돌린다.  
더 반복할지 말지는 iterator interface가 결정한다.  
즉, while, for 등 반복'문'은 소극적으로 변할 수밖에 없다.  
이러한 반복문들은 next만 호출할 수 있다.

심지어 더 반복될지 안될지도 모른다.  
그건 iterator interface의 next 안의 value가 결정. 
이러한 차이 때문에 while, for '문'은 한번 실행되고 말지만 iterator interface는 **self description**을 통해서 몇번이고 실행할 수 있는 것이다.   
즉, 반복을 직접하진 않지만, 외부에서 반복을 실행하려할 때 반복을 하기 위한 조건과 실행을 iterator iterface 객체가 미리 갖고 있는 것이다.

**이것이 iterator result object 이다.**  

### 반복 행위와 반복을 위한 준비를 분리시키다.

* 반복행위 - 반복문
* 반복을 위한 준비 - 이터레이터 객체

분리시켰기 때문에 위에서도 말했지만 반복 행위를 몇번이고 반복할 수 있다.  
행위는 next만 호출해주면 된다.  

---

*  여러분들이 `for` 문을 두번 쓰는데 `i`값을 제대로 맞췄을까?  
   `for` 문을 두번 쓸 때 똑같은 `for`문을 두 번 작성할 수 있는 사람은 드물다.  
   구구단 같이 쉬운 건 두 번 돌리겠지.  
   어려운 거는?  
   하지만 iterator interface 객체라면, 몇번이고 어려운 반복문을 실행시킬 수 있다.  
   **이것이 iterator 객체를 사용하려는 이유다.**  
   '문'을 사용하지 않고 '식(값)'을 사용하려는 이유.  
   폰 노이만 머신 구조에 따라 '문'은 한 번 실행되고 메모리에서 사라진다.  
   사람이 똑같은 `for`문을 두번 만드는 것은 쉽지 않다.  
   구구단 처럼 쉬운 루프면 몰라도.  
   **개발자들은 루프'문'을 쓰는 거 자체를 문제라고 본다는 뜻이다.**

---

![](/static/img/codespitz/image26.jpg)

### 사용자 방법 처리기를 통해 iterator를 소비하는 훈련

iterator 객체 : 반복을 위한 준비  
즉, 행위와 상태를 분리함.  
**즉, 우리가 행위 쪽도 짜보자는 이야기**  

---

### 사용자 반복 처리기, 직접 iterator 반복처리기를 구현

```javascript
// 첫번째 인자값 : 이터러블 객체
// 두번째 인자값 : 이 이터러블 객체가 반복될 때마다 해야될 일을 함수 f로 받는다. 
const loop = (iter, f) => {
    // 우선 이터러블인지 아닌지를 검증
    // Symbol.iterator가 function인지를 검사, 그리고 이 함수를 불러서 return 받는게 이터레이터 객체
    // 이것이 이터러블의 정의
    // 이전에는 이것이 동적 데이터를 함부로 검사한 것처럼 보였을 것이다.
    // 하지만 지금은 자바스크립트 공식 인터페이스인 이터러블을 약식으로 검증했구나. 라고 보여야됨.
    // 그리고 iter도 검증을 해줘야된다. iterator result object인지 검증 필요. 어떻게?
    // in으로 value와 done이 있는지 검증해야된다. 여기까지는 귀찮아서 안함.
    // 어쨌든 이는 단순히 런타임 값 검사가 아니라 자바스크립트 공식 인터페이스인지 아닌지를 검증하는 것으로 봐야된다.
    if (typeof iter[Symbol.iterator] == 'function') {
        // 이터러블 인터페이스를 통해서 이터레이터를 얻었다.
        iter = iter[Symbol.iterator]();
    }else return;

    // iterator result object가 아니라면 건너뜀
    if (typeof iter.next != 'function') return;

    // 위 과정을 통과하면 드디어 루프를 돈다.
    // 아래 루프처리기는 아무 일도 못함. 그냥 돌린다라는 행위말고는 아무 것도 못함.
    // 그렇기 때문에 while 안에 true가 들어감. 무한루프를 돔.
    // 기본적으로 아래 루프문은 반복말고는 다른걸 할 생각이 없는 것이다.
    // 아래 while은 단순히 반복기일 뿐. 아무런 권한과 책임이 없다.
    // 이건 재귀함수로 짜도 상관없다. next의 결과값 done이 true일 때까지만 도는 재귀함수로 짜도 상관 없다는 것.
    do{
        const v = iter.next();
        if (v.done) return; // 종료처리
        f(v.value); // done이 false라면 현재 값을 전달함
    }while(true)
}
```

반복될 때의 조건에 해당하는 값들과, 반복기를 분리했더니  
반복기 쪽에서는 그냥 돌리기만하면 되는, 즉, 책임이 확 줄고,  
나머지 상태관리나 루프에 대한 책임은 모두 이터레이터 객체가 가져가 버렸다.

이런식으로 짜면 이터레이터 객체는 몇번이고 루프를 돌아도 안정적으로 성공할 것이다.  
여러분은 더 이상 어려운 루프를 짜지 않아도 된다는 것이다.  

```javascript
const loop = (iter, f) => {
    if (typeof iter[Symbol.iterator] == 'function') {
        iter = iter[Symbol.iterator]();
    }else return;

    if (typeof iter.next != 'function') return;

    do{
        const v = iter.next();
        if (v.done) return; 
        f(v.value); 
    }while(true)
}

const iter = {
    arr: [1, 2, 3, 4],
    [Symbol.iterator]() {return this;},
    next() {
        return {
            done: this.arr.length == 0,
            value: this.arr.pop()
        }
    }
};

loop(iter, console.log);
``` 

![](/static/img/codespitz/image27.jpg)

이것을 **이터레이터 패턴**이라고 한다.  
이런 이터레이터 패턴을 구현하는 데 있어서, 자바스크립트 표준 스펙이 나오고 이걸 구현하는 공식적인 방법이 스펙으로 정리되어있을 뿐입니다.  
여러분들이 여태 나름대로의 이터레이터를 구현해왔다면 앞으로는 자바스크립트 표준 스펙이 맞춰 이터레이터를 구현해야 된다.  

* 이유 : 언어의 혜택이 굉장히 많기 때문에

---

위의 루프를 간단하게 만든 사용자 루프 처리기라고 생각합시다.  
그럼 언어의 혜택을 받는다는 것은 무슨 말인지 살펴보자.  

### 언어의 혜택 : 내장반복처리기, Array destructuring(배열 해체)

단지 이터레이터의 스펙만 충족해주면 이러한 기능들을 사용할 수 있다는 것이다.

1. 첫번째로 배열 해체라는 것이 있습니다.  
   Array destruction이라고 불립니다.  
   해체라고 이야기하기도 하고, 분열이라고 이야기하기도 하고, 비구조화라고도 이야기합니다.  
   이는 한국말로 적당한 말이 없어서 그런 것.
   
* 아래는 이터러블 객체 : iterator result object 를 반환한다.

```javascript
const iter = {
    [Symbol.iterator]() {return this;},
    arr: [1, 2, 3, 4],
    next() {
        return {
            done: this.arr.length == 0,
            value: this.arr.pop()
        };
    }
};

// 해체 구문은 일반적으로 '할당' 즉, 변수를 선언하는 쪽에 쓰인다.
// 아래 a는 이 배열로부터 첫번째껄 얻게 된다.
// 나머지를 모아서 b에 담아라.
// 위 iterable interface 구문을 지켰을 때 아래 iter를 가상의 배열로 볼 수 있다. next()를 실행...
// 언제까지 next()를 실행? done이 true가 될 때까지..
const [a, ...b] = iter;
console.log(a, b)
```

![](/static/img/codespitz/image28.jpg)

iter는 배열도 아니었다.  
하지만 여러분들이 iterable interface의 요구 스펙만 지켜주면, 언어의 혜택을 바로 받을 수 있게된다.
  
왜냐면 처음부터 이 언어에 **해체라는 기능**은 이터러블에 반응하는 거지 배열에 반응하는 것이 아니다.  

* 이터러블을 이용해야되는 이유가 늘었다.    
  언어의 혜택을 받기 위해서

### 언어의 혜택 : 내장반복처리기, Spread(펼치기)

```javascript
const iter = {
    [Symbol.iterator]() {return this;},
    arr: [1, 2, 3, 4],
    next() {
        return {
            done: this.arr.length == 0,
            value: this.arr.pop()
        };
    }
};

// iter 값을 펼쳐서 배열에 넣어버림
// 그 배열을 a 상수에 담음
// 아까와는 반대로 값을 펼쳐서 배열에 담는다.
// 즉, 이는 해체가 아니라 스프레드라고 부른다.
// 이런 스프레드(펼치기)도 이터러블에 반응하는 것.
// 이터러블 객체가 아니면 작동하지 않는다. 반드시 이터러블 객체여야 된다.
const a = [...iter];
console.log(a)
```

![](/static/img/codespitz/image29.jpg)



33:57

https://www.youtube.com/watch?v=xTaCosid1-k&list=PLBNdLLaRx_rIF3jAbhliedtfixePs5g2q&index=4








