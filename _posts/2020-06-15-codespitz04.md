---
title: 3. iterator generator 공부
layout: post
date: '2020-06-15 18:38'
categories:
- codespitz
---

## 3. iterator generator 공부

![](/static/img/codespitz/image17.jpg)

자바스크립트 인터페이스란?

![](/static/img/codespitz/image18.jpg)

```javascript
// 키 : function(){}  
// function과 콜론은 생략 가능
{
    test(str){return true;}
}
```

![](/static/img/codespitz/image19.jpg)

인터페이스가 제시하는 조건대로만 만들면 된다.

![](/static/img/codespitz/image20.jpg)

Symbol - ES6 에 추가된 primitive 타입. 값이라는 뜻. 객체가 아니다.  
typeof로 찍으면 symbol 반환  
Symbol은 primitive 값이긴 하지만 **객체의 키로 사용할 수 있다는 특징**이 있다.  
대괄호를 통해 정의 또는 호출한다.  

```javascript
let a = {}
a[Symbol];
```

![](/static/img/codespitz/image21.jpg)

### 이터레이터만 있으면 되는 거 아니야? 왜 이터러블 객체가 필요하지?

![](/static/img/codespitz/image19.jpg)

위 이터레이트를 다시 보면, pop으로 배열을 한번만 다 빼내면 다시는 못씀.  
데이터의 원본도 사라짐.  
하지만 위 이터레이터가 데이터의 사본을 만들고 데이터의 사본을 가지고 반복문을 돈다고 생각하면, 
리셋만 하면 얼마든지 여러번 돌 수 있겠죠?

그래서 루프를 다시 돌 수 있는 리셋타이밍이 필요해.  
그것이 바로 이터러블.
어터러블에게 이터레이터 객체를 요청할 때 이터레이터 객체를 리셋하거나 다시 만들어줄 찬스가 생기는 것.  

**그래서 여러번 루프를 돌 때마다 루프를 위한 변수와 원본 데이터를 구분해서 
이터레이터를 잘 구축하라고 이터러블이 한번 개입하는 것**  
이터러블이 이터레이터를 한번 요청하는 행위에서 새로운 이터레이터 객체를 만들던지, 아니면 데이터를 리셋할 기회를 주던지.  
이렇게 하면 루프를 여러번 돌려도 객체가 안 깨지기 때문에 이걸 구현하라고 이터러블을 통해서 이터레이터 객체를 얻게 되어있다.  

---

이런 패턴은 거의 모든 언어에 있다.  
디자인 패턴의 한 종류  
이터레이터 패턴을 준수하는 언어는 대부분 이런 게 되고, 이거를 사용하는 특별한 루프문을 제공해준다.  

![](/static/img/codespitz/image22.jpg)

### 그러면 우리는 왜 이터레이터를 쓰지? 우리에게는 멋있는 abc 언어인 for, while, do while이 있는데 왜 이런걸 쓰는거야?

1. statement : 문 - 엔진한테 주는 힌트. 실행한번되면 흔적도 없이 사라진다.
2. expression : 값 - 메모리에 남는다. 따라서 언제든지 조회할 수 있고 참조할 수 있다.

즉, for, while, do..while 문은 '문(statement)'이기 때문에 흔적도 없이 사라진다.  
두 번 다시 이 '문'을 반복시킬 수 없다.  
두 번 다시 쓸 수 없기 때문에 또 반복'문'을 작성하던지, 아니면 함수로 만들어서 다시 호출하던지, 
이 방법밖엔 없다. 

**그래서 우리는 루프를 '식'으로 바꾸고 싶다.**  
왜?  
여러번 재현하거나, 중간에 멈추거나 아니면, 이 루프라는 행위 자체를 객체화 시킬 수 있기 때문이다.  

**현대 언어의 중요한 패러다임**은 '문'을 제거하고 죄다 '식'으로 바꾸는 것이다.  
기존에 '문'만이 할 수 있었던 것들을 '식', '값'으로 바꾸려고 한다.  
그렇다면, 모든 '문'을 '식(값)'으로 바꾸기 위해 죄다 함수에 집어넣어버리면 
우리는 함수를 값으로 잡을 수 있기 때문에 해당 함수를 호출하면 실행되겠지?  

그러면 여러번 그 '문'을 반복해서 실행할 수 있네?  

원래 '문'은 메모리에 적재돼서 한번 실행되고 나면 폰노이만 머신 모델에서 말했듯이 
메모리에서 사라진다.  
하지만 함수에 담아놓으면 메모리에서 사라지지 않기 때문에 몇번이고 다시 실행할 수 있다.  
기본적인 FLOW 흐름에 따라 실행하는 것이 아닌 내가 원할 때 아무때나 불러서 실행할 수 있다.  

이러한 기저에서 보면 현대 언어는 '문'을 죄다 '식(값)'으로 바꾸려고 한다.  
디자인 패턴 깊게 공부하시면 커멘드 패턴이라는 게 있는데 이 패턴이 우리가 생각하는 '문'을 
'값'으로 바꿔서 우리가 마음대로 호출할 수 있게 해주는 패턴이다.  

이러한 철학 하에서 보면, for문과 while문을 식으로 바꾸고 싶어.  
그런데 얘네는 특수한 경우니까 커멘드 패턴추룸 일반적인 객체로 바꿀 필요는 없고 
(사실 커멘트 패턴으로 이터레이터 대체 가능)  
하지만 거기까지 갈 필요 없고 **반복 전용에 해당되는 객체**로만 바꿔주면 될 듯.

이것이 바로 **이터레이터 패턴**

---

![](/static/img/codespitz/image23.jpg)
![](/static/img/codespitz/image24.jpg)

이터레이터 객체와 next 객체가 **반복 자체를 하지는 않는다.**

18:47

https://www.youtube.com/watch?v=xTaCosid1-k&list=PLBNdLLaRx_rIF3jAbhliedtfixePs5g2q&index=4








