---
title: 6. GENERATOR, PROMISE, ASYNC/AWAIT
layout: post
date: '2020-06-22 21:55'
categories:
- codespitz
---

## 6. GENERATOR, PROMISE, ASYNC/AWAIT

GENERATOR - 여태껏 iterator를 반환해주는 편리한 용법 정도로만 바라봤다.  
그런데 이번 시간엔 iterator를 반환해주는 걸로 보지 않고 **제어문을 중간에 멈출 수 있는 능력을 가진 실행기의 일종**으로 볼 것이다.  

## BREAKING BLOCK

프로그램을 중도에 멈췄다가 다시 실행할 수 있다.  
프로그램을 적재한 순간 실행이 종료될 때까지 멈출 수 없는 건데, 제너레이터는 서스팬션이라는 기능으로 중간에 제어문을 멈출 수 있다.  
이렇게 중간에 멈출 수 있는 기능을 언어가 갖기 위해선 언어가 직접 명령어를 메모리에 적재하지 않고 한번 더 감싸서 이 감싼걸 실행시킬지 말지를 정해야 된다.  
자바스크립트는 명령어 한줄 한줄을 레코드로 만들어 적재한다.  
이 레코드를 실행할지 말지를 보는 거다.  

여러분들은 '문'을 사용해 코드를 짰지만 자바스크립트는 이런 '문'을 마치 객체처럼 만들어서 중간에 실행할지 말지를 정하는 것이다.  
이러한 언어들은 여러분들이 딱히 '객체'를 안 만들어도 '문' 수준에서 이런 기능이 다 된다.  
이러한 기능을 제공하지 않는 언어라면 여러분들이 직접 '문'을 '객체'처럼 만든 다음에 실행할지 말지를 결정해야 된다.  

이 패턴이 바로 **커맨드 패턴**이다.  
디자인 패턴 중에 **커맨트 패턴**이라고 있는데, 커맨드 패턴은 '문'을 하나하나의 객체로 만들어서 어디까지 실행할지, 되돌릴지, 그만할지, 더 할지를 
결정해줄 수 있다.  

그래서 **커맨드 패턴**을 사용하면 undo나 redo가 되는 이유가 바로 이거다.  
원래 '문'은 한 번 실행하면 끝인데, 커멘드 패턴으로 만들면 undo, redo, 매크로 등등을 만들 수 있다.  
'문'을 '객체'화 시켰기 때문.

자바스크립트, 파이썬, C# 같은 서스팬션 기능을 제공해주는 언어들은 어떻게 이를 제공해 줄까?  
내부적으로 커멘드 객체로 '문'을 다 바꿨기 때문에 가능한 일이다.  

```javascript
// 아래 제너레이터는 무한히 루프문을 돌지만 
// next를 호출할 때 한 번씩만 돌기 때문에 
// 아래 식은 프레임을 다운시킬 일이 없다.
// 원래 아래 while 문은 무한으로 도니까 timeout 걸려서 죽어야 하는데 yield로 그 순간 프레임을 멈출 수 있다.
// 우리가 배운 프로그래밍 상식상 불가능한 일
const infinity = (function*() {
    let i = 0;
    while(true) yield i++;
})();
console.log(infinity.next());
console.log(infinity.next());
```

이런 불가능한 것이 가능한 이유는 중간에 `yield`로 제어문을 멈출 수 있기 때문이다.  
**yield를 이용하면 블록을 중간에 끊어주는 효과가 발생한다.**  

블로킹 : FLOW에서 제어권을 넘기지 않는 것(CPU 먹통)

그런데 제너레이터를 활용하면 CPU에게 제어권을 다시 넘겨주고 멈출 수 있다.  
이 성질을 이용해보자.

### BLOCKING EVASION

Time slicing manual

```javascript
// 한번에 3개씩 처리 - timeout의 위험성을 줄이고 있다
const looper = (n, f, slice = 3) => {
    let limit = 0, i = 0;
    const runner = _ => {
        while(i < n) {
            if (limit++ < slice) f(i++);
            else {
                limit = 0;
                requestAnimationFrame(runner);
                break;
            }
        }
    }
    requestAnimationFrame(runner);
}
looper(10, console.log);
```

위 식을 제너레이터로 바꿔보자.

```javascript
// 차이점 - 기존 식에선 다음 프레임으로 함수를 넘겼는데, 제너레이터는 yield로 중지시켰다.  
const loop = function*(n, f, slice = 3) {
    let limit = 0, i = 0;
    while(i < n) {
        if (limit++ < slice) f(i++);
        else {
            limit = 0;
            yield;
        }
    }
}

// 이런 제너레이터를 실행하는 실행기 필요
// 이 실행기가 처리하는 것을 보면, iter(iterator)를 받아서 
// iterator 객체의 done이 true인지 false인지 판단 후, false이면 다음 프레임에 runner를 실행시키도록 했다.
// 즉, 이 실행기는 iterator를 받아서 iterator를 requestAnimationFrame으로 실행시켜버린다.
const executor = iter => {
    const runner = _ => {
        if (!iter.next().done)
            requestAnimationFrame(runner);
    };
    requestAnimationFrame(runner);
}

executor(loop(10, console.log));
```

![](/static/img/codespitz/image64.jpg)

위에서 실행기는 루프가 어떻게 일어나는지 알지 못한다.  
그 이유는 루프관련 내용은 다 loop 함수에 몰려있기 때문이다.  
반면 제너레이터로 바꾸기 식을 보면 루프를 어떻게 돌리는지에 대한 로직도 있고 루프를 돌릴지 말지에 대한 판단도 같이 갖고 있다.  
**즉, 섞여있다는 것이다. 그 말은 재활용 할 수 없다는 뜻이다.**

>**또 다른 차이점 - 자율변수와 지역변수**    
>제너레이터에선 `i`, `limit` 가 지역변수로 선언되어 있다.  
>제너레이터에선 복잡한 자율변수나 스코프를 인식하지 않아도 된다.  
>제너레이터 이전 식 - 지역변수 처럼 보이지만 `runner`라는 함수를 만들 때, `자율변수`로 되어있는 스코프 바깥에 있는 변수들을 캡쳐한다.(클로져)  
>이런 식으로 되어있는 코드는 상태관리를 할 때 보다 더 복잡한 생각을 해야된다.  
>이렇다 보니까 매번 `runner` 함수를 만들어야 된다.  
>지역변수를 캡쳐하기 위해서 `runner` 함수를 만들어야 되기 때문.  
>제너레이터를 활용하니까 코드가 훨씬 직관적으로 변했다.

![](/static/img/codespitz/image65.jpg)

제너레이터를 통해 루프 추상화 성공. 실행기와 분리.  
진짜 실행기와 분리되었는지 볼까?

![](/static/img/codespitz/image66.jpg)

실행기를 `setInterval`로 갈아치워도 `loop` 함수는 한글자도 수정 안해도 된다.  
루프를 도는 로직과 실행기를 도는 로직을 완전히 분리하면 이런 효과를 볼 수 있다는 것이다.

>**우리가 추구했던 바가 뭐다?**  
>루프를 돌리는 조건이나 상태에 관한 것은 추상화하고 얘를 어떻게 루프돌릴지(스프레드, Rest, 해체, for...of 등등..)  
>이런 것들은 바깥에서 결정하도록 하자.  
>**이럴려면 루프 추상화를 이뤄야된다.**

10:46