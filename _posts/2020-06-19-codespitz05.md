---
title: 4. ABSTACT LOOP & LAZY EXECUTION
layout: post
date: '2020-06-19 13:20'
categories:
- codespitz
---

## 4. ABSTACT LOOP & LAZY EXECUTION

generator - 동기명령을 중간에 멈출 수 있는 기능이 있다. yield (이러한 기능을 suspension이라 한다), 그리고 다시 재진행한다.  
이것이 기본사항이 돼서 그걸 바탕으로 루프를 추상화시키는 것, 그리고 LAZY EXCUTION(지연실행)을 배울 것이다.  
지연실행이라는 것은 함수의 특권이다.  
여러분이 어떤 제어문을 작성했는데, 그 문이 즉시실행되지 않게 하려면 원래는 함수에 담아두고 함수를 호출할 때까지 지연되지?  
기본적으로 지연실행이라는 것은 함수호출 지연실행인데, 이걸 **함수의 호출 지연**말고도 **제너레이터**를 통해서 지연 시킬 수 있다.  
문이 다 실행되지 않고 다시 빠져나올 수 있기 때문에, **yield 밑에를 실행시키지 않고 지연시킬 수 있다.**

기존에 지연실행이 함수형 프로그래밍의 특징이자 걔네들의 특권으로 여겨졌다면, 코루틴을 지원하는 대부분의 언어에서는 
제어문으로 지연실행을 일으킬 수 있다.  
기존의 복잡한 함수형 프로그래밍 지연 실행을 지금은 다 제어문으로 실행할 수 있다.  

### 오늘 공부 목표 : 제너레이터의 지연실행 측면, 그리고 이걸 위한 추상루프화

오늘 배우는 내용에는 약간의 디자인 패턴을 포함하고 있는데, 조금 복잡하다. 천천히 살펴보도록 하자.

### ABSTRACT LOOP

루프의 추상화.  
아니 루프가 루프지 루프를 추상화해? 라고 생각할지도 모르지만, 이미 지난 시간에 이터레이터를 통해 루프를 추상화하는 방법을 공부했다.  
루프문을 쓸 때 보다 이터레이터 객체로 바꿔놓으면, 루프를 위한 상태값들을 객체가 갖고 있기 때문에 언제든지 똑같은 루프를 재현할 수 있게 되고, 
루프문의 역할이 크게 줄어드는 걸 알 수 있었다.  

기존의 제어문은 많은 역할이나 책임을 제어문이 갖고있는데 비해서, 이터레이터를 사용한 경우는, 루프문을 더 돌릴지말지, 루프마다 뭘할지말지, 
이런 결정권들이 이터레이터 객체로 넘어가기 때문에 훨씬 더 여러번 똑같은 루프를 제어할 수 있는 루프문을 만들 수 있었다.  

이 장점을 본격적으로 이용해보려고 하는 것이다.  
이전 시간까지는 이것이 진짜 제어문에 비해서 좋은건가? 아리까리한 상태였다면 이번시간에 좀 더 복잡한 루프를 해결해보자는 것이다.  

### COMPLEX RESURSION

단순한 배열 루프부터 시작해보자.  

```javascript
{
    [Symbol.iterator](){return this;},
    data:[1, 2, 3, 4],
    next(){
        return {
            done: this.data.length == 0,
            value: this.data.shift()
        }
    }
}
``` 

3:21