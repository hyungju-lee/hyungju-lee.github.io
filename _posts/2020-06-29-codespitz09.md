---
title: ES6+ 함수와 OOP 2회차
layout: post
date: '2020-06-29 13:58'
categories:
- codespitz
---

## ES6+ 함수와 OOP 2회차

>**2회차 스터디 주제**  
>1. **Spread Ref**  
>메인루틴과 서브루틴이 통신을 할 때 참조값을 활용하면 문제가 크다. 이에 대해 좀 더 살펴보도록 하자.  
>2. **Sub Routine Chain**  
>서브루틴 안에 서브루틴이 있는 경우를 깊게 살펴보면 Tail Recursion optimize라는 꼬리물기 최적화에 대해 이해할 수 있다.  
>3. **Tail Recursion**  
>위의 서브루틴 체인에 대해 이해하고 나면 꼬리물기 최적화에 성공한 재귀함수에 대해 이해가 가능하다.
>4. **Tail Recursion to loop**  
>그렇게되면 재귀함수를 손쉽게 루프로 바꿀 수 있다.
>5. **Closure**
>6. **Nested closure(중첩된 클로져)**
>7. **Shadowing**
>8. **Co routine**

### Spread ref

![](/static/img/codespitz/image141.jpg)

참조값은 잠깐 전파가 되는 것이 아니라 지속적으로 전파되어 오염을 시킨다.  
위 식에서 지난번 가이드대로 Local variable을 사용했지만, 이 지역변수조차 B를 물고있다.  
즉, 참조를 계속 물고 있기 때문에, A와 B는 참조가 서로 전파되고 있다. (서로 관계가 생기게 된다.)  
이렇게되면 나중에 어디에서 오류가 발생했는지 디버깅해도 찾을 수 없게 된다.  

![](/static/img/codespitz/image142.jpg)

새로운 참조값인 D를 추가해보자.  
D를 ROUTINEB에게 넘겼다고 해보자.  
위와 같은 식이라면 C하고 D도 서로 관계가 없다고는 못한다.  

여기서 더 최악인 경우는 D자리에 A가 넘어가는 것이다.  

위 소스는 겉보기엔 멀쩡해보이고 깔끔해보이나, 참조가 서로 얽히고 섥혀서 어디서 문제가 터질지 모르는 코드인 상태인 것이다.  
ROUTINEA만 보면 별로 문제가 아니게 보일 수도 있다.  
새로운 객체를 생성하는데 무엇이 문제가 되겠어? 라고 생각할 수 있다.  
하지만 문제는 MAIN FLOW의 A = ROUTINEA(B) 부분이다.  
이 MAIN FLOW 단계에서 A가 B와 관계된 무언가를 할 때 문제가 발생한다.  

방법은 **복사본**을 사용하는 것이다.  
**결론 : 참조를 소유한 참조 객체를 만들어도 참조의 여파는 끝나지 않는다.**  
이 모든 문제의 근원은 B를 그냥 사용하고 있다는 것이다.  
**복사본**의 개념에서 보자면 위의 LA에 B를 넘길 때 조차도 **복사본**을 넘겼어야 했다.  
인자로 넘어가는 B도 전부 `new` 처리해서 넘겨야 된다.  
B를 그냥 사용하면 간접적으로라도 서로 물리기 때문에 이 오염이 끝나질 않는다.  

### Sub routine chain

참조값을 안넘길 수는 없으니 내부에서 새로운 값을 만들어서 리턴하거나 복사본을 사용하자.  
그때의 대상이 단지 만들어진 값만을 포함하거나 만들어진 값한테 인자로만 넘겨도 위험하다.  
그러니 아예 처음부터 새로 만들고 시작하는 것이 편하다.  

<span style="color:red">(아.. 이게 작년 리액트 배울 때 딥카피 개념인가? 스프레드 연산자로 하는...)</span>

5:28