---
title: ES6+ 함수와 OOP 2회차
layout: post
date: '2020-06-29 13:58'
categories:
- codespitz
---

## ES6+ 함수와 OOP 2회차

>**2회차 스터디 주제**  
>1. **Spread Ref**  
>메인루틴과 서브루틴이 통신을 할 때 참조값을 활용하면 문제가 크다. 이에 대해 좀 더 살펴보도록 하자.  
>2. **Sub Routine Chain**  
>서브루틴 안에 서브루틴이 있는 경우를 깊게 살펴보면 Tail Recursion optimize라는 꼬리물기 최적화에 대해 이해할 수 있다.  
>3. **Tail Recursion**  
>위의 서브루틴 체인에 대해 이해하고 나면 꼬리물기 최적화에 성공한 재귀함수에 대해 이해가 가능하다.
>4. **Tail Recursion to loop**  
>그렇게되면 재귀함수를 손쉽게 루프로 바꿀 수 있다.
>5. **Closure**
>6. **Nested closure(중첩된 클로져)**
>7. **Shadowing**
>8. **Co routine**

### Spread ref

![](/static/img/codespitz/image141.jpg)

참조값은 잠깐 전파가 되는 것이 아니라 지속적으로 전파되어 오염을 시킨다.  
위 식에서 지난번 가이드대로 Local variable을 사용했지만, 이 지역변수조차 B를 물고있다.  
즉, 참조를 계속 물고 있기 때문에, A와 B는 참조가 서로 전파되고 있다. (서로 관계가 생기게 된다.)  
이렇게되면 나중에 어디에서 오류가 발생했는지 디버깅해도 찾을 수 없게 된다.  

![](/static/img/codespitz/image142.jpg)

새로운 참조값인 D를 추가해보자.  
D를 ROUTINEB에게 넘겼다고 해보자.  
위와 같은 식이라면 C하고 D도 서로 관계가 없다고는 못한다.  

여기서 더 최악인 경우는 D자리에 A가 넘어가는 것이다.  

위 소스는 겉보기엔 멀쩡해보이고 깔끔해보이나, 참조가 서로 얽히고 섥혀서 어디서 문제가 터질지 모르는 코드인 상태인 것이다.  
ROUTINEA만 보면 별로 문제가 아니게 보일 수도 있다.  
새로운 객체를 생성하는데 무엇이 문제가 되겠어? 라고 생각할 수 있다.  
하지만 문제는 MAIN FLOW의 A = ROUTINEA(B) 부분이다.  
이 MAIN FLOW 단계에서 A가 B와 관계된 무언가를 할 때 문제가 발생한다.  

방법은 **복사본**을 사용하는 것이다.  
**결론 : 참조를 소유한 참조 객체를 만들어도 참조의 여파는 끝나지 않는다.**  
이 모든 문제의 근원은 B를 그냥 사용하고 있다는 것이다.  
**복사본**의 개념에서 보자면 위의 LA에 B를 넘길 때 조차도 **복사본**을 넘겼어야 했다.  
인자로 넘어가는 B도 전부 `new` 처리해서 넘겨야 된다.  
B를 그냥 사용하면 간접적으로라도 서로 물리기 때문에 이 오염이 끝나질 않는다.  

### Sub routine chain

참조값을 안넘길 수는 없으니 내부에서 새로운 값을 만들어서 리턴하거나 복사본을 사용하자.  
그때의 대상이 단지 만들어진 값만을 포함하거나 만들어진 값한테 인자로만 넘겨도 위험하다.  
그러니 아예 처음부터 새로 만들고 시작하는 것이 편하다.  

<span style="color:red">(아.. 이게 작년 리액트 배울 때 딥카피 개념인가? 스프레드 연산자로 하는...)</span>

여러분이 만든 함수는 여러분만 쓰는 것이 아니다.  
그렇기에 꼼꼼하게 살펴야 한다.  
복사본으로 넘어가는지, 객체 참조인지 아닌지를 항상 확인하는 습관을 가져야된다.  

![](/static/img/codespitz/image143.jpg)

위와 같이 서브루틴에 서브루틴이 있으면 콜스텍에 루틴들이 쌓이게된다.  
그리고 하나씩 리턴될 때마다 스텍이 사라지게 된다.  
그리고 결과값이 리턴된다.  

![](/static/img/codespitz/image144.jpg)
![](/static/img/codespitz/image146.jpg)

Keep의 정확한 대상들이다.  
아주 정확하겐 위의 인자(arguments)와 지역변수(local variable)를 기억하는 메모리가 필요하다.  
이걸 기억한 상태에서 다음 서브루틴으로 갔다가 다시 돌아오는 것이다.  
그렇다면 함수는 호출되는 순간 하나 분량의 **미니 메모리**를 갖게되는 것이다.  
이 **미니 메모리**엔 인자와 지역변수가 들어있다.  
이것이 바로 자바스크립트에서 **excution context(실행 컨텍스트)**라고 부르는 것이다.  

함수가 호출될 때 만들어지는 것이고 이 실행 컨텍스트 안엔 인자와 지역변수가 담겨져 있다.  
이걸 해제하지 않고 그 다음 서브루틴을 부르는 것이다.  

![](/static/img/codespitz/image145.jpg)

중간에 있는 함수 콜을 끝으로 옮겼다.  
루트에서 `return` 이후는 없는 거다.  
즉 `return` 이후는 해당 함수가 끝나는 걸 의미한다.  

![](/static/img/codespitz/image147.jpg)

위가 해당 함수의 흐름이다.  
여기서 약간 아이디어를 바꿔보자는 것이다.

![](/static/img/codespitz/image148.jpg)

함수 안의 Keep 부분을 메모리에 저장할 필요가 없다면, R2의 리턴값을 Main으로 보내는 것이 어떻겠냐는 것이다.  
**리턴 포인트**는 **언어 수준에서 결정된다.**  
**언어 엔진 수준에서 함수를 호출할 때 리턴 포인트를 결정한다.**  

![](/static/img/codespitz/image149.jpg)

이 아이디어를 확장하면 위와 같은 흐름이 된다.  
**위의 함수 흐름을 보면 더 이상 <span style="color:red">콜스텍</span>이 없다.**  
이런 흐름을 바뀐다면 아까와는 굉장히 다르다.  
**아무리 많은 함수를 불러도 유지하는 메모리가 없게되는 것이다.**  
게다가 각 함수의 영역을 유지할 필요도 없다.  
리턴 포인트가 없기 때문이다.  

**이러한 흐름은 반드시 <span style="color:red">언어 수준</span>에서 도움을 줘야된다.**  
왜냐하면 함수의 **리턴 포인트**를 바꿔주는 것은 언어밖에 못하기 때문이다.  
따라서 언어가 이 기능을 지원하냐 안하냐에 따라서 **꼬리물기 최적화**를 지원하냐 안하냐가 결정되는 것이다.  

위와 같은 식의 조건은 다음과 같다.  

![](/static/img/codespitz/image150.jpg)

이것을 우리는 **꼬리물기 최적화(Tail Recursion)**라고 부르는 것이다. 

![](/static/img/codespitz/image151.jpg)

이 방법은 안타깝게도 이를 지원하는 언어에서밖에 사용 못한다.  
이를 지원하는 언어 수준에서 위와 같이 **꼬리 물기 최적화**를 활용해 소스를 짠다면 
해당 소스는 메모리를 많이 사용하지 않고, 함수 메모리를 사용하고 바로 해제하고 사용하고 헤제하는 식으로 메모리를 사용한다.  
**이는 제어문과 같은 작동원리이다.**

for문은 돌때마다 항상 그 안에 있는 것을 메모리에 유지하지 않는다.  
for문 안에 있는 내용은 다음 for문을 돌릴 때 index 변수를 제외하곤 다 해제해버린다.  
이를 **<span style="color:red">제어문의 stack clear 기능</span>**이라고 부른다.  

제어문의 루프문(for, while)들은 모두 **stack clear 기능**을 갖고 있다.

>구식 언어는 stack clear를 안해주는 언어도 있다.  
>for문 같은 제어문을 goto 언어의 우아한 버전이라고 생각하면 큰 오산이다.  
>제어문은 원래 앞에 실행되었던 stack문을 제거해버리는 기능이 있다.  
>우리가 사용하는 abc 언어의 제어루프문은 루프 블록의 stack clear 기능이 있다.  

**그런데 이를 언어가 함수 수준에서도 구현할 수 있게 해준다면, 함수 수준에서 제어문과 동일하게 소스를 짤 수 있다는 것이다.**  
위 함수 예제도 마치 for문을 돌릴 때의 메모리 동작과 같은 효과를 낸다는 것이다.  
그래서 **꼬리물기 최적화**를 지원하는 언어에서는 **for, while**문의 도움을 받지 않고도 
고성능의 루프를 만들어낼 수 있다. 

---

이게 먼나라 이웃나라 이야기일까?  
아니다. 현재 사파리가 지원하고 있다.(2018년 9월 7일 기준)  
크롬과 엣지는 아직 지원 안된다.  

**그래서 사파리에선 재귀함수를 꼬리물기 최적화해서 짠다면 몇억번을 호출해도 뻑나지 않는다.**  
이렇게하면 스크립트 타임아웃이 뻑날뿐이지 **stack overflow**로 죽지 않는다.

### Tail Recursion(꼬리물기 최적화)

![](/static/img/codespitz/image152.jpg)

이것이 재귀함수이다.  
위 재귀함수는 꼬리물기 최적화가 될까, 안될까?  
위의 함수는 현재 꼬리물기 최적화가 된거일까?  
아니다.  
`sum(2)`의 리턴값이 와서 계산되려면 `3 +`가 메모리에 남아있어야 한다.  
현재 꼬리물기 최적화를 방해하고 있는 요소는 `더하기`이다.  

**연산자는 꼬리물기 최적화를 방해한다.**  
그래서 메모리를 해제시키지 못한다.  
연산을 하기위해선 스택 메모리가 필요하다.  

그렇다면 이걸 어떻게 tail recursion하게 바꿀까?  
**메모리를 유발시키는 것을 모두 제거해야지 tail recursion을 실현시킬 수 있다.**  
제일 마지막에 **return**과 **함수콜**만 남겨야지 진짜 tail recursion을 실현시킬 수 있다는 것이다.  
한 가지 조건(마지막 return에다 함수를 콜해)은 충족시켰지만 더하기 연산자 때문에 tail recursion을 이루지 못하고 
있는 것이다.  

>가장 많이 알려진 방법  
>연산을 인자로 옮긴다.

![](/static/img/codespitz/image153.jpg)

위의 식을 보면 인자쪽에 연산을 옮겼다.  
여기서 의문이 들것이다.  
어? 3항연산자도 연산식인데 위와 같이 작성하면 3항 연산식도 stack memory에 쌓이지 않나요?  

언어에는 stack에 쌓이지 않는 연산자가 따로 정의되어 있다.  
자바스크립트 같은 경우엔 3항 연산자와 &&, || 연산자는 stack memory를 일으키지 않는다.  
이들은 tail recursion의 대상이다.  
보통 언어에선 위 세가지가 stack memory를 일으키지 않는 연산자로 지정이 되어있다.  

* truthy && A : 이럴 경우엔 A의 값만 평가하면 된다.
* falsy && A : 이럴 경우엔 A의 값을 평가하지 않아도 된다.
* truthy \|\| A : 이럴 경우엔 A의 값을 평가하지 않아도 된다.
* falsy \|\| A : 이럴 경우엔 A의 값만 평가하면 된다.

**즉, 앞의 값이 뭐냐에 따라 뒤에 값을 평가하거나 평가하지 않아도 되는 것이 이들 연산자의 특징이다.**  
**즉, 이 연산자들은 stack에 메모리를 쌓을 필요가 없다는 것이다.**  
**stack을 잡지 않아도 stack을 clear할 수 있다. 뒤로 갈지말지를 결정할 수 있기 때문이다.**  
**3항 연산자도 마찬가지이다. 맨 왼쪽을 평가한 다음에 어느 것을 불러올지를 선택하면 되기 때문에 stack에 쌓을 필요가 없다.**  

>꼬리물기 최적화가 안되어있는 함수를 꼬리물기 최적화 함수로 바꾸는 첫번째 전략은 
>내부에서 연산이나 상태를 유지해야될게 있으면 다 말아서 다음번 함수 콜에 인자로 전달하는 것이다.  
>내 메모리는 해제하고 다음 함수콜의 인자로 다 넘겨버리는 것이다.

tail recursion으로 하다보면 인자가 늘어나는데 이는 어찌보면 당연한 것이다.  

![](/static/img/codespitz/image154.jpg)

tail recursion을 언어가 지원하면 재귀적으로 돌아가지 않고 그때마다 메모리를 해제하고 마지막에 
원래 최초의 콜 포인트로 보내면 그만이라는 것이다.  
**stack memory를 활용하는 코드에서 다음 함수콜의 인자 메모리를 사용하도록 수정했다.**  

**<span style="color:red">재귀적인 로직이 있으면 앞으론 꼬리물기 최적화 형식으로 짜는 습관을 들인다!!!! 무조건!!!!!!!!</span>**

![](/static/img/codespitz/image155.jpg)

노란색 인자 메모리를 stack memory를 사용하는 연산자를 대신해 사용한다.  
왜? 내 메모리를 해제할 수 있으니깐.  
다음번 함수 메모리를 사용하면 되니깐.  

26:51