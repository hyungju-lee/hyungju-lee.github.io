---
title: total
layout: post
date: '2020-05-13 05:10:00'
categories: issue
share: false
---

[참고](https://github.com/hyungju-lee/private-hj/tree/master/00_issue/daily/200513-gulpfile)

### folder tree

![](/assets/img/issue/issue10.jpg)

### gulpfile.js

```javascript
'use strict'
/*jshint -W110 */

const fs = require('fs'),
  path = require('path'), // added
  cheerio = require('cheerio'), // added
  ejs = require('gulp-ejs'), // added
  packageJson = JSON.parse(fs.readFileSync('package.json')),
  {src, dest, watch, series, parallel, lastRun} = require('gulp'),
  del = require('del'),
  merge = require('merge-stream'),
  browserSync = require('browser-sync').create(),
  vinylBuffer = require('vinyl-buffer'),
  spritesmith = require('gulp.spritesmith-multi'),
  gitDateExtractor = require('git-date-extractor'),
  getRepoInfo = require('git-repo-info'),
  $ = require('gulp-load-plugins')({
    camelize: true
  }),
  gulpConfig = {
    autoprefixer: ['> 1%', 'last 2 versions', 'iOS 5', 'Android 2.3', 'FF 20', 'IE 8'],
    deployMessage: '[UPDATE] deploy to gh-pages',
    src: './src',
    dist: './dist',
    // sprite-hash option
    spriteHash: true,
    // ejs-template's global variables
    ejsVars: {
    }
  },
  fileIncludeConfig = {
    "prefix": "@@",
    "basepath": "@file",
    "context": {}
  };

function sprites() {
  const opts = {
    spritesmith: function (options, sprite, icons) {
      options.imgPath = `../img/${options.imgName}`;
      options.cssName = `_${sprite}-mixins.scss`;
      options.cssTemplate = `${gulpConfig.src}/scss/vendor/spritesmith-mixins.handlebars`;
      options.cssSpritesheetName = sprite;
      options.padding = 4;
      options.algorithm = 'binary-tree';
      return options
    }
  };

  const spriteData = src(`${gulpConfig.src}/img/sprites/**/*.png`)
    .pipe(spritesmith(opts)).on('error', function (err) {
      console.log(err)
    });

  const imgStream = spriteData.img
    .pipe(vinylBuffer())
    .pipe($.pngquant({
      quality: '90'
    }))
    .pipe(dest(`${gulpConfig.src}/img`));

  const cssStream = spriteData.css
    .pipe(dest(`${gulpConfig.src}/scss/vendor`));

  return merge(imgStream, cssStream)
}

function update_normalize() {
  return src([
    `./node_modules/normalize.css/normalize.css`
  ])
    .pipe($.rename({
      prefix: '_',
      extname: '.scss'
    }))
    .pipe(dest(`${gulpConfig.src}/scss/common`))
}

function sass() {
  return src([
    `${gulpConfig.src}/scss/**/*.{scss, sass}`,
    `!${gulpConfig.src}/scss/vendor/*-mixins.scss`
  ], {sourcemaps: true})
    .pipe($.sassGlob())
    .pipe($.sass({
      errLogToConsole: true,
      outputStyle: 'compressed'
    }).on('error', $.sass.logError))
    .pipe($.autoprefixer({
      overrideBrowserslist: gulpConfig.autoprefixer,
      remove: false,
      cascade: false
    }))
    .pipe(dest(`${gulpConfig.src}/css`))
    .pipe(dest(`${gulpConfig.dist}/css`, {sourcemaps: true}))
}

function getFolders(dir) {
  let result = [];
  if (fs.statSync(dir).isDirectory()) {
    result = fs.readdirSync(dir).filter((file) => fs.statSync(path.join(dir, file)).isDirectory());
  }
  return result;
}

async function spriteSvg() {
  const folders = getFolders(`${gulpConfig.src}/img/sprites-svg`);

  let options = {
    spritesmith: (options) => {
      const { folder, gulpConfig } = options;
      return {
        shape: {
          spacing: {
            padding: 4
          },
          id: {
            generator: function (name) {
              return path.basename(name.split(`${gulpConfig.src}/scss/vendor`).join(this.separator), '.svg');
            }
          }
        },
        mode: {
          css: {
            dest: './',
            bust: false,
            sprite: folder + '-svg.svg',
            render:  {
              scss: {
                template: path.join(`${gulpConfig.src}/scss/vendor`, 'sprite-svg-mixins.handlebars'),
                dest: path.posix.relative(`${gulpConfig.src}/img`, path.posix.join(`${gulpConfig.src}/scss`, 'vendor', '_'+folder+'-svg-mixins.scss'))
              }
            }
          }
        },
        variables: {
          spriteName: folder,
          baseName: path.posix.relative(`${gulpConfig.src}/css`, path.posix.join(`${gulpConfig.src}/img`, folder + '-svg')),
          svgToPng: ''
        }
      }
    },
  };

  return folders.map((folder) => {
    return new Promise((resolve) => {
      src(path.join(`${gulpConfig.src}/img/sprites-svg`, folder, '*.svg'))
        .pipe($.sort())
        .pipe($.svgSprite(options.spritesmith({folder, gulpConfig})))
        .pipe(dest(`${gulpConfig.src}/img`))
        .on('end',resolve);
    });
  });
}

function optimize_png() {
  // TODO: 'guip-filter' can be replaced by 'gulp-ignore'
  // see https://github.com/robrich/gulp-ignore and minimatch
  return src([
    `${gulpConfig.src}/img/**/*.png`,
    `!${gulpConfig.src}/img/**/*.ani.png`,
    `!${gulpConfig.src}/img/**/sprite*.png`,
  ], {since: lastRun(optimize_png)})
    .pipe($.pngquant({
      quality: '90'
    }))
    .pipe(dest(`${gulpConfig.src}/img`))
}

function optimize_others() {
  return src([
    `${gulpConfig.src}/img/**/*.{gif,jpg,jpeg,svg}`,
    `!${gulpConfig.src}/img/**/sprite*.svg`,
  ], {since: lastRun(optimize_others)})
    .pipe($.imagemin([
      $.imagemin.gifsicle({
        interlaced: true
      }), // gif
      $.imagemin.jpegtran({
        progressive: true
      }), // jpg
      $.imagemin.svgo({ // svg
        plugins: [
          {removeViewBox: true},
          {cleanupIDs: false}
        ]
      })
    ], {
      verbose: true
    }))
    .pipe(dest(`${gulpConfig.src}/img`))
}

function copy_image() {
  return src([
    `${gulpConfig.src}/img/**/*`,
    `!${gulpConfig.src}/img/sprites`,
    `!${gulpConfig.src}/img/sprites/**/*`,
    `!${gulpConfig.src}/img/sprites-svg`,
    `!${gulpConfig.src}/img/sprites-svg/**/*`,
  ])
    .pipe(dest(`${gulpConfig.dist}/img`))
}

function process_html() {
  return src([
    `${gulpConfig.src}/html/**/*.html`,
    `!${gulpConfig.src}/html/**/@*`,
    `!${gulpConfig.src}/html/include/**/*`
  ])
    .pipe($.fileInclude(fileIncludeConfig))
    .pipe($.jsbeautifier({
      config: '.jsbeautifyrc',
      mode: 'VERIFY_AND_WRITE'
    }))
    .pipe(dest(`${gulpConfig.dist}/html`))
}

async function stamps(){
  await gitDateExtractor.getStamps({
    outputToFile: true,
    outputFileName: '../../timestamps.json',
    onlyIn : ['./'],
    projectRootPath: __dirname+'/src/html'
  });
}

function make_indexfile() {
  const dPath = `${gulpConfig.src}/html/`, // index를 생성할 파일들이 있는 저장소
    info = getRepoInfo(), // git 정보 생성
    fileInfo = fs.readdirSync(dPath),
    stampData = fs.readFileSync('./timestamps.json'), // stamps 에서 생성한 json 읽기
    jsonStampData = JSON.parse(stampData); // json 파일 이용가능하도록 parse
  let normalFiles = []; // 파일 정보를 저장할 배열 생성

  fileInfo.map(function (file) {
    return path.join(dPath, file);
  }).filter(function (file) {
    return fs.statSync(file).isFile();
  }).forEach(function (file) {
    //HTML 파일만 거르기
    let extname = path.extname(file),
      basename = path.basename(file);
    if (extname == '.html') {
      // 일반 file info를 저장할 객체 생성
      let nfileData = {};
      // title 텍스트 값 추출
      let fileInnerText = fs.readFileSync(file, 'utf8');
      let $ = cheerio.load(fileInnerText);
      let wholeTitle = $('title').text(),
        splitTitle = wholeTitle.split(' : '),
        //git 기준 마지막 변경 날짜
        modifiedDate = jsonStampData[`${basename}`].modified*1000,
        //git 기준 생성 날짜
        createdDate = jsonStampData[`${basename}`].created*1000;

      // 객체에 데이터 집어넣기
      nfileData.title = splitTitle[0];
      nfileData.name = basename;
      nfileData.category = String(nfileData.name).substring(0, 2);
      nfileData.categoryText = splitTitle[1];
      nfileData.mdate = new Date(modifiedDate);
      nfileData.cdate = new Date(createdDate);
      nfileData.since = modifiedDate;
      nfileData.age = createdDate;
      // 파일수정시점 - 대한민국 표준시 기준
      nfileData.ndate = nfileData.mdate.toLocaleString('ko-KR', {timeZone: 'Asia/Seoul'}) + ' (GMT+9)';
      // title 마지막 조각 , 인덱스에 붙은 라벨 식별 및 yet 인 경우 수정날짜정보 제거
      nfileData.status = splitTitle[2];
      if (typeof splitTitle[2] == 'undefined' || splitTitle[2] == null || splitTitle[2] == '') {
        nfileData.status = '';
      } else if (splitTitle[2] == 'yet') {
        nfileData.mdate = '';
        nfileData.ndate = '';
      }
      normalFiles.push(nfileData);
    }
  });

  let projectObj = {
    nfiles: normalFiles,
    branch: info.branch
  }
  let projectObjStr = JSON.stringify(projectObj);
  let projectObjJson = JSON.parse(projectObjStr);

  //index 파일 쓰기
  return src('index.html')
    .pipe(ejs(projectObjJson))
    .pipe(dest(gulpConfig.dist))
}

/**
 * CSS: watch for style auto-compile
 * @example gulp
 */

function clean_dist() {
  return del(gulpConfig.dist)
}

function clean_json() {
  return del(`${gulpConfig.dist}/json`)
}

function clean_css() {
  return del([
    `${gulpConfig.src}/css`,
    `${gulpConfig.dist}/css`
  ])
}

function clean_html() {
  return del(`${gulpConfig.dist}/html`)
}

function clean_img() {
  return del(`${gulpConfig.dist}/img`)
}

const browserSyncReload = (done) => {
  browserSync.reload();
  done();
}

function server() {
  // serve files from the build folder
  browserSync.init({
    port: 8030,
    ui: {
      port: 8033,
      weinre: {
        port: 8133
      }
    },
    cors: false, // if you need CORS, set true
    server: {
      baseDir: `${gulpConfig.dist}/`
    }
  });

  console.log('\x1b[32m%s\x1b[0m', '[--:--:--] HTML/SCSS watch complete...');

  watch([
    `${gulpConfig.src}/img/**/*`,
    `!${gulpConfig.src}/img/*.png`,
    `!${gulpConfig.src}/img/*.svg`
  ], series(clean_img, sprites, copy_image, sass, browserSyncReload));
  watch([
    `${gulpConfig.src}/scss/**/*`,
    `!${gulpConfig.src}/scss/vendor/*-mixins.scss`
  ], series(clean_css, sass, browserSyncReload));
  watch(`${gulpConfig.src}/json/**/*`, series(clean_json, browserSyncReload));
  watch(`${gulpConfig.src}/html/**/*`, series(clean_html, parallel(make_indexfile, process_html), browserSyncReload));
  watch('index.html', series(make_indexfile, browserSyncReload));
}

function markup_watch() {
  series(clean_dist, stamps, parallel(update_normalize, optimize_others, process_html, make_indexfile), sprites, sass, copy_image, server, () => {
    console.log('\x1b[32m%s\x1b[0m', '[--:--:--] HTML/SCSS watch complete...')
  })();
}

exports.default = markup_watch;

function process_html_in_build() {
  return src([
    `${gulpConfig.src}/html/**/*.html`,
    `!${gulpConfig.src}/html/**/@*`,
    `!${gulpConfig.src}/html/include/**/*`
  ])
    .pipe($.fileInclude(fileIncludeConfig))
    .pipe($.jsbeautifier({
      config: '.jsbeautifyrc',
      mode: 'VERIFY_AND_WRITE'
    }))
    .pipe(dest(`${gulpConfig.dist}/html`))
}

function accessibility_test() {
  return src(`${gulpConfig.dist}/html/**/*`)
    .pipe($.accessibility({
      Accessibilityrc: '.accessibilityrc'
    }))
    .on('error', console.log)
    .pipe($.accessibility.report({
      reportType: 'txt'
    }))
    .pipe($.rename({
      extname: '.txt'
    }))
    .pipe(dest('reports/txt'))
}

function zip() {
  let date = new Date()
  let dateFormatted = `${date.getFullYear()}${('0' + (date.getMonth() + 1)).slice(-2)}${('0' + date.getDate()).slice(-2)}T${('0' + date.getHours()).slice(-2)}${('0' + date.getMinutes()).slice(-2)}`
  return src([
    `${gulpConfig.dist}/**/*`,
    `!${gulpConfig.dist}/**/*.zip`
  ])
    .pipe($.zip(`${packageJson.name}_${packageJson.version}_${dateFormatted}.zip`))
    .pipe(dest(gulpConfig.dist))
}

/**
 * build: watch for style auto-compile
 * @example gulp build
 */

function markup_build(done) {
  series(clean_dist, stamps, parallel(update_normalize, optimize_png, optimize_others, process_html_in_build, make_indexfile), sprites, sass, copy_image, accessibility_test, zip, (done) => {
    console.log('\x1b[32m%s\x1b[0m', '[--:--:--] Build complete...')
    done()
  })()
  done()
}

exports.build = markup_build;

// function sprite_img_rename(done) {
//   return gulpConfig.spriteHash ? gulp.src([
//     `${gulpConfig.dist}/img/sprite*.png`,
//     `${gulpConfig.dist}/img/sprite*.svg`,
//   ],{base: `${gulpConfig.dist}`})
//     .pipe($.rev())
//     .pipe($.revDeleteOriginal())
//     .pipe(gulp.dest(`${gulpConfig.dist}`))
//     .pipe($.rev.manifest())
//     .pipe(gulp.dest(`${gulpConfig.dist}`)) : done()
// }
//
// function sprite_css_rewrite(done) {
//   const manifest = gulpConfig.spriteHash ? gulp.src(`${gulpConfig.dist}/rev-manifest.json`) : false;
//
//   return gulpConfig.spriteHash ? gulp.src(`${gulpConfig.dist}/css/*.css`)
//     .pipe($.revRewrite({ manifest }))
//     .pipe(gulp.dest(`${gulpConfig.dist}/css`)) : done()
// }


function source_deploy() {
  return src(`${gulpConfig.dist}/**/*`)
    .pipe($.ghPages({
      message: gulpConfig.deployMessage
    }))
}

/**
 * deploy: watch for style auto-compile
 * @example gulp build
 */

function markup_deploy(done) {
  series(clean_dist, stamps, parallel(update_normalize, optimize_png, optimize_others, process_html_in_build, make_indexfile), sprites, sass, copy_image, accessibility_test, zip, source_deploy, (done) => {
    console.log('\x1b[32m%s\x1b[0m', '[--:--:--] Build & Deploy complete...');
    done()
  })()
  done()
}

exports.deploy = markup_deploy;

```

### index.html

```text
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
  <title>Pay TH</title>
  <style>a,body{color:#000}body,li{position:relative}body,button,dd,dl,dt,fieldset,form,h1,h2,h3,h4,h5,h6,input,legend,li,ol,p,select,table,td,textarea,th,ul{margin:0;padding:0;-webkit-text-size-adjust:none}body,button,input,select,table,textarea{font-family:-apple-system,system-ui,BlinkMacSystemFont,Roboto,sans-serif;font-size:14px;line-height:1.25em}body{padding:0 1em;padding:0 calc(1em + constant(safe-area-inset-right)) constant(safe-area-inset-bottom) calc(1em + constant(safe-area-inset-left));padding:0 calc(1em + env(safe-area-inset-right)) env(safe-area-inset-bottom) calc(1em + env(safe-area-inset-left));background-color:#fff;word-wrap:break-word;word-break:break-all}fieldset,img{border:0}ol,ul{list-style:none}a{text-decoration:none;cursor:pointer}h1{padding:.8em 4em .6em .1em;border-bottom:3px solid #222;background:#fff;font-size:1.2em}h2,h3{clear:both;font-size:1em}h2{padding:2em .1em .4em;border-bottom:1px solid #000}h3{padding:1em .1em .4em;border-bottom:1px dotted #888}.inf{padding:10px 2px 0;line-height:1.4em;color:#666}ul{margin-bottom:10px;font-size:.9em}li{border-bottom:1px solid #dfdfdf}li .na{display:block;padding:.7em 31px .6em .1em;color:#999}li .bx{display:inline-block;border:1px solid #999;background:#f2f2f2;font-size:.8em;padding:1px 3px;color:#999;border-radius:3px}li a{display:block;padding:.7em 31px .6em .1em;background:url(http://static.naver.com/www/m/cm/im/bu_lk.gif) 100% 50% no-repeat}li a span{margin-right:5px;font-weight:700;font-size:.85em}li a .sup{color:#a30}li .inner_btn{position:absolute;top:4px;right:35px;z-index:99;padding:0 5px;border:1px solid #da7c0c;background:#f78d1d;background:-webkit-gradient(linear,0 0,0 100%,from(#faa51a),to(#f47a20));font-size:11px;line-height:23px;color:#fef4e9;border-radius:3px;box-shadow:1px 1px 0 rgba(0,0,0,.3);-webkit-box-shadow:1px 1px 0 rgba(0,0,0,.3)}li .inner_btn:hover{background:#f47c20;background:-webkit-gradient(linear,0 0,0 100%,from(#f88e11),to(#f06015))}.message{display:block;margin:5px 0 0;font-size:14px;color:red;}.toc{padding:0 20px 20px;background:#efefef}.toc li a{text-transform:capitalize}.sec_h{text-transform:capitalize}.date{display:inline-block;padding:2px 4px;color:#a30;}.yet{color:#cfcdcd}.yet .date{background-color:#ccc;color:#fff}.yet .date:before{content:'YET'}.new .date{background-color:#f50a20;color:#fff}.new .date:before{content:'NEW|'}.update .date{background-color:#3c94e5;color:#fff}.update .date:before{content:'UPDATE|'}.sec_h:target,.sec_h:target+.page-lst{animation-duration:2s;animation-name:highlight;animation-iteration-count:1;}@keyframes highlight{from{background-color:rgba(255,120,0,.2);}to{background-color:rgba(255,120,0,0)}}
  </style>
</head>
<body>

<h1>Pay TH<span class="message"><%= branch %> 브랜치</span></h1>

<p class="inf">description of LINE Project</p>

<img src="" id="_im1" width="150" height="150" style="width:150px;height:150px">
<script>document.getElementById("_im1").src = 'http://chart.apis.google.com/chart?cht=qr&chs=150x150&chl='+encodeURIComponent(location.href);</script>

<div class="toc">
  <h2>카테고리 바로가기</h2>
  <ul>
    <% for (var i=0; i < 100 ; i++){
    var categoryNum = String("0" + i).slice(-2);
    var colIndex = 0;
    var nfileList = nfiles;
    for(var j=0 ; j < nfileList.length; j++){
    if (categoryNum == nfileList[j].category){
    if (colIndex == 0){ %>
    <li><a href="#tab<%= categoryNum %>"><%= nfileList[j].categoryText %></a></li><%}
    colIndex++;
    }
    }
    }%>
  </ul>
</div>

<%
var today = new Date();
today = Date.parse(today);
for (var i=0; i < 100 ; i++){
var categoryNum = String("0" + i).slice(-2);
var listCount = 0;
var nfileList = nfiles;
var lastCategory = nfileList[nfileList.length - 1].category;
for(var j=0 ; j < nfileList.length; j++){
if (categoryNum == nfileList[j].category){
if (listCount == 0){ %>
<h2 id="tab<%= categoryNum %>" class="sec_h"><%= nfileList[j].categoryText %></h2>
<ul class="page-lst"><%} %>
  <li>
    <a class="<%= nfileList[j].status %>" href="html/<%= nfileList[j].name %>">
      <%= nfileList[j].title %> / <%= nfileList[j].name %>
      <span class="date" title="<%= nfileList[j].ndate %>" data-since="<%= nfileList[j].since %>" data-age="<%= nfileList[j].age %>"><%= nfileList[j].mdate.substring(2,10).replace(/-/gi,'') %></span>
    </a> <% if (nfileList[j].splitStatus) { %>
    <% } %>
  </li> <% listCount++; } }  if (categoryNum <= lastCategory && listCount >= 1) { %>
</ul> <%  } } %>

<script>
  var unbindEl = document.querySelectorAll('.yet'),
    unbindElLength = unbindEl.length;
  for (i=0;i < unbindElLength; i++) {
    var unbindParent = unbindEl[i].parentNode;
    unbindParent.addEventListener('click', noti);
    function noti(e){
      e.preventDefault();
      alert('작업 진행중인 페이지입니다.');
    }
  }

  var pageListItem = document.querySelectorAll('.page-lst li'),
    statusResetDate = 28 * 86400 * 1000;

  for(var l = 0; l < pageListItem.length; l++) {
    var since = pageListItem[l].querySelector('.date').getAttribute('data-since');
    var age = pageListItem[l].querySelector('.date').getAttribute('data-age');
    if(Date.now() - age < statusResetDate && !pageListItem[l].querySelector('a').classList.contains('yet')) {
      pageListItem[l].querySelector('a').classList.add('new');
    }
    else if(Date.now() - since < statusResetDate && !pageListItem[l].querySelector('a').classList.contains('yet')) {
      pageListItem[l].querySelector('a').classList.add('update');
    }
  }
</script>

</body>
</html>

```

### .accessibilityrc

```json
{
  "accessibilityLevel": "WCAG2A",
  "ignore": [
    "WCAG2A.Principle2.Guideline2_4.2_4_2.H25.1.NoTitleEl",
    "WCAG2A.Principle3.Guideline3_1.3_1_1.H57.2"
  ],
  "reportLevels": {
    "notice": false,
    "warning": true,
    "error": true
  },
  "force": true,
  "verbose": false
}

```

### .jsbeautifyrc

```json
{
  "html": {
    "allowed_file_extensions": ["htm", "html", "xhtml", "shtml", "xml", "svg", "dust"],
    "brace_style": "collapse",
    "end_with_newline": true,
    "indent_char": " ",
    "indent_with_tabs": false,
    "indent_handlebars": true,
    "indent_inner_html": false,
    "indent_scripts": "keep",
    "indent_size": 2,
    "preserve_newlines": true,
    "max_preserve_newlines": 1,
    "unformatted": ["a", "span", "img", "code", "pre", "sub", "sup", "em", "strong", "b", "i", "u", "strike", "big", "small", "pre", "h1", "h2", "h3", "h4", "h5", "h6"],
    "wrap_line_length": 0
  },
  "css": {
    "allowed_file_extensions": ["css", "scss", "sass", "less"],
    "end_with_newline": true,
    "indent_char": " ",
    "indent_size": 2,
    "newline_between_rules": true,
    "selector_separator": " ",
    "selector_separator_newline": false,
    "preserve_newlines": true,
    "max_preserve_newlines": 2
  },
  "js": {
    "allowed_file_extensions": ["js", "json", "jshintrc", "jsbeautifyrc"],
    "brace_style": "collapse",
    "break_chained_methods": false,
    "e4x": false,
    "end_with_newline": true,
    "indent_char": " ",
    "indent_level": 0,
    "indent_size": 2,
    "indent_with_tabs": false,
    "jslint_happy": false,
    "keep_array_indentation": false,
    "keep_function_indentation": false,
    "preserve_newlines": true,
    "max_preserve_newlines": 2,
    "space_after_anon_function": true,
    "space_before_conditional": true,
    "space_in_empty_paren": false,
    "space_in_paren": false,
    "unescape_strings": false,
    "wrap_line_length": 0
  }
}

```

### package.json

```json
{
  "name": "",
  "version": "0.0.0",
  "description": "",
  "repository": {
    "type": "git",
    "url": ""
  },
  "bugs": {
    "url": ""
  },
  "private": true,
  "engines": {
    "node": "^10.16.3",
    "npm": "^6.10.3"
  },
  "dependencies": {},
  "devDependencies": {
    "browser-sync": "^2.26.7",
    "cheerio": "^1.0.0-rc.3",
    "del": "^5.0.0",
    "git-date-extractor": "^2.0.0",
    "git-repo-info": "^2.1.1",
    "gulp": "^4.0.2",
    "gulp-accessibility": "^3.1.1",
    "gulp-autoprefixer": "^7.0.0",
    "gulp-clean-css": "^4.2.0",
    "gulp-ejs": "^4.1.1",
    "gulp-file-include": "^2.1.0",
    "gulp-gh-pages": "^0.5.4",
    "gulp-htmlmin": "^5.0.1",
    "gulp-if": "^3.0.0",
    "gulp-imagemin": "^6.0.0",
    "gulp-jsbeautifier": "^3.0.1",
    "gulp-load-plugins": "^2.0.1",
    "gulp-pngquant": "^1.0.12",
    "gulp-rename": "^1.4.0",
    "gulp-replace": "^1.0.0",
    "gulp-sass": "^4.0.1",
    "gulp-sass-glob": "^1.1.0",
    "gulp-sort": "^2.0.0",
    "gulp-svg-sprite": "^1.5.0",
    "gulp-uglify": "^3.0.0",
    "gulp-zip": "^5.0.0",
    "gulp.spritesmith-multi": "^3.1.0",
    "merge-stream": "^2.0.0",
    "normalize.css": "^8.0.1",
    "path": "^0.12.7",
    "run-sequence": "^2.2.1",
    "vinyl-buffer": "^1.0.1"
  },
  "license": "ISC"
}

```