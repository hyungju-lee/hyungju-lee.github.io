---
title: 9-9. String 오브젝트 / 정규표현식을 사용할 수 있는 함수
layout: post
date: '2020-11-26 10:56:00'
categories:
- js_beginner
---

## 9-9. String 오브젝트 / 정규표현식을 사용할 수 있는 함수

## match()

|구분|데이터(값)|
|---|---------|
|data|매치 대상|
|파라미터|정규표현식, 문자열|
|반환|[매치 결과]|

* 매치 결과를 배열로 반환

    * 매치 대상에 정규 표현식의 패턴을 적용하여 매치하고 매치 결과를 반환
    
        ```javascript
        var value = "Sports";
        console.log(value.match(/s/)); // [s]
        console.log(value.match("spo")); // null
        ```
        
        1. 매치는 정규 표현식 용어
        2. match(/s/)에서  
           /s/는 정규 표현식으로 소문자 s를 매치
        3. "Sports" 끝에 s가 있으므로 매치되며 매치된 문자를 반환
        4. match("spo")에서 spo가 있으나 대문자 S이므로 null 반환
        
        보통 없을땐 undefined 를 반환합니다.  
        그런데 위 예제에선 null 을 반환했습니다.  
        이는 뭔가 프로세스를 한거죠?  
        **undefined는 아직 존재하지 않는 느낌이지만 null은 뭔가 처리를 했는데 없다라는 뉘앙스입니다.**  
        **그런 측면에서 본다면 null이 undefined 보다 적절하다고 할 수 있겠습니다.**
        
        정규 표현식 오브젝트가 별도로 있습니다.  
        `RegExp` 오브젝트인데, 빌트인 오브젝트입니다.  
        String 오브젝트에는 RegExp 오브젝트를 처리할 수 있는 게 없죠. 기능이요.
        
        그래서 위와 같이 value.match(“spo”) 라고 입력하면,
        RegExp에 exec 와 같은 함수가 있거든요?
        그 함수를 호출합니다.
        그러면서 “spo” 파라미터값을 넘겨줍니다.
        
        그럼 RegExp 오브젝트에선 spo를 정규표현식으로 변환하겠죠?
        /spo/ 형태로 변환할겁니다.
        그 변환한 걸로 매치를 하게됩니다.
        그래서 위와 같이 null 값이 나오는 것입니다.
        
    * 문자열 작성 가능, 엔진이 정규 표현식으로 변환하여 매치
    
---

* 정규표현식

    * 문자열을 패턴으로 매치
    * 패턴(pattern) 형태 : ^, $, *, + 등
    
>match 함수 파라미터에 정규표현식을 사용할 수 있습니다.  
>정규표현식이란 문자열을 패턴으로 매치합니다.  
>즉 문자열이 대상입니다.  
>String 오브젝트에서 이것을 다룹니다.

기호마다 기능이 있습니다.

1. ^ (캐럿) : 첫문자와 일치
2. $ : 끝문자와 일치

이런 기능을 문자열에 매치하는 것을 패턴이라고 합니다.

일치가 하나의 개념이라고 한다면 매치는 다수의 개념이라고 할 수 있습니다.  
**그래서 매치 결과물은 배열로 반환됩니다.**  
**매치 대상에 정규 표현식의 패턴을 적용하여 매치하고 매치 결과를 반환합니다.**

---

## replace()

|구분|데이터(값)|
|---|---------|
|data|치환 대상|
|파라미터|첫번째 파라미터 : 정규표현식, 문자열 <br> 두번째 파라미터 : 대체할 값, 함수|
|반환|치환 결과|

---

* 매치 결과를 파라미터에 작성한 값으로 대체하여 반환
* <mark>두번째 파라미터에 함수를 작성하면 먼저 함수를 실행하고 함수에서 반환한 값으로 대체</mark>

    ```javascript
    var value = "abcabc";
    console.log(value.replace("a", "바꿈")); // 바꿈bcabc
    console.log(value.replace(/a/, "바꿈")); // 바꿈bcabc
    
    function change() {
        return "함수";
    }
    console.log(value.replace(/a/, change())); // 함수bcabc
    ```
    
    정규 표현식 `/a/` 뒤에는 `g`를 작성할 수 있습니다.  
    g는 global의 약칭입니다.  
    `/a/g`라고 입력하면 전체에서 a를 검색합니다.
    
    `change()` 표현식 먼저 평가 후 반환된 값으로 `replace()`함수 실행합니다.
    
## search()

|구분|데이터(값)|
|---|---------|
|data|검색 대상|
|파라미터|정규표현식, 문자열|
|반환|매치된 인덱스|

---

* 검색된 첫번째 인덱스 반환

    * 매치되지 않으면 **-1** 반환  
      `indexOf()`와 개념이 좀 비슷합니다.  
      <mark>그러나 indexOf()는 하나밖에 안됩니다.</mark>  
      그러나 정규표현식은 다양한 조건을 작성할 수 있습니다.
      
        ```javascript
        var value = "cbacba";
        console.log(value.search(/a/)); // 2
        console.log(value.search("K")); // -1
        ```
        
        1. 매치된 첫번째 인덱스 반환
        2. K가 없으므로 매치되지 않음  
           매치되지 않으면 -1 반환
           
        `indexOf()`는 위에(`search(/a/)`) 이거처럼 하나만 비교할 수 있습니다.  
        
        하지만 `search()`에선 정규 표현식을 하게되면, 다른 조건들을 사용할 수 있습니다.  
        a이면서 다음에 오는 문자가 c이면서.... 다음 문자는 아무 문자라도 상관없고...  
        조건을 다양하게 할 수 있습니다.
        
        패턴으로 이와 같은 것이 가능합니다.  
        정규표현식은 이와 같이 복잡하게 사용할 수 있습니다.
        
## split()

|구분|데이터(값)|
|---|---------|
|data|분리 대상|
|파라미터|첫번째 파라미터 : 분리자(정규표현식, 문자열) <br> 두번째 파라미터 : 반환 수|
|반환|결과|

--- 

* 분리 대상을 분리자로 분리하여 **배열로 반환**

    ```javascript
    console.log("12_34_56".split("_")); // [12, 34, 56]
    ```
    
    1. "_"를 분리자로 사용
    2. "12_34_56"을 "_"로 분리

* 분리자를 작성하지 않은 경우

    ```javascript
    var value = "123";
    console.log(value.split("")); // [1, 2, 3]
    console.log(value.split()); // [123]
    ```
    
    1. 분리자에 빈 문자열을 작성하면 문자를 하나씩 분리하여 반환
    2. 분리자를 작성하지 않으면 분리 대상 전체를 하나의 배열로 반환

* 두번째 파라미터에 반환 수를 작성

    ```javascript
    var value = "12_34_56_78";
    console.log(value.split("_", 3)); // [12, 34, 56]
    
    value = "123";
    console.log(value.split("A")); // [123]
    ```
    
    1. 두 번째 파라미터에 숫자를 작성하면 앞에서부터 수만큼만 반환
    2. 분리자가 분리대상에 없으면 분리 대상 전체를 하나의 배열로 반환