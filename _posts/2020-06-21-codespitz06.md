---
title: 5. BLOCK, NONBLOCK & SYNC, ASYNC
layout: post
date: '2020-06-21 20:45'
categories:
- codespitz
---

## 5. BLOCK, NONBLOCK & SYNC, ASYNC

FLOW를 막고 있는 것이 바로 BLOCK.  
BLOCKING이 일어나고 있는 상태에선 컴퓨터가 죽은 것처럼 보인다.(CPU)  
그래서 이 때 내 컴퓨터가 이대로 꺼질 것인가 아니면 다시 살아날 것인가, 불안불안하다.  
이렇기 때문에 BLOCKING을 제거하는 것이 개발자들의 제일 큰 화두이다.  

모든 프로그래밍 소스는 BLOCKING을 일으킨다.  
그럼 NON-BLOCKING은 뭐야?  
상대적인 것이다.  
짧은 시간동안만 블로킹을 일으키면, 논블로킹이고 긴 시간동안 블로킹을 일으키면 블로킹인 것이다.  
그럼 그 기준은 누가 정하는데? 사람마다 다 달라?  
라고 생각하실지도 모르겠지만, 사실은 그렇지 않다.  
VR은 16.6ms 를 권고사항으로 하고 있고, 브라우저는 5초 정도라고 하고 있다.  
전화기는 1ms만 느려도 상대방 목소리가 다르게 들린다거나 하기 때문에 블로킹시간이 다른 거에 비해 훨씬 적다.  

## FLOW IS BLOCKING

프로그램이 실행되면 도중에 멈춰지지 않고 끝까지 실행된다.(CPU가 블로킹된다)  

```javascript
for (const i of (function*() {
    let i = 0;
    // yield가 실행될 때마다 iterator result object 반환
    while (true) yield i++;
})()) console.log(i);
// 제너레이터를 호출하면 유사 이터러블로 작동한다.
// 위 무한 루프는 플로우 블로킹을 일으킨다.

// scripot timeout
// 플랫폼의 안정성을 위해 블록되는 시간이 길면 강제 종료시킨다.
```

## BLOCKING FUNCTION

점유하는 시간만큼 블록을 일으키는 함수

```javascript
const f = v => {
    let i = 0;
    while(i++ < v);
    return i;
};
// 아래는 블로킹을 유발 안할 것이다.
f(10);
// 아래는 블로킹을 유발할 것이다.
f(10000000000000000);
// 이것이 블로킹 함수다.
```

함수를 짰을 때 이 함수가 블로킹 함수인지 아닌지는, 함수에 전달하는 **인자**에 달려있다.  

배열을 루프돌리는 함수라면, 배열의 크기에 따라 블로킹 함수인지 아닌지가 달려있다.
만약에 배열 대신에 받아오는 인자가 **해시맵(셋)**이었다면, 값을 해시화시키고 해시셋 있는지만 조사하면 끝이기 때문에 
일정 비용으로 아무리 많은 큰 집합의 해시셋이 와도 똑같은 비용으로 처리할 수 있다.  

자바의 해시셋이라는 개념이 자바스크립트에도 위크셋이라고 있다.  
위크셋을 쓰면 아무리 위크셋에 들어가 있는 객체 수가 많아져도 위크셋에 값이 있는지를 조사할 때는 똑같은 비용으로 조사할 수 있다.  
이는 블로킹 함수가 아니다.  
많거나 적거나 똑같은 블로킹 시간이기 때문에 블로킹함수라고 불리지 않는다.  

아무튼 우리는 자기도 모르게 블로킹 함수로 짠다.  
위의 소스도 블로킹 함수란걸 보면 우리가 그렇다는 걸 알 수 있다.  
일단 여러분이 블로킹 함수로 어플리케이션을 만들면, 해당 어플리케이션 상황에 따라 굉장히 긴 블로킹이 유발될 수도 있는 것이다.  
그래서 **블로킹 함수 관리**가 정말 중요하다.  
밑에 깔린 유틸리티 함수 몇 개가 블로킹으로 되어 있다는 이유로 시스템 전체가 블로킹에 빠질 수도 있다.  

위 소스에 max 같은 것을 조건으로 달지 않는 이상, (max > 100 이라면 throw 라던지..) 어디선가 블로킹을 일으킬지 모른다는 것이다.   

---

아니 저렇게 안 짜는 사람도 있나요?  
네, 저렇게 안 짭니다. 의사들은.  
블로킹 함수가 되지 않도록 처음부터 유의하면서 짠다.  

함수 하나를 짜더라도 프로 정신을 가지고 짜자.  
난 엔터프라이즈 급으로 일하는 사람이다. 라는 생각으로 짜자.  

---

1. 배열순회, 정렬 - 배열 크기에 따라
2. DOM 순회 - DOM의 하위 구조에 따라
3. 이미지 프로세싱 - 이미지 크기에 따라

아니 그러면, 배열 크기가 크면? DOM 하위 구조가 크면? 이미지 크기가 크면? 어떻게 블로킹에 빠지지 않게 코드를 짜라는 거야?  
특정 단위로 쪼개서 `setInterval`로 작업을 한 다음에 나중에 합치면 될 거 아냐?  
이런건 경험이 아니다.  
단지, 제대로 안 배웠다는 것이다.  
제대로 배우면 위와 같은 것들을 고려 안할리 없다.  

## BLOCKING EVASION

**블로킹을 피하는 기술**

>**블로킹의 문제점**  
>1. 독점적인 cpu 점유로 인해 모든 동작이 정지됨 (의문 : 난 6코어 인데? 멀티 코어인데? 이럴리 있어?)
>2. 타임아웃 체크에 의해 프로그래밍이 강제 중단됨  
>   요즘은 OS에 제어되는 코드로 짜게끔 강제된다.  
>   만약 그렇지 않은 코드로 짜게되면 블루스크린 뜨는 것.  
>   맥OS는 많이 제한되어있어서 어플 올리기 힘든 것. 맥 OS에 제어되는 코드로만 짜야되니깐.

**블로킹 함수로 짠다면 얼마나 많은 블로킹이 발생할지 예측할 수 없다.**  

```javascript
// some 함수가 블로킹이고 other 함수가 블로킹이면 당연히 f도 블로킹 함수
// 그리고 각각 얼마나 블로킹을 일으키는지 모른다.
// 실제 코드는 이렇게 생겼기 때문에, 구성 요소 중 하나만 블로킹이더라도 전체가 오염될 수 있다는 것이다.
const f = v => other(some(v), v = 2);
f(10);
```

블로킹 함수의 에러는 잡을 수가 없다. 그냥 죽기 때문에.  
디버깅, 콘솔로그로도 안 뜬다.  
이러면 비용 엄청 발생시키는 거. 이거 잡겠다고.  

**순차적인 실행**

1(완료) -> 2(완료) -> 3(완료)

**현대 시분할 운영체제의 동시 실행**

1(조금) -> 2(조금) -> 3(조금) -> 1(조금) -> 2(조금) -> 3(조금) -> ...

당연히 시분할 운영체제의 시간이 똑같은 일을 해도 순차적 실행보다 3배 이상 오래걸릴 때도 있다.  
재수 없으면 4~5배 이상 차이나기도 한다.  
**순차적 실행**이 훨씬 빠른데도 불구하고 **시분할 운영체제**로 하는 이유는 뭘까?  
다 사용자들 때문이다.  
사용자들이 지겨운걸 못 견뎌하기 때문.  

음악이 플레이되는 척 하면서, 프린팅이 되는 척 하면서, 영화가 재생되어야 해.  

이런 느낌이다.  
조금씩 처리되고 전체 완료가 더 오래걸린다고 하더라도 그걸 원한다.  
**<span style="color:red">그래서 단일 CPU에 대한 시분할 운영체제가 탄생한 것이다.</span>**
**CPU가 여러개여도 각각 CPU에게 시분할 운영을 시킨다.**  

**자바스크립트 쓰레드**

![](/static/img/codespitz/image54.jpg)

그렇다면 자바스크립트 스레드는 어떻게 생겼을까?  
흔히 자바스크립트가 싱글 스레드라고 하는데, 이것은 굉장히 잘못된 생각이다.  
자바스크립트 브라우저에는 수많은 스레드가 돌고 있다.  
일반적으로 스레드 추적기 같은 거 돌려보면, 네이버 같은 페이지 보면 스레드 15개 정도 떠있다.  

**자바스크립트 스레드가 싱글 스레드가 아니라, 자바스크립트에서 UI에 관련된 처리를 하고, 자바스크립트란 스크립트 처리하는 부분이
 바로 싱글 스레드로 되어 있다.**  
그런데 이것은 자바스크립트가 특이한 것이 아니다.  
iOS, 안드로이드 다 이렇게 되어 있고, 윈도우 관리 코드로 되어있는 어플리케이션을 유니버셜 앱이라고 하는데, 얘도 이렇게 되어있다.  

**현대의 거의 모든 OS는 UI를 건드리거나 메인 스크립트 작동을 싱글 스레드로 하고 있다.**  
그리고 우리는 MAIN UI THREAD를 감시한다.  
얘가 얼마나 블로킹을 발생시키는 지를 감시한다.  

**반면에 여러분이 AJAX 로딩을 20개로 걸어놨어. 얘네는 다 다른 스레드로 뜬다.**  
MAIN UI THREAD가 아니라 다른 스레드로 뜬다.(BACKGROUND THREAD)  
최근에 HTML5가 등장한 이후엔 이러한 브라우저 내장 스레드 말고도 우리가 직접 스레드를 띄울 수 있는 WEB WORKER라는 기능이 있다.
WEB WORKER를 이용하면 우리가 자바스크립트에서도 별도의 스레드를 또 띄울 수 있다.  

![](/static/img/codespitz/image55.jpg)

그에 비해서 자바스크립트의 MAIN UI THREAD 가 너무 희안하니까, 다른 것들이 비해서..  
얘를 좀 더 깊이 살펴보자.  
이 스레드는 어떻게 작동하냐면, 이 스레드는 **무한 루프**를 돌고 있다.  
그리고 이 스레드가 바라보고 있는 **배열**이 있다.  
이 배열엔 자바스크립트의 명령을 저장을 하는데, 저장될 때 이 명령은 몇 초에 실행되어라 라는 **타임스탬프**가 붙게된다.  
예를 들어, 이 명령은 시작하자마자 실행해, 저거는 2초 이따가 실행해,.. 이런 타임스탬프가 붙어있다.  

인간이 이해하기 쉬우라고 시간이라는 말을 썼지만, 컴퓨터는 이렇게 인식한다.  
이 명령어는 **0 프레임**에서 실행해, 이건 **1 프레임**에서 실행해,..  
메인 UI 스레드에서는 자신만의 시간 - 루프 한바퀴 돌 때마다 1틱이라고 한다면, 5틱 때 몇 프레임을 실행해.. 이런 느낌인건가?  
메인 UI 스레드는 계속 자신만의 시간을 돌리면서 해당 시간일 때 명령어를 실행해준다.  

그래서 우리가 다수의 명령어를 이러한 시간축에다 배열해두면, 메인 UI 스레드는 자신만의 시간을 돌리면서 해당 명령어들을 확인한다.  
클릭 이벤트 리스너가 프레임에 들어와서 대기 -> 메인 UI 스레드 시간축 돌리다가 발견 -> 실행  
AJAX 완료 리스너가 프레임에 들어와서 대기 -> 메인 UI 스레드 시간축 돌리다가 발견 -> 실행  

**다른 스레드에서 실행의 결과를 메인 UI 스레드 프레임이 넣어놓고 메인 UI 스레드가 돌면서 받아들이는 느낌(?)인 것 같다.**
**이걸 멀티 스레드 패턴에선 서스팬션 페턴이라고 부른다.**

26:57