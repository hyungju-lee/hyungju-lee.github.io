[

{
"id": "-issue-2020-05-13-issue20",
"title": "total",
"author": null,
"tags": [],
"url": "/issue/2020/05/13/issue20/",
"date": "2020-05-13",
"content": "참고folder treegulpfile.js'use strict'/*jshint -W110 */const fs = require('fs'),  path = require('path'), // added  cheerio = require('cheerio'), // added  ejs = require('gulp-ejs'), // added  packageJson = JSON.parse(fs.readFileSync('package.json')),  {src, dest, watch, series, parallel, lastRun} = require('gulp'),  del = require('del'),  merge = require('merge-stream'),  browserSync = require('browser-sync').create(),  vinylBuffer = require('vinyl-buffer'),  spritesmith = require('gulp.spritesmith-multi'),  gitDateExtractor = require('git-date-extractor'),  getRepoInfo = require('git-repo-info'),  $ = require('gulp-load-plugins')({    camelize: true  }),  gulpConfig = {    autoprefixer: ['&gt; 1%', 'last 2 versions', 'iOS 5', 'Android 2.3', 'FF 20', 'IE 8'],    deployMessage: '[UPDATE] deploy to gh-pages',    src: './src',    dist: './dist',    // sprite-hash option    spriteHash: true,    // ejs-template's global variables    ejsVars: {    }  },  fileIncludeConfig = {    \"prefix\": \"@@\",    \"basepath\": \"@file\",    \"context\": {}  };function sprites() {  const opts = {    spritesmith: function (options, sprite, icons) {      options.imgPath = `../img/${options.imgName}`;      options.cssName = `_${sprite}-mixins.scss`;      options.cssTemplate = `${gulpConfig.src}/scss/vendor/spritesmith-mixins.handlebars`;      options.cssSpritesheetName = sprite;      options.padding = 4;      options.algorithm = 'binary-tree';      return options    }  };  const spriteData = src(`${gulpConfig.src}/img/sprites/**/*.png`)    .pipe(spritesmith(opts)).on('error', function (err) {      console.log(err)    });  const imgStream = spriteData.img    .pipe(vinylBuffer())    .pipe($.pngquant({      quality: '90'    }))    .pipe(dest(`${gulpConfig.src}/img`));  const cssStream = spriteData.css    .pipe(dest(`${gulpConfig.src}/scss/vendor`));  return merge(imgStream, cssStream)}function update_normalize() {  return src([    `./node_modules/normalize.css/normalize.css`  ])    .pipe($.rename({      prefix: '_',      extname: '.scss'    }))    .pipe(dest(`${gulpConfig.src}/scss/common`))}function sass() {  return src([    `${gulpConfig.src}/scss/**/*.{scss, sass}`,    `!${gulpConfig.src}/scss/vendor/*-mixins.scss`  ], {sourcemaps: true})    .pipe($.sassGlob())    .pipe($.sass({      errLogToConsole: true,      outputStyle: 'compressed'    }).on('error', $.sass.logError))    .pipe($.autoprefixer({      overrideBrowserslist: gulpConfig.autoprefixer,      remove: false,      cascade: false    }))    .pipe(dest(`${gulpConfig.src}/css`))    .pipe(dest(`${gulpConfig.dist}/css`, {sourcemaps: true}))}function getFolders(dir) {  let result = [];  if (fs.statSync(dir).isDirectory()) {    result = fs.readdirSync(dir).filter((file) =&gt; fs.statSync(path.join(dir, file)).isDirectory());  }  return result;}async function spriteSvg() {  const folders = getFolders(`${gulpConfig.src}/img/sprites-svg`);  let options = {    spritesmith: (options) =&gt; {      const { folder, gulpConfig } = options;      return {        shape: {          spacing: {            padding: 4          },          id: {            generator: function (name) {              return path.basename(name.split(`${gulpConfig.src}/scss/vendor`).join(this.separator), '.svg');            }          }        },        mode: {          css: {            dest: './',            bust: false,            sprite: folder + '-svg.svg',            render:  {              scss: {                template: path.join(`${gulpConfig.src}/scss/vendor`, 'sprite-svg-mixins.handlebars'),                dest: path.posix.relative(`${gulpConfig.src}/img`, path.posix.join(`${gulpConfig.src}/scss`, 'vendor', '_'+folder+'-svg-mixins.scss'))              }            }          }        },        variables: {          spriteName: folder,          baseName: path.posix.relative(`${gulpConfig.src}/css`, path.posix.join(`${gulpConfig.src}/img`, folder + '-svg')),          svgToPng: ''        }      }    },  };  return folders.map((folder) =&gt; {    return new Promise((resolve) =&gt; {      src(path.join(`${gulpConfig.src}/img/sprites-svg`, folder, '*.svg'))        .pipe($.sort())        .pipe($.svgSprite(options.spritesmith({folder, gulpConfig})))        .pipe(dest(`${gulpConfig.src}/img`))        .on('end',resolve);    });  });}function optimize_png() {  // TODO: 'guip-filter' can be replaced by 'gulp-ignore'  // see https://github.com/robrich/gulp-ignore and minimatch  return src([    `${gulpConfig.src}/img/**/*.png`,    `!${gulpConfig.src}/img/**/*.ani.png`,    `!${gulpConfig.src}/img/**/sprite*.png`,  ], {since: lastRun(optimize_png)})    .pipe($.pngquant({      quality: '90'    }))    .pipe(dest(`${gulpConfig.src}/img`))}function optimize_others() {  return src([    `${gulpConfig.src}/img/**/*.{gif,jpg,jpeg,svg}`,    `!${gulpConfig.src}/img/**/sprite*.svg`,  ], {since: lastRun(optimize_others)})    .pipe($.imagemin([      $.imagemin.gifsicle({        interlaced: true      }), // gif      $.imagemin.jpegtran({        progressive: true      }), // jpg      $.imagemin.svgo({ // svg        plugins: [          {removeViewBox: true},          {cleanupIDs: false}        ]      })    ], {      verbose: true    }))    .pipe(dest(`${gulpConfig.src}/img`))}function copy_image() {  return src([    `${gulpConfig.src}/img/**/*`,    `!${gulpConfig.src}/img/sprites`,    `!${gulpConfig.src}/img/sprites/**/*`,    `!${gulpConfig.src}/img/sprites-svg`,    `!${gulpConfig.src}/img/sprites-svg/**/*`,  ])    .pipe(dest(`${gulpConfig.dist}/img`))}function process_html() {  return src([    `${gulpConfig.src}/html/**/*.html`,    `!${gulpConfig.src}/html/**/@*`,    `!${gulpConfig.src}/html/include/**/*`  ])    .pipe($.fileInclude(fileIncludeConfig))    .pipe($.jsbeautifier({      config: '.jsbeautifyrc',      mode: 'VERIFY_AND_WRITE'    }))    .pipe(dest(`${gulpConfig.dist}/html`))}async function stamps(){  await gitDateExtractor.getStamps({    outputToFile: true,    outputFileName: '../../timestamps.json',    onlyIn : ['./'],    projectRootPath: __dirname+'/src/html'  });}function make_indexfile() {  const dPath = `${gulpConfig.src}/html/`, // index를 생성할 파일들이 있는 저장소    info = getRepoInfo(), // git 정보 생성    fileInfo = fs.readdirSync(dPath),    stampData = fs.readFileSync('./timestamps.json'), // stamps 에서 생성한 json 읽기    jsonStampData = JSON.parse(stampData); // json 파일 이용가능하도록 parse  let normalFiles = []; // 파일 정보를 저장할 배열 생성  fileInfo.map(function (file) {    return path.join(dPath, file);  }).filter(function (file) {    return fs.statSync(file).isFile();  }).forEach(function (file) {    //HTML 파일만 거르기    let extname = path.extname(file),      basename = path.basename(file);    if (extname == '.html') {      // 일반 file info를 저장할 객체 생성      let nfileData = {};      // title 텍스트 값 추출      let fileInnerText = fs.readFileSync(file, 'utf8');      let $ = cheerio.load(fileInnerText);      let wholeTitle = $('title').text(),        splitTitle = wholeTitle.split(' : '),        //git 기준 마지막 변경 날짜        modifiedDate = jsonStampData[`${basename}`].modified*1000,        //git 기준 생성 날짜        createdDate = jsonStampData[`${basename}`].created*1000;      // 객체에 데이터 집어넣기      nfileData.title = splitTitle[0];      nfileData.name = basename;      nfileData.category = String(nfileData.name).substring(0, 2);      nfileData.categoryText = splitTitle[1];      nfileData.mdate = new Date(modifiedDate);      nfileData.cdate = new Date(createdDate);      nfileData.since = modifiedDate;      nfileData.age = createdDate;      // 파일수정시점 - 대한민국 표준시 기준      nfileData.ndate = nfileData.mdate.toLocaleString('ko-KR', {timeZone: 'Asia/Seoul'}) + ' (GMT+9)';      // title 마지막 조각 , 인덱스에 붙은 라벨 식별 및 yet 인 경우 수정날짜정보 제거      nfileData.status = splitTitle[2];      if (typeof splitTitle[2] == 'undefined' || splitTitle[2] == null || splitTitle[2] == '') {        nfileData.status = '';      } else if (splitTitle[2] == 'yet') {        nfileData.mdate = '';        nfileData.ndate = '';      }      normalFiles.push(nfileData);    }  });  let projectObj = {    nfiles: normalFiles,    branch: info.branch  }  let projectObjStr = JSON.stringify(projectObj);  let projectObjJson = JSON.parse(projectObjStr);  //index 파일 쓰기  return src('index.html')    .pipe(ejs(projectObjJson))    .pipe(dest(gulpConfig.dist))}/** * CSS: watch for style auto-compile * @example gulp */function clean_dist() {  return del(gulpConfig.dist)}function clean_json() {  return del(`${gulpConfig.dist}/json`)}function clean_css() {  return del([    `${gulpConfig.src}/css`,    `${gulpConfig.dist}/css`  ])}function clean_html() {  return del(`${gulpConfig.dist}/html`)}function clean_img() {  return del(`${gulpConfig.dist}/img`)}const browserSyncReload = (done) =&gt; {  browserSync.reload();  done();}function server() {  // serve files from the build folder  browserSync.init({    port: 8030,    ui: {      port: 8033,      weinre: {        port: 8133      }    },    cors: false, // if you need CORS, set true    server: {      baseDir: `${gulpConfig.dist}/`    }  });  console.log('\\x1b[32m%s\\x1b[0m', '[--:--:--] HTML/SCSS watch complete...');  watch([    `${gulpConfig.src}/img/**/*`,    `!${gulpConfig.src}/img/*.png`,    `!${gulpConfig.src}/img/*.svg`  ], series(clean_img, sprites, copy_image, sass, browserSyncReload));  watch([    `${gulpConfig.src}/scss/**/*`,    `!${gulpConfig.src}/scss/vendor/*-mixins.scss`  ], series(clean_css, sass, browserSyncReload));  watch(`${gulpConfig.src}/json/**/*`, series(clean_json, browserSyncReload));  watch(`${gulpConfig.src}/html/**/*`, series(clean_html, parallel(make_indexfile, process_html), browserSyncReload));  watch('index.html', series(make_indexfile, browserSyncReload));}function markup_watch() {  series(clean_dist, stamps, parallel(update_normalize, optimize_others, process_html, make_indexfile), sprites, sass, copy_image, server, () =&gt; {    console.log('\\x1b[32m%s\\x1b[0m', '[--:--:--] HTML/SCSS watch complete...')  })();}exports.default = markup_watch;function process_html_in_build() {  return src([    `${gulpConfig.src}/html/**/*.html`,    `!${gulpConfig.src}/html/**/@*`,    `!${gulpConfig.src}/html/include/**/*`  ])    .pipe($.fileInclude(fileIncludeConfig))    .pipe($.jsbeautifier({      config: '.jsbeautifyrc',      mode: 'VERIFY_AND_WRITE'    }))    .pipe(dest(`${gulpConfig.dist}/html`))}function accessibility_test() {  return src(`${gulpConfig.dist}/html/**/*`)    .pipe($.accessibility({      Accessibilityrc: '.accessibilityrc'    }))    .on('error', console.log)    .pipe($.accessibility.report({      reportType: 'txt'    }))    .pipe($.rename({      extname: '.txt'    }))    .pipe(dest('reports/txt'))}function zip() {  let date = new Date()  let dateFormatted = `${date.getFullYear()}${('0' + (date.getMonth() + 1)).slice(-2)}${('0' + date.getDate()).slice(-2)}T${('0' + date.getHours()).slice(-2)}${('0' + date.getMinutes()).slice(-2)}`  return src([    `${gulpConfig.dist}/**/*`,    `!${gulpConfig.dist}/**/*.zip`  ])    .pipe($.zip(`${packageJson.name}_${packageJson.version}_${dateFormatted}.zip`))    .pipe(dest(gulpConfig.dist))}/** * build: watch for style auto-compile * @example gulp build */function markup_build(done) {  series(clean_dist, stamps, parallel(update_normalize, optimize_png, optimize_others, process_html_in_build, make_indexfile), sprites, sass, copy_image, accessibility_test, zip, (done) =&gt; {    console.log('\\x1b[32m%s\\x1b[0m', '[--:--:--] Build complete...')    done()  })()  done()}exports.build = markup_build;// function sprite_img_rename(done) {//   return gulpConfig.spriteHash ? gulp.src([//     `${gulpConfig.dist}/img/sprite*.png`,//     `${gulpConfig.dist}/img/sprite*.svg`,//   ],{base: `${gulpConfig.dist}`})//     .pipe($.rev())//     .pipe($.revDeleteOriginal())//     .pipe(gulp.dest(`${gulpConfig.dist}`))//     .pipe($.rev.manifest())//     .pipe(gulp.dest(`${gulpConfig.dist}`)) : done()// }//// function sprite_css_rewrite(done) {//   const manifest = gulpConfig.spriteHash ? gulp.src(`${gulpConfig.dist}/rev-manifest.json`) : false;////   return gulpConfig.spriteHash ? gulp.src(`${gulpConfig.dist}/css/*.css`)//     .pipe($.revRewrite({ manifest }))//     .pipe(gulp.dest(`${gulpConfig.dist}/css`)) : done()// }function source_deploy() {  return src(`${gulpConfig.dist}/**/*`)    .pipe($.ghPages({      message: gulpConfig.deployMessage    }))}/** * deploy: watch for style auto-compile * @example gulp build */function markup_deploy(done) {  series(clean_dist, stamps, parallel(update_normalize, optimize_png, optimize_others, process_html_in_build, make_indexfile), sprites, sass, copy_image, accessibility_test, zip, source_deploy, (done) =&gt; {    console.log('\\x1b[32m%s\\x1b[0m', '[--:--:--] Build &amp; Deploy complete...');    done()  })()  done()}exports.deploy = markup_deploy;index.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=\"utf-8\"&gt;  &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover\"&gt;  &lt;title&gt;Pay TH&lt;/title&gt;  &lt;style&gt;a,body{color:#000}body,li{position:relative}body,button,dd,dl,dt,fieldset,form,h1,h2,h3,h4,h5,h6,input,legend,li,ol,p,select,table,td,textarea,th,ul{margin:0;padding:0;-webkit-text-size-adjust:none}body,button,input,select,table,textarea{font-family:-apple-system,system-ui,BlinkMacSystemFont,Roboto,sans-serif;font-size:14px;line-height:1.25em}body{padding:0 1em;padding:0 calc(1em + constant(safe-area-inset-right)) constant(safe-area-inset-bottom) calc(1em + constant(safe-area-inset-left));padding:0 calc(1em + env(safe-area-inset-right)) env(safe-area-inset-bottom) calc(1em + env(safe-area-inset-left));background-color:#fff;word-wrap:break-word;word-break:break-all}fieldset,img{border:0}ol,ul{list-style:none}a{text-decoration:none;cursor:pointer}h1{padding:.8em 4em .6em .1em;border-bottom:3px solid #222;background:#fff;font-size:1.2em}h2,h3{clear:both;font-size:1em}h2{padding:2em .1em .4em;border-bottom:1px solid #000}h3{padding:1em .1em .4em;border-bottom:1px dotted #888}.inf{padding:10px 2px 0;line-height:1.4em;color:#666}ul{margin-bottom:10px;font-size:.9em}li{border-bottom:1px solid #dfdfdf}li .na{display:block;padding:.7em 31px .6em .1em;color:#999}li .bx{display:inline-block;border:1px solid #999;background:#f2f2f2;font-size:.8em;padding:1px 3px;color:#999;border-radius:3px}li a{display:block;padding:.7em 31px .6em .1em;background:url(http://static.naver.com/www/m/cm/im/bu_lk.gif) 100% 50% no-repeat}li a span{margin-right:5px;font-weight:700;font-size:.85em}li a .sup{color:#a30}li .inner_btn{position:absolute;top:4px;right:35px;z-index:99;padding:0 5px;border:1px solid #da7c0c;background:#f78d1d;background:-webkit-gradient(linear,0 0,0 100%,from(#faa51a),to(#f47a20));font-size:11px;line-height:23px;color:#fef4e9;border-radius:3px;box-shadow:1px 1px 0 rgba(0,0,0,.3);-webkit-box-shadow:1px 1px 0 rgba(0,0,0,.3)}li .inner_btn:hover{background:#f47c20;background:-webkit-gradient(linear,0 0,0 100%,from(#f88e11),to(#f06015))}.message{display:block;margin:5px 0 0;font-size:14px;color:red;}.toc{padding:0 20px 20px;background:#efefef}.toc li a{text-transform:capitalize}.sec_h{text-transform:capitalize}.date{display:inline-block;padding:2px 4px;color:#a30;}.yet{color:#cfcdcd}.yet .date{background-color:#ccc;color:#fff}.yet .date:before{content:'YET'}.new .date{background-color:#f50a20;color:#fff}.new .date:before{content:'NEW|'}.update .date{background-color:#3c94e5;color:#fff}.update .date:before{content:'UPDATE|'}.sec_h:target,.sec_h:target+.page-lst{animation-duration:2s;animation-name:highlight;animation-iteration-count:1;}@keyframes highlight{from{background-color:rgba(255,120,0,.2);}to{background-color:rgba(255,120,0,0)}}  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Pay TH&lt;span class=\"message\"&gt;&lt;%= branch %&gt; 브랜치&lt;/span&gt;&lt;/h1&gt;&lt;p class=\"inf\"&gt;description of LINE Project&lt;/p&gt;&lt;img src=\"\" id=\"_im1\" width=\"150\" height=\"150\" style=\"width:150px;height:150px\"&gt;&lt;script&gt;document.getElementById(\"_im1\").src = 'http://chart.apis.google.com/chart?cht=qr&amp;chs=150x150&amp;chl='+encodeURIComponent(location.href);&lt;/script&gt;&lt;div class=\"toc\"&gt;  &lt;h2&gt;카테고리 바로가기&lt;/h2&gt;  &lt;ul&gt;    &lt;% for (var i=0; i &lt; 100 ; i++){    var categoryNum = String(\"0\" + i).slice(-2);    var colIndex = 0;    var nfileList = nfiles;    for(var j=0 ; j &lt; nfileList.length; j++){    if (categoryNum == nfileList[j].category){    if (colIndex == 0){ %&gt;    &lt;li&gt;&lt;a href=\"#tab&lt;%= categoryNum %&gt;\"&gt;&lt;%= nfileList[j].categoryText %&gt;&lt;/a&gt;&lt;/li&gt;&lt;%}    colIndex++;    }    }    }%&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;%var today = new Date();today = Date.parse(today);for (var i=0; i &lt; 100 ; i++){var categoryNum = String(\"0\" + i).slice(-2);var listCount = 0;var nfileList = nfiles;var lastCategory = nfileList[nfileList.length - 1].category;for(var j=0 ; j &lt; nfileList.length; j++){if (categoryNum == nfileList[j].category){if (listCount == 0){ %&gt;&lt;h2 id=\"tab&lt;%= categoryNum %&gt;\" class=\"sec_h\"&gt;&lt;%= nfileList[j].categoryText %&gt;&lt;/h2&gt;&lt;ul class=\"page-lst\"&gt;&lt;%} %&gt;  &lt;li&gt;    &lt;a class=\"&lt;%= nfileList[j].status %&gt;\" href=\"html/&lt;%= nfileList[j].name %&gt;\"&gt;      &lt;%= nfileList[j].title %&gt; / &lt;%= nfileList[j].name %&gt;      &lt;span class=\"date\" title=\"&lt;%= nfileList[j].ndate %&gt;\" data-since=\"&lt;%= nfileList[j].since %&gt;\" data-age=\"&lt;%= nfileList[j].age %&gt;\"&gt;&lt;%= nfileList[j].mdate.substring(2,10).replace(/-/gi,'') %&gt;&lt;/span&gt;    &lt;/a&gt; &lt;% if (nfileList[j].splitStatus) { %&gt;    &lt;% } %&gt;  &lt;/li&gt; &lt;% listCount++; } }  if (categoryNum &lt;= lastCategory &amp;&amp; listCount &gt;= 1) { %&gt;&lt;/ul&gt; &lt;%  } } %&gt;&lt;script&gt;  var unbindEl = document.querySelectorAll('.yet'),    unbindElLength = unbindEl.length;  for (i=0;i &lt; unbindElLength; i++) {    var unbindParent = unbindEl[i].parentNode;    unbindParent.addEventListener('click', noti);    function noti(e){      e.preventDefault();      alert('작업 진행중인 페이지입니다.');    }  }  var pageListItem = document.querySelectorAll('.page-lst li'),    statusResetDate = 28 * 86400 * 1000;  for(var l = 0; l &lt; pageListItem.length; l++) {    var since = pageListItem[l].querySelector('.date').getAttribute('data-since');    var age = pageListItem[l].querySelector('.date').getAttribute('data-age');    if(Date.now() - age &lt; statusResetDate &amp;&amp; !pageListItem[l].querySelector('a').classList.contains('yet')) {      pageListItem[l].querySelector('a').classList.add('new');    }    else if(Date.now() - since &lt; statusResetDate &amp;&amp; !pageListItem[l].querySelector('a').classList.contains('yet')) {      pageListItem[l].querySelector('a').classList.add('update');    }  }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;.accessibilityrc{  \"accessibilityLevel\": \"WCAG2A\",  \"ignore\": [    \"WCAG2A.Principle2.Guideline2_4.2_4_2.H25.1.NoTitleEl\",    \"WCAG2A.Principle3.Guideline3_1.3_1_1.H57.2\"  ],  \"reportLevels\": {    \"notice\": false,    \"warning\": true,    \"error\": true  },  \"force\": true,  \"verbose\": false}.jsbeautifyrc{  \"html\": {    \"allowed_file_extensions\": [\"htm\", \"html\", \"xhtml\", \"shtml\", \"xml\", \"svg\", \"dust\"],    \"brace_style\": \"collapse\",    \"end_with_newline\": true,    \"indent_char\": \" \",    \"indent_with_tabs\": false,    \"indent_handlebars\": true,    \"indent_inner_html\": false,    \"indent_scripts\": \"keep\",    \"indent_size\": 2,    \"preserve_newlines\": true,    \"max_preserve_newlines\": 1,    \"unformatted\": [\"a\", \"span\", \"img\", \"code\", \"pre\", \"sub\", \"sup\", \"em\", \"strong\", \"b\", \"i\", \"u\", \"strike\", \"big\", \"small\", \"pre\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"],    \"wrap_line_length\": 0  },  \"css\": {    \"allowed_file_extensions\": [\"css\", \"scss\", \"sass\", \"less\"],    \"end_with_newline\": true,    \"indent_char\": \" \",    \"indent_size\": 2,    \"newline_between_rules\": true,    \"selector_separator\": \" \",    \"selector_separator_newline\": false,    \"preserve_newlines\": true,    \"max_preserve_newlines\": 2  },  \"js\": {    \"allowed_file_extensions\": [\"js\", \"json\", \"jshintrc\", \"jsbeautifyrc\"],    \"brace_style\": \"collapse\",    \"break_chained_methods\": false,    \"e4x\": false,    \"end_with_newline\": true,    \"indent_char\": \" \",    \"indent_level\": 0,    \"indent_size\": 2,    \"indent_with_tabs\": false,    \"jslint_happy\": false,    \"keep_array_indentation\": false,    \"keep_function_indentation\": false,    \"preserve_newlines\": true,    \"max_preserve_newlines\": 2,    \"space_after_anon_function\": true,    \"space_before_conditional\": true,    \"space_in_empty_paren\": false,    \"space_in_paren\": false,    \"unescape_strings\": false,    \"wrap_line_length\": 0  }}package.json{  \"name\": \"\",  \"version\": \"0.0.0\",  \"description\": \"\",  \"repository\": {    \"type\": \"git\",    \"url\": \"\"  },  \"bugs\": {    \"url\": \"\"  },  \"private\": true,  \"engines\": {    \"node\": \"^10.16.3\",    \"npm\": \"^6.10.3\"  },  \"dependencies\": {},  \"devDependencies\": {    \"browser-sync\": \"^2.26.7\",    \"cheerio\": \"^1.0.0-rc.3\",    \"del\": \"^5.0.0\",    \"git-date-extractor\": \"^2.0.0\",    \"git-repo-info\": \"^2.1.1\",    \"gulp\": \"^4.0.2\",    \"gulp-accessibility\": \"^3.1.1\",    \"gulp-autoprefixer\": \"^7.0.0\",    \"gulp-clean-css\": \"^4.2.0\",    \"gulp-ejs\": \"^4.1.1\",    \"gulp-file-include\": \"^2.1.0\",    \"gulp-gh-pages\": \"^0.5.4\",    \"gulp-htmlmin\": \"^5.0.1\",    \"gulp-if\": \"^3.0.0\",    \"gulp-imagemin\": \"^6.0.0\",    \"gulp-jsbeautifier\": \"^3.0.1\",    \"gulp-load-plugins\": \"^2.0.1\",    \"gulp-pngquant\": \"^1.0.12\",    \"gulp-rename\": \"^1.4.0\",    \"gulp-replace\": \"^1.0.0\",    \"gulp-sass\": \"^4.0.1\",    \"gulp-sass-glob\": \"^1.1.0\",    \"gulp-sort\": \"^2.0.0\",    \"gulp-svg-sprite\": \"^1.5.0\",    \"gulp-uglify\": \"^3.0.0\",    \"gulp-zip\": \"^5.0.0\",    \"gulp.spritesmith-multi\": \"^3.1.0\",    \"merge-stream\": \"^2.0.0\",    \"normalize.css\": \"^8.0.1\",    \"path\": \"^0.12.7\",    \"run-sequence\": \"^2.2.1\",    \"vinyl-buffer\": \"^1.0.1\"  },  \"license\": \"ISC\"}"
}, 

{
"id": "-issue-2020-05-12-issue19",
"title": "autoprefixer 모듈관련?",
"author": null,
"tags": [],
"url": "/issue/2020/05/12/issue19/",
"date": "2020-05-12",
"content": "https://github.com/browserslist/browserslist#best-practices"
}, 

{
"id": "-issue-2020-05-12-issue18",
"title": "CSS display:inline-block changes text size on mobile?",
"author": null,
"tags": [],
"url": "/issue/2020/05/12/issue18/",
"date": "2020-05-12",
"content": "CSS display:inline-block changes text size on mobile?재현기기 : 안드로이드 7.0 / 8.1.0 크롬브라우저글자를 감싼 요소가 display: inline-block 일 때, 시스템 폰트를 확대할 시, inline-block으로 감싸진 텍스트들만 확대가 안된다.해결방법 : …"
}, 

{
"id": "-issue-2020-05-12-issue17",
"title": "git 수정된 파일 목록 가져오기 git log --stat",
"author": null,
"tags": [],
"url": "/issue/2020/05/12/issue17/",
"date": "2020-05-12",
"content": "git log --stat수정된 파일 목록 가져오기"
}, 

{
"id": "-issue-2020-05-12-issue16",
"title": "gulp - git hash 번호 붙이기 및 make_index 함수 수정",
"author": null,
"tags": [],
"url": "/issue/2020/05/12/issue16/",
"date": "2020-05-12",
"content": "index 만드는 함수// gitlog 모듈 필요const gitLog = require('gitlog').default;function make_indexfile() {  const dPath = `${gulpConfig.src}/html/`, // index를 생성할 파일들이 있는 저장소    info = getRepoInfo(), // git 정보 생성    fileInfo = fs.readdirSync(dPath); // 파일 목록 불러오는 함수를 동기적으로 수정  let normalFiles = []; // 파일 정보를 저장할 배열 생성  fileInfo.map(function (file) {    return path.join(dPath, file);  }).filter(function (file) {    return fs.statSync(file).isFile();  }).forEach(function (file) {    let stats = fs.statSync(file);    //HTML 파일만 거르기    let extname = path.extname(file),      basename = path.basename(file);    if (extname == '.html') {      // 일반 file info를 저장할 객체 생성      let nfileData = {};      // title 텍스트 값 추출      let fileInnerText = fs.readFileSync(file, 'utf8');      let $ = cheerio.load(fileInnerText);      let wholeTitle = $('title').text(),        splitTitle = wholeTitle.split(' : ');      // 객체에 데이터 집어넣기      nfileData.title = splitTitle[0];      nfileData.name = basename;      nfileData.category = String(nfileData.name).substring(0, 2);      nfileData.categoryText = splitTitle[1];      nfileData.mdate = new Date(util.inspect(stats.mtime));      // 파일수정시점 - 대한민국 표준시 기준      nfileData.ndate = nfileData.mdate.toLocaleString('ko-KR', {timeZone: 'Asia/Seoul'}) + ' (GMT+9)';      // 브랜치 정보      nfileData.branch = info.branch;      // title 마지막 조각 , 인덱스에 붙은 라벨 식별 및 yet 인 경우 수정날짜정보 제거      nfileData.status = splitTitle[2];      if (typeof splitTitle[2] == 'undefined' || splitTitle[2] == null || splitTitle[2] == '') {        nfileData.status = '';      } else if (splitTitle[2] == 'yet') {        nfileData.mdate = '';        nfileData.ndate = '';      }      normalFiles.push(nfileData);    }  });  const gitOptions = {    repo: __dirname,    number: 20,    fields: [\"hash\", \"abbrevHash\", \"subject\", \"body\", \"authorName\", \"authorDateRel\", \"committerDate\", \"committerDateRel\"],    execOptions: { maxBuffer: 1000 * 1024 },  };  const commits = gitLog(gitOptions).reverse();  for (let i = 0; i &lt; normalFiles.length; i++) {    for (let j =0; j &lt; commits.length; j++) {      let boolean = commits[j].files.filter((x) =&gt; {        if (path.extname(x) === '.html') return x      }).map((x) =&gt; path.basename(x)).some(x =&gt; x === normalFiles[i].name);      if (boolean) {        normalFiles[i].committerDate = new Date(commits[j].committerDate).toLocaleDateString();        normalFiles[i].abbrevHash = commits[j].abbrevHash;      }    }  }  let projectObj = {    nfiles: normalFiles  }  let projectObjStr = JSON.stringify(projectObj);  let projectObjJson = JSON.parse(projectObjStr);  //index 파일 쓰기  return src('index.html')    .pipe(ejs(projectObjJson))    .pipe(dest(gulpConfig.dist))}index&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;\t&lt;meta charset=\"utf-8\"&gt;\t&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover\"&gt;\t&lt;title&gt;Pay TH&lt;/title&gt;\t&lt;style&gt;a,body{color:#000}body,li{position:relative}body,button,dd,dl,dt,fieldset,form,h1,h2,h3,h4,h5,h6,input,legend,li,ol,p,select,table,td,textarea,th,ul{margin:0;padding:0;-webkit-text-size-adjust:none}body,button,input,select,table,textarea{font-family:-apple-system,system-ui,BlinkMacSystemFont,Roboto,sans-serif;font-size:14px;line-height:1.25em}body{padding:0 1em;background-color:#fff;word-wrap:break-word;word-break:break-all}fieldset,img{border:0}ol,ul{list-style:none}a{text-decoration:none;cursor:pointer}h1{padding:.8em 4em .6em .1em;border-bottom:3px solid #222;background:#fff;font-size:1.2em}h2,h3{clear:both;font-size:1em}h2{padding:2em .1em .4em;border-bottom:1px solid #000}h3{padding:1em .1em .4em;border-bottom:1px dotted #888}.inf{padding:10px 2px 0;line-height:1.4em;color:#666}ul{margin-bottom:10px;font-size:.9em}li{border-bottom:1px solid #dfdfdf}li .na{display:block;padding:.7em 31px .6em .1em;color:#999}li .bx{display:inline-block;border:1px solid #999;background:#f2f2f2;font-size:.8em;padding:1px 3px;color:#999;border-radius:3px}li a{display:block;padding:.7em 31px .6em .1em;background:url(http://static.naver.com/www/m/cm/im/bu_lk.gif) 100% 50% no-repeat}li a span{margin-right:5px;font-weight:700;font-size:.85em}li a .sup{color:#a30}li .inner_btn{position:absolute;top:4px;right:35px;z-index:99;padding:0 5px;border:1px solid #da7c0c;background:#f78d1d;background:-webkit-gradient(linear,0 0,0 100%,from(#faa51a),to(#f47a20));font-size:11px;line-height:23px;color:#fef4e9;border-radius:3px;box-shadow:1px 1px 0 rgba(0,0,0,.3);-webkit-box-shadow:1px 1px 0 rgba(0,0,0,.3)}li .inner_btn:hover{background:#f47c20;background:-webkit-gradient(linear,0 0,0 100%,from(#f88e11),to(#f06015))}.message{display:block;margin:5px 0 0;font-size:14px;color:red;}.toc{padding:0 20px 20px;background:#efefef}.toc li a{text-transform:capitalize}.sec_h{text-transform:capitalize}.date{display:inline-block;padding:2px 4px;color:#a30;}.yet{color:#cfcdcd}.yet .date{background-color:#ccc;color:#fff}.yet .date:before{content:'YET'}.new .date{background-color:#f50a20;color:#fff}.new .date:before{content:'NEW|'}.update .date{background-color:#3c94e5;color:#fff}.update .date:before{content:'UPDATE|'}.sec_h:target,.sec_h:target+.page-lst{animation-duration:2s;animation-name:highlight;animation-iteration-count:1;}@keyframes highlight{from{background-color:rgba(255,120,0,.2);}to{background-color:rgba(255,120,0,0)}}\t&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;th-bank-markup&lt;span class=\"message\"&gt;&lt;%= nfiles[0].branch %&gt; 브랜치&lt;/span&gt;&lt;/h1&gt;&lt;p class=\"inf\"&gt;LINE CWA - Line Bank Thailand&lt;/p&gt;&lt;img src=\"\" id=\"_im1\" width=\"150\" height=\"150\" style=\"width:150px;height:150px\"&gt;&lt;script&gt;document.getElementById(\"_im1\").src = 'http://chart.apis.google.com/chart?cht=qr&amp;chs=150x150&amp;chl='+encodeURIComponent(location.href);&lt;/script&gt;&lt;div class=\"toc\"&gt;\t&lt;h2&gt;카테고리 바로가기&lt;/h2&gt;\t&lt;ul&gt;\t\t&lt;% for (var i=0; i &lt; 100 ; i++){\t\tvar categoryNum = String(\"0\" + i).slice(-2);\t\tvar colIndex = 0;\t\tvar nfileList = nfiles;\t\tfor(var j=0 ; j &lt; nfileList.length; j++){\t\tif (categoryNum == nfileList[j].category){\t\tif (colIndex == 0){ %&gt;\t\t&lt;li&gt;&lt;a href=\"#tab&lt;%= categoryNum %&gt;\"&gt;&lt;%= nfileList[j].categoryText %&gt;&lt;/a&gt;&lt;/li&gt;&lt;%}\t\tcolIndex++;\t\t}\t\t}\t\t}%&gt;\t&lt;/ul&gt;&lt;/div&gt;&lt;%var today = new Date();today = Date.parse(today);for (var i=0; i &lt; 100 ; i++){var categoryNum = String(\"0\" + i).slice(-2);var listCount = 0;var nfileList = nfiles;var lastCategory = nfileList[nfileList.length - 1].category;for(var j=0 ; j &lt; nfileList.length; j++){if (categoryNum == nfileList[j].category){if (listCount == 0){ %&gt;&lt;h2 id=\"tab&lt;%= categoryNum %&gt;\" class=\"sec_h\"&gt;&lt;%= nfileList[j].categoryText %&gt;&lt;/h2&gt;&lt;ul class=\"page-lst\"&gt;&lt;%} %&gt;\t&lt;li&gt;\t\t&lt;a class=\"&lt;%= nfileList[j].status %&gt;\" href=\"html/&lt;%= nfileList[j].name %&gt;\"&gt;\t\t\t&lt;%= nfileList[j].title %&gt; / &lt;%= nfileList[j].name %&gt;\t\t\t&lt;span class=\"date\" title=\"&lt;%= nfileList[j].ndate %&gt;\"&gt;&lt;%= nfileList[j].committerDate.substring(2,10).replace(/-/gi,'') %&gt;&lt;/span&gt;\t\t\t&lt;span class=\"date\" title=\"&lt;%= nfileList[j].ndate %&gt;\"&gt;&lt;%= nfileList[j].abbrevHash %&gt;&lt;/span&gt;&lt;!--\t\t\t&lt;span class=\"date\" title=\"&lt;%= nfileList[j].ndate %&gt;\"&gt;&lt;%= nfileList[j].mdate.substring(2,10).replace(/-/gi,'') %&gt;&lt;/span&gt;--&gt;\t\t&lt;/a&gt; &lt;% if (nfileList[j].splitStatus) { %&gt;\t\t&lt;% } %&gt;\t&lt;/li&gt; &lt;% listCount++; } }  if (categoryNum &lt;= lastCategory &amp;&amp; listCount &gt;= 1) { %&gt;&lt;/ul&gt; &lt;%  } } %&gt;&lt;script&gt;\tvar unbindEl = document.querySelectorAll('.yet'),\t\t\tunbindElLength = unbindEl.length;\tfor (i=0;i &lt; unbindElLength; i++) {\t\tvar unbindParent = unbindEl[i].parentNode;\t\tunbindParent.addEventListener('click', noti);\t\tfunction noti(e){\t\t\te.preventDefault();\t\t\talert('작업 진행중인 페이지입니다.');\t\t}\t}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"
}, 

{
"id": "-issue-2020-05-12-issue15",
"title": "파일 목록을 뽑아오는 함수 파헤치기",
"author": null,
"tags": [],
"url": "/issue/2020/05/12/issue15/",
"date": "2020-05-12",
"content": "const {src, dest} = require('gulp');const fs = require('fs');const path = require('path');const cheerio = require('cheerio');const ejs = require('gulp-ejs');const getRepoInfo = require('git-repo-info');function make_indexfile(done) {  // git 정보를 info 상수에 담는다.  const info = getRepoInfo();  // 파일 정보를 저장할 배열 생성  let normalFiles = [];  fs.readdir('./src/html/', function (err, files) {    if (err) {      throw err;    }    files.map(function (file) {      // console.log(`./src/html/${file}`);      // console.log(path.join('./src/html', file));      // 현재 html 파일들의 경로와 파일명을 합쳐서 다음 함수로 전달한다.      return path.join('./src/html', file);    }).filter(function (file) {      // console.log(fs.statSync(file));      // console.log(fs.statSync(file).isFile());      // 전달 받은 파일경로+파일명들이 파일인지 아닌지 구분하여 아닌 것들은 걸러낸다.      return fs.statSync(file).isFile();    }).forEach(function (file) {      // 넘어온 파일들의 목록의 상태 목록들을 stats 상수에 저장한다.      // https://psyhm.tistory.com/15      const stats = fs.statSync(file);      // 넘어온 파일들의 확장자 목록들을 extname 상수에 저장한다.      const extname = path.extname(file);      // 넘어온 파일목록의 파일명+확장자 목록을 basename 상수에 저장한다.      const basename = path.basename(file);      // 확장자가 html 이라면      if (extname === '.html') {        // 일반 file info를 저장할 변수 nfileData를 생성한다. 객체형        let nfileData = {};        // 각 파일의 내용을 fileInnerText 상수에 저장한다.        const fileInnerText = fs.readFileSync(file, 'utf8');        // cheerio 모듈 - html 파일 편집을 도와주는 모듈이다.        // 각 파일의 내용들을 담은 상수 fileInnerText를 로드해 $ 변수에 저장한다.        const $ = cheerio.load(fileInnerText);        // title 태그 안에 text들을 wholeTitle에 저장한다.        const wholeTitle = $('title').text();        // : 콜론을 기준으로 쪼개서 splitTitle 상수에 배열 형태로 저장한다.        const splitTitle = wholeTitle.split(' : ');        // 객체에 데이터 집어넣기        // nfileData 객체의 title 키에 splitTitle 첫번째 요소를 대입한다.        // trim 메서드는 앞뒤로 공백을 없애준다.        nfileData.title = splitTitle[0].trim();        // nfileData 객체의 name 키에 file의 베이스이름(파일명+확장자, 경로제외)을 저장한다.        nfileData.name = path.basename(file);        // nfileData 객체의 name 키에 저장된 문자열 데이터에서 첫번째 글자부터 두번째 글자까지 잘라서 category 키값에 저장한다.        nfileData.category = nfileData.name.substring(0, 2);        // nfileData 객체의 categoryText 키에 splitTitle 두번째 요소를 대입한다.        // trim 메서드는 앞뒤로 공백을 없애준다.        nfileData.categoryText = splitTitle[1].trim();        // 마지막 수정시간을 nfileData 객체의 mdate 키에 담는다.        // mtile = modification date        nfileData.mdate = new Date(stats.mtime);        // 마지막 파일수정시점을 ndate 키에 담는다. - 대한민국 표준시 기준        nfileData.ndate = nfileData.mdate.toLocaleString('ko-KR',{timeZone:'Asia/Seoul'})+' (GMT+9)';        // 브랜치 정보를 branch 키에 담는다.        nfileData.branch = info.branch        // title 마지막 조각 , 인덱스에 붙은 라벨 식별 및 yet 인 경우 수정날짜정보 제거        nfileData.status = splitTitle[2];        if(typeof splitTitle[2] == 'undefined' || splitTitle[2] == null || splitTitle[2] == '') {          nfileData.status = '';        }        else if(splitTitle[2] == 'yet') {          nfileData.mdate = '';          nfileData.ndate = '';        }        normalFiles.push(nfileData);      }    })    const projectObj = {      nfiles: normalFiles    }    // projectObj, normalFiles 키값에 다른 유형의 데이터가 있기 때문에 아래처럼 문자열 데이터로 변형한 후 projectObjStr 상수에 담는다.    const projectObjStr = JSON.stringify(projectObj);    // 문자열화된 데이터를 다시 JSON 객체화시켜서 projectObjJson 상수에 담는다.    // 이렇게해야 마지막 수정시간으로 저장된 mdate 의 value가 문자열로 JSON 객체화돼서 ejs와 연동시킬 수 있다.    const projectObjJson = JSON.parse(projectObjStr);    console.log(projectObjJson)    //index 파일 쓰기    // return src('index.html')    //     .pipe(ejs(projectObjJson))    //     .pipe(dest('./dist/'))  });  // 아래 done 함수는 매개변수에서 전달받은 함수를 실행시킨 것이다.  // 보통 이렇게 작성하면 done 매개변수로 받는 인자값이 아무것도 없기 때문에 정의가 안되었다는 에러가 발생한다.  // 하지만 gulp에선 아래와 같이 쓰면 함수가 끝났다는 것을 알려준다.  // gulp에 내재되어있는 기능 중 한개같다.\t// https://stackoverflow.com/questions/29298244/gulp-where-is-the-gulp-task-callback-function-defined\t// 더 알아보니 이렇게 모듈로 타고타고 들어가서 처리된다는 것을 알 수 있었다.\t// 신기하다. 아래 done() 은 함수가 끝났는지 안끝났는지 여부만 알려주고 그이상 그이하도 아니다.  // done();}// exports.default = make_indexfile;make_indexfile();"
}, 

{
"id": "-issue-2020-05-12-issue14",
"title": "gulp - git log 읽고 index.html 옆에 최신 log남기기",
"author": null,
"tags": [],
"url": "/issue/2020/05/12/issue14/",
"date": "2020-05-12",
"content": "index.html 파일을 ejs 템플릿으로 컴파일 할 때 현재 로컬서버의 시간을 읽어서 mdate, 즉 modified date를 넘긴다.하지만 이렇게 되면 로컬에선 수정되었지만, git에선 수정이 안된걸로 읽혀 커밋 기록에 남은 수정날짜 시간과 index.html에 출력되는 수정된 날짜가 다를 수 있다.이를 해결하기 위해 git commit 기록을 읽을 수 있는 방법을 찾아 최신 커밋기록으로 파일목록에 해당 날짜들을 남기고, 관리해야될 것 같다.https://www.npmjs.com/package/git-log위 모듈로 연구해봐야될 것 같다."
}, 

{
"id": "-issue-2020-05-12-issue13",
"title": "gulp화 할 때 주의할 점",
"author": null,
"tags": [],
"url": "/issue/2020/05/12/issue13/",
"date": "2020-05-12",
"content": "accessibility_test 함수.dist/html/ 이 경로에 순수 html 파일만 있는 것이 아니라 include 폴더 같은 것들이 같이 결과물로 나오면 접근성 태스트 함수가 에러가 난다.스펠링 체크 항상 주의!!src/\tㄴ html\t\tㄴ include\tㄴ img\t\tㄴ sprites\tㄴ js\tㄴ scss\t\tㄴ vendorgulpfile.js'use strict'/*jshint -W110 */const fs = require('fs'),    path = require('path'), // added    cheerio = require('cheerio'), // added    util = require('util'), // added    ejs = require('gulp-ejs'), // added    packageJson = JSON.parse(fs.readFileSync('package.json')),    {src, dest, watch, series, parallel, lastRun} = require('gulp'),    del = require('del'),    merge = require('merge-stream'),    browserSync = require('browser-sync').create(),    vinylBuffer = require('vinyl-buffer'),    spritesmith = require('gulp.spritesmith-multi'),    getRepoInfo = require('git-repo-info'),    $ = require('gulp-load-plugins')({        camelize: true    }),    gulpConfig = {        autoprefixer: ['&gt; 1%', 'last 2 versions', 'iOS 5', 'Android 2.3', 'FF 20', 'IE 8'],        deployMessage: '[UPDATE] deploy to gh-pages',        src: './src',        dist: './dist'    },    fileIncludeConfig = {        \"prefix\": \"@@\",        \"basepath\": \"@file\",        \"context\": {}    };function sprites() {    const opts = {        spritesmith: function (options, sprite, icons) {            options.imgName = `sp_${sprite}.png`;            options.imgPath = `../img/${options.imgName}`;            options.cssName = `_sp_${sprite}-mixins.scss`;            options.cssTemplate = `${gulpConfig.src}/scss/vendor/spritesmith-mixins.handlebars`;            options.cssSpritesheetName = sprite;            options.padding = 4;            options.algorithm = 'binary-tree';            return options        }    };    const spriteData = src(`${gulpConfig.src}/img/sprites/**/*.png`)        .pipe(spritesmith(opts)).on('error', function (err) {            console.log(err)        });    const imgStream = spriteData.img        .pipe(vinylBuffer())        .pipe($.pngquant({            quality: '90'        }))        .pipe(dest(`${gulpConfig.src}/img`));    const cssStream = spriteData.css        .pipe(dest(`${gulpConfig.src}/scss/vendor`));    return merge(imgStream, cssStream)}function sass() {    return src([        `${gulpConfig.src}/scss/**/*.{scss, sass}`,        `!${gulpConfig.src}/scss/vendor/*-mixins.scss`    ], {sourcemaps: true})        .pipe($.sass({            outputStyle: 'expanded'        }).on('error', $.sass.logError))        .pipe($.autoprefixer({            overrideBrowserslist: gulpConfig.autoprefixer,            remove: false,            cascade: false        }))        .pipe($.base64Inline())        .pipe(dest(`${gulpConfig.src}/css`))        .pipe(dest(`${gulpConfig.dist}/css`, {sourcemaps: true}))}function optimize_png() {    // TODO: 'guip-filter' can be replaced by 'gulp-ignore'    // see https://github.com/robrich/gulp-ignore and minimatch    return src([        `${gulpConfig.src}/img/**/*.png`,        `!${gulpConfig.src}/img/sprites/**/*`,    ], {since: lastRun(optimize_png)})        .pipe($.pngquant({            quality: '90'        }))        .pipe(dest(`${gulpConfig.src}/img`))}function optimize_others() {    return src([        `${gulpConfig.src}/img/**/*.{gif,jpg,jpeg,svg}`,        `!${gulpConfig.src}/img/sprites/**/*`,    ], {since: lastRun(optimize_others)})        .pipe($.imagemin([            $.imagemin.gifsicle({                interlaced: true            }), // gif            $.imagemin.jpegtran({                progressive: true            }), // jpg            $.imagemin.svgo({ // svg                plugins: [                    {removeViewBox: true},                    {cleanupIDs: false}                ]            })        ], {            verbose: true        }))        .pipe(dest(`${gulpConfig.src}/img`))}function copy_image() {    return src([        `${gulpConfig.src}/img/**/*`,        `!${gulpConfig.src}/img/sprites`,        `!${gulpConfig.src}/img/sprites/**/*`,        `!${gulpConfig.src}/img/sprites-svg`,        `!${gulpConfig.src}/img/sprites-svg/**/*`,    ])        .pipe(dest(`${gulpConfig.dist}/img`))}function process_html() {    return src([        `${gulpConfig.src}/html/**/*.html`,        `!${gulpConfig.src}/html/include/**/*.html`,    ])        .pipe($.fileInclude(fileIncludeConfig))        .pipe($.jsbeautifier({            config: '.jsbeautifyrc',            mode: 'VERIFY_AND_WRITE'        }))        .pipe(dest(`${gulpConfig.dist}/html`))}function make_indexfile(done) {    let dPath = `${gulpConfig.src}/html/`, // index를 생성할 파일들이 있는 저장소        normalFiles = [], // 파일 정보를 저장할 배열 생성        info = getRepoInfo() // git 정보 생성    // 파일 목록 읽고, 필요한 정보 저장    fs.readdir(dPath, function (err, files) {        if (err) {            throw err;        }        files.map(function (file) {            return path.join(dPath, file);        }).filter(function (file) {            return fs.statSync(file).isFile();        }).forEach(function (file) {            let stats = fs.statSync(file);            //HTML 파일만 거르기            let extname = path.extname(file),                basename = path.basename(file);            if (extname == '.html') {                // 일반 file info를 저장할 객체 생성                let nfileData = {};                // title 텍스트 값 추출                let fileInnerText = fs.readFileSync(file, 'utf8');                let $ = cheerio.load(fileInnerText);                let wholeTitle = $('title').text(),                    splitTitle = wholeTitle.split(' : ');                // 객체에 데이터 집어넣기                nfileData.title = splitTitle[0];                nfileData.name = path.basename(file);                nfileData.category = String(nfileData.name).substring(0, 2);                nfileData.categoryText = splitTitle[1];                nfileData.mdate = new Date(util.inspect(stats.mtime));                // 파일수정시점 - 대한민국 표준시 기준                nfileData.ndate = nfileData.mdate.toLocaleString('ko-KR', {timeZone: 'Asia/Seoul'}) + ' (GMT+9)';                // 브랜치 정보                nfileData.branch = info.branch                // title 마지막 조각 , 인덱스에 붙은 라벨 식별 및 yet 인 경우 수정날짜정보 제거                nfileData.status = splitTitle[2];                if (typeof splitTitle[2] == 'undefined' || splitTitle[2] == null || splitTitle[2] == '') {                    nfileData.status = '';                } else if (splitTitle[2] == 'yet') {                    nfileData.mdate = '';                    nfileData.ndate = '';                }                normalFiles.push(nfileData);            }        });        let projectObj = {            nfiles: normalFiles        }        let projectObjStr = JSON.stringify(projectObj);        let projectObjJson = JSON.parse(projectObjStr);        //index 파일 쓰기        return src('index.html')            .pipe(ejs(projectObjJson))            .pipe(dest(gulpConfig.dist))    });    done();}/** * CSS: watch for style auto-compile * @example gulp */function clean_dist() {    return del(gulpConfig.dist)}function clean_json() {    return del(`${gulpConfig.dist}/json`)}function clean_css() {    return del([        `${gulpConfig.src}/css`,        `${gulpConfig.dist}/css`    ])}function clean_html() {    return del(`${gulpConfig.dist}/html`)}function clean_img() {    return del(`${gulpConfig.dist}/img`)}const browserSyncReload = (done) =&gt; {    browserSync.reload();    done();}function server() {    // serve files from the build folder    browserSync.init({        port: 8030,        ui: {            port: 8033,            weinre: {                port: 8133            }        },        cors: false, // if you need CORS, set true        server: {            baseDir: `${gulpConfig.dist}/`        }    });    console.log('\\x1b[32m%s\\x1b[0m', '[--:--:--] HTML/SCSS watch complete...');    watch([        `${gulpConfig.src}/img/**/*`,        `!${gulpConfig.src}/img/*.png`,        `!${gulpConfig.src}/img/*.svg`    ], series(clean_img, sprites, copy_image, sass, browserSyncReload));    watch([        `${gulpConfig.src}/scss/**/*`,        `!${gulpConfig.src}/scss/vendor/*-mixins.scss`    ], series(clean_css, sass, browserSyncReload));    watch(`${gulpConfig.src}/json/**/*`, series(clean_json, browserSyncReload));    watch(`${gulpConfig.src}/html/**/*`, series(clean_html, parallel(make_indexfile, process_html), browserSyncReload));    watch('index.html', series(make_indexfile, browserSyncReload));}function markup_watch() {    series(clean_dist, parallel(optimize_others, process_html, make_indexfile), sprites, sass, copy_image, server, () =&gt; {    })();}exports.default = markup_watch;function process_html_in_build() {    return src([        `${gulpConfig.src}/html/**/*.html`,        `!${gulpConfig.src}/html/include/**/*.html`,    ])        .pipe($.fileInclude(fileIncludeConfig))        .pipe($.jsbeautifier({            config: '.jsbeautifyrc',            mode: 'VERIFY_AND_WRITE'        }))        .pipe($.if('*.js', $.uglify()))        .pipe($.if('*.css', $.cleanCss()))        .pipe(dest(`${gulpConfig.dist}/html`))}function accessibility_test() {  return src(`${gulpConfig.dist}/html/**/*`)    .pipe($.accessibility({      Accessibilityrc: '.accessibilityrc'    }))    .on('error', console.log)    .pipe($.accessibility.report({      reportType: 'txt'    }))    .pipe($.rename({      extname: '.txt'    }))    .pipe(dest('reports/txt'))}function zip() {    let date = new Date()    let dateFormatted = `${date.getFullYear()}${('0' + (date.getMonth() + 1)).slice(-2)}${('0' + date.getDate()).slice(-2)}T${('0' + date.getHours()).slice(-2)}${('0' + date.getMinutes()).slice(-2)}`    return src([        `${gulpConfig.dist}/**/*`,        `!${gulpConfig.dist}/**/*.zip`    ])        .pipe($.zip(`${packageJson.name}_${packageJson.version}_${dateFormatted}.zip`))        .pipe(dest(gulpConfig.dist))}/** * build: watch for style auto-compile * @example gulp build */function markup_build(done) {  series(clean_dist, parallel(optimize_png, optimize_others, process_html_in_build, make_indexfile), sprites, sass, copy_image, accessibility_test, zip, (done) =&gt; {    console.log('\\x1b[32m%s\\x1b[0m', '[--:--:--] Build complete...')    done()  })()  done()}exports.build = markup_build;function source_deploy() {    return src(`${gulpConfig.dist}/**/*`)        .pipe($.ghPages({            message: gulpConfig.deployMessage        }))}/** * deploy: watch for style auto-compile * @example gulp build */function markup_deploy(done) {    series(clean_dist, parallel(optimize_png, optimize_others, process_html_in_build, make_indexfile), sprites, sass, copy_image, accessibility_test, zip, source_deploy, (done) =&gt; {        console.log('\\x1b[32m%s\\x1b[0m', '[--:--:--] Build &amp; Deploy complete...');        done()    })()    done()}exports.deploy = markup_deploy;.accessibilityrc{  \"accessibilityLevel\": \"WCAG2A\",  \"ignore\": [    \"WCAG2A.Principle2.Guideline2_4.2_4_2.H25.1.NoTitleEl\",    \"WCAG2A.Principle3.Guideline3_1.3_1_1.H57.2\"  ],  \"reportLevels\": {    \"notice\": false,    \"warning\": true,    \"error\": true  },  \"force\": true,  \"verbose\": false}package.json{  \"name\": \"\",  \"version\": \"\",  \"description\": \"\",  \"repository\": {    \"type\": \"git\",    \"url\": \"\"  },  \"bugs\": {    \"url\": \"\"  },  \"private\": true,  \"engines\": {    \"node\": \"^10.16.3\",    \"npm\": \"^6.10.3\"  },  \"dependencies\": {},  \"devDependencies\": {    \"git-repo-info\": \"^2.1.1\",    \"browser-sync\": \"^2.26.7\",    \"cheerio\": \"^1.0.0-rc.3\",    \"del\": \"^5.0.0\",    \"gulp\": \"^4.0.2\",    \"gulp-accessibility\": \"^3.1.1\",    \"gulp-autoprefixer\": \"^7.0.0\",    \"gulp-base64-inline\": \"^1.0.4\",    \"gulp-clean-css\": \"^4.2.0\",    \"gulp-ejs\": \"^4.1.1\",    \"gulp-file-include\": \"^2.1.0\",    \"gulp-gh-pages\": \"^0.5.4\",    \"gulp-htmlmin\": \"^5.0.1\",    \"gulp-if\": \"^3.0.0\",    \"gulp-imagemin\": \"^6.0.0\",    \"gulp-jsbeautifier\": \"^3.0.1\",    \"gulp-load-plugins\": \"^2.0.1\",    \"gulp-pngquant\": \"^1.0.12\",    \"gulp-rename\": \"^1.4.0\",    \"gulp-replace\": \"^1.0.0\",    \"gulp-sass\": \"^4.0.1\",    \"gulp-sass-glob\": \"^1.1.0\",    \"gulp-sort\": \"^2.0.0\",    \"gulp-svg-sprite\": \"^1.5.0\",    \"gulp-uglify\": \"^3.0.0\",    \"gulp-zip\": \"^5.0.0\",    \"gulp.spritesmith-multi\": \"^3.1.0\",    \"merge-stream\": \"^2.0.0\",    \"path\": \"^0.12.7\",    \"run-sequence\": \"^2.2.1\",    \"util\": \"^0.12.1\",    \"vinyl-buffer\": \"^1.0.1\"  },  \"license\": \"ISC\"}"
}, 

{
"id": "-issue-2020-05-12-issue12",
"title": "cdn 다운안될 경우를 대비",
"author": null,
"tags": [],
"url": "/issue/2020/05/12/issue12/",
"date": "2020-05-12",
"content": "https://heeestorys.tistory.com/737\t&lt;script src=\"https://ghpages-fin.line-dev.me/markup-libs/js/jquery-3.4.1.min.js\"&gt;&lt;/script&gt;  &lt;script src=\"https://ghpages-fin.line-dev.me/markup-libs/js/swiper-4.4.6.min.js\"&gt;&lt;/script&gt;  &lt;script src=\"https://ghpages-fin.line-dev.me/markup-libs/js/lottie-5.5.9.min.js\"&gt;&lt;/script&gt;  &lt;script&gt;    window.jQuery || document.write(      \"&lt;script src=\\\"https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js\\\"&gt;&lt;\\/script&gt;\" +      \"&lt;script src=\\\"https://unpkg.com/swiper/js/swiper.min.js\\\"&gt;&lt;\\/script&gt;\" +      \"&lt;script src=\\\"https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.5.9/lottie.min.js\\\"&gt;&lt;\\/script&gt;\"    )  &lt;/script&gt;모바일이 문제..PC는 그래도 빨리 끊기고 아래 경로로 다운받는데.."
}, 

{
"id": "-issue-2020-05-12-issue11",
"title": "제이쿼리 객체와 자바스크립트 객체는 다르다",
"author": null,
"tags": [],
"url": "/issue/2020/05/12/issue11/",
"date": "2020-05-12",
"content": "자바스크립트 객체와 제이쿼리 객체는 다릅니다.function (e) {\te.target; // 자바스크립트 객체\t$(e.target); // 제이쿼리 객체화}"
}, 

{
"id": "-2020-05-12-git-git-log-stat",
"title": "git 수정된 파일 목록 가져오기 git log --stat",
"author": null,
"tags": [],
"url": "/2020/05/12/git-git-log-stat/",
"date": "2020-05-12",
"content": ""
}, 

{
"id": "-javascript-2020-05-10-javascript159",
"title": "9.4 요약",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript159/",
"date": "2020-05-10",
"content": "객체지향 프로그래밍은 대단히 널리 쓰이는 패러다임이며, 그럴 만한 이유가 있습니다.객체지향 프로그래밍을 사용하다 보면 자연스레 관리하고, 디버그하고, 수정하기 쉬운 정리되고 캡슐화된 코드를 작성하게 됩니다.자바스크립트의 OOP 구현은 비판을 자주 받는 편이고, 개중에는 객체지향 언어의 기준조차 만족하지 못한다고 혹평하는 사람도 있습니다(이런 혹평은 보통 데이터 접근 제어가 불가능하다는 점에 집중됩니다).그런 주장에 틀렸다고 할 수는 없지만, 일단 익숙해지면 자바스크립트의 OOP는 사실 매우 유연하고 강력합니다.다른 객체지향 언어에서는 하기 어려운 일도 할 수 있습니다."
}, 

{
"id": "-javascript-2020-05-10-javascript158",
"title": "9.3 다중 상속, 믹스인, 인터페이스",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript158/",
"date": "2020-05-10",
"content": "다중 상속일부 객체지향 언어에서는 다중 상속(multiple inheritance) 이란 기능을 지원합니다.이 기능은 클래스가 슈퍼클래스 두 개를 가지는 기능이며,슈퍼클래스의 슈퍼클래스가 존재하는 일반적인 상속과는 다릅니다.다중 상속에는 충돌의 위험이 있습니다.예를 들어 어떤 클래스에 두 개의 슈퍼 클래스가 있고, 두 슈퍼클래스에 모두 greet 메서드가 있다면 서브클래스는 어느 쪽의 메서드를 상속해야 할까요?다중 상속을 지원하지 않는 언어가 많은 이유는 이런 문제를 피하기 위해서입니다.하지만 현실 세계를 생각해 보면 다중 상속을 적용할 수 있는 문제가 많습니다.예를 들어 자동차는 운송 수단인 동시에 ‘보험을 들 수 있는’ 대상입니다.주택에도 보험을 들 수 있지만, 주택은 운송 수단이 아닙니다.인터페이스다중 상속을 지원하지 않는 언어 중에는 인터페이스(interface) 개념을 도입해서 이런 상황에 대처하는 언어가 많습니다.Car 클래스의 슈퍼클래스는 Vehicle 하나뿐이지만, Insurable, Container 등 여러 인터페이스를 가질 수 있습니다.자바스크립트는 흥미로운 방식으로 이들을 절충했습니다.자바스크립트는 프로토타입 체인에서 여러 부모를 검색하지는 않으므로 단일 상속 언어라고 해야 하지만, 어떤 면에서는 다중 상속이나 인터페이스보다 더 나은 방법을 제공합니다(물론 더 못할 때도 있습니다).믹스인자바스크립트가 다중 상속이 필요한 문제에 대한 해답으로 내놓은 개념이 믹스인(mixin) 입니다.믹스인이란 기능을 필요한 만큼 섞어 놓은 것입니다.자바스크립트는 느슨한 타입을 사용하고 대단히 관대한 언어이므로 그 어떤 기능이라도 언제든, 어떤 객체에든 추가할 수 있습니다.그러면 자동차에 적용할 수 있는 보험 가입(insurable) 믹스인을 만듭시다.이 믹스인은 단순하게 만들 겁니다.보험 가입 믹스인 외에도 InsurancePolicy 클래스를 만듭니다.보험 가입 믹스인에는 addInsurancePolicy, getInsurancePolicy 메서드가 필요하며, 편의를 위해 isInsured 메서드도 추가하겠습니다.예제를 봅시다.class InsurancePolicy {}function makeInsurable(o) {\to.addInsurancePolicy = function(p) { this.insurancePolicy = p; }\to.getInsurancePolicy = function() { return this.insurancePolicy; }\to.isInsured = function() { return !!this.insurancePolicy; }}이제 우리는 어떤 객체든 보험에 가입할 수 있습니다.그러면 Car로 돌아와서, 무엇을 보험에 가입해야 할까요?가장 먼저 드는 생각은 이런 것이겠지요.makeInsurable(Car);하지만 그렇게는 되지 않습니다.const car1 = new Car();car1.addInsurancePolicy(new InsurancePolicy()); // error“addInsurancePolicy가 프로토타입 체인에 존재하지 않으니 당연하지” 라고 생각했다면, 애석하지만 틀린 답입니다.그렇게 해도 Car를 보험에 가입할 수는 없습니다.상식적이지도 않습니다.자동차를 추상화한 개념을 보험에 가입할 수는 없죠.보험에 가입하는 것은 개별 자동차입니다.그러니 이렇게 해봅시다.const Car = (function() {\t\tconst carProps = new WeakMap();\t\tclass Car {\t\tstatic getNextVin() {\t\t\treturn Car.nextVin++; // this.nextVin++ 라고 써도 되지만,\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Car를 앞에 쓰면 정적 메서드라는 점을\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 상기하기 쉽습니다.\t\t}\t\tconstructor(make, model) {\t\t\tthis.make = make;\t\t\tthis.model = model;\t\t\tthis.vin = Car.getNextVin();\t\t}\t\tstatic areSimilar(car1, car2) {\t\t\treturn car1.make === car2.make &amp;&amp; car.model === car2.model;\t\t}\t\tstatic areSame(car1, car2) {\t\t\treturn car1.vin === car2.vin;\t\t}\t\ttoString () {\t\t\treturn `${this.make} ${this.model} : ${this.vin}`\t\t}\t}\t\treturn Car;})();Car.nextVin = 0;const car1 = new Car();makeInsurable(car1);car1.addInsurancePolicy(new InsurancePolicy()); // works이 방법은 동작하지만, 모든 자동차에서 makeInsurable 을 호출해야 합니다.Car 생성자에 추가할 수도 있지만, 그렇게 하면 이 기능을 모든 자동차에 복사하는 형국이 됩니다.다행히 해결책은 쉬운 편입니다.makeInsurable(Car.prototype);const car1 = new Car();car1.addInsurancePolicy(new InsurancePolicy()); // works이제 보험 관련 메서드들은 모두 Car 클래스에 정의된 것처럼 동작합니다.자바스크립트의 관점에서는 실제로 그렇습니다.개발자의 관점에서는 중요한 두 클래스를 관리하기 쉽게 만들었습니다.자동차 회사에서 Car 클래스의 개발과 관리를 담당하고, 보험 회사에서 InsurancePolicy 클래스와 makeInsurable 믹스인을 관리하게 됩니다.두 회사의 업무가 충돌할 가능성을 완전히 없앤 건 아니지만, 모두가 거대한 Car 클래스에 달라붙어 일하는 것보다는 낫습니다.물론 믹스인이 모든 문제를 해결해 주지는 않습니다.보험 회사에서 shift 메서드를 만들게 된다면 Car 클래스의 동작이 이상해질 겁니다.충돌instanceof 연산자로 보험에 가입할 수 있는 객체를 식별할 수도 없습니다.‘addInsurancePolicy 메서드가 있다면 틀림없이 보험에 가입할 수 있다’는 식의 짐작만 가능할 뿐입니다.심볼을 사용하면 이런 문제 일부를 경감할 수 있습니다.보험 회사에서 매우 범용적인 메서드 이름을 계속 사용해서, 우연히 Car 클래스의 메서드와 충돌할까 봐 걱정된다고 가정합시다.그러면 보험 회사에 키를 모두 심볼로 사용해 달라고 요청할 수 있습니다.보험사가 제공하는 믹스인은 다음과 같은 형태가 될 겁니다.class InsurancePolicy {}const ADD_POLICY = Symbol();const GET_POLICY = Symbol();const IS_INSURED = Symbol();const _POLICY = Symbol();function makeInsurable(o) {\to[ADD_POLICY] = function(p) { this[_POLICY] = p; }\to[GET_POLICY] = function() { return this[_POLICY]; }\to[IS_INSURED] = function() { return !!this[_POLICY]; }}심볼은 항상 고유하므로 믹스인이 Car 클래스의 기능과 충돌할 가능성은 없습니다.쓰기가 조금 번거로울 수는 있겠지만, 훨씬 안전합니다.메서드 이름에는 일반적인 문자열을 쓰고 데이터 프로퍼티에는 _POLICY 같은 심볼을 쓰는 절충안을 생각할 수도 있습니다."
}, 

{
"id": "-javascript-2020-05-10-javascript157",
"title": "9.2.8 문자열 표현",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript157/",
"date": "2020-05-10",
"content": "모든 객체는 Object를 상속하므로 Object의 메서드는 기본적으로 모든 객체에서 사용할 수 있습니다.객체의 기본적인 문자열 표현을 제공하는 toString 도 그런 메서드 중 하나입니다.toString의 기본 동작은 “[object Object]”를 반환하는 것인데, 이건 거의 쓸모가 없습니다.toString 메서드에서 객체에 관한 중요한 정보를 제공한다면 디버깅에도 유용하고, 객체를 한 눈에 파악할 수 있습니다.Car 클래스의 toString 메서드가 제조사, 모델, VIN을 반환하도록 고쳐봅시다.const Car = (function() {\t\tconst carProps = new WeakMap();\t\tclass Car {\t\tstatic getNextVin() {\t\t\treturn Car.nextVin++; // this.nextVin++ 라고 써도 되지만,\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Car를 앞에 쓰면 정적 메서드라는 점을\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 상기하기 쉽습니다.\t\t}\t\tconstructor(make, model) {\t\t\tthis.make = make;\t\t\tthis.model = model;\t\t\tthis.vin = Car.getNextVin();\t\t}\t\tstatic areSimilar(car1, car2) {\t\t\treturn car1.make === car2.make &amp;&amp; car.model === car2.model;\t\t}\t\tstatic areSame(car1, car2) {\t\t\treturn car1.vin === car2.vin;\t\t}\t\ttoString () {\t\t\treturn `${this.make} ${this.model} : ${this.vin}`\t\t}\t}\t\treturn Car;})();Car.nextVin = 0;const car1 = new Car(\"Tesla\", \"S\");const car2 = new Car(\"Hyundai\", \"K5\");이제 Car의 인스턴스에서 toString을 호출하면 객체 식별에 필요한 정보를 얻을 수 있습니다."
}, 

{
"id": "-javascript-2020-05-10-javascript156",
"title": "9.2.7 객체 프로퍼티 나열 다시 보기",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript156/",
"date": "2020-05-10",
"content": "for … in 문으로 객체의 프로퍼티를 나열하는 방법은 이미 봤습니다.이제 프로토타입 상속에 대해 알게 됐으니 객체의 프로퍼티를 나열할 때 hasOwnProperty 가 어떤 의미가 있는지 완전히 이해할 수 있습니다.객체 obj와 프로퍼티 x에서, obj.hasOwnProperty(x) 는 obj에 프로퍼티 x가 있다면 true를 반환하며, 프로퍼티 x가 obj에 정의되지 않았거나 프로토타입 체인에만 정의되어있다면 false를 반환합니다.ES6 클래스를 설계 의도대로 사용한다면 데이터 프로퍼티는 항상 프로토타입 체인이 아니라 인스턴스에 정의해야 합니다.하지만 프로퍼티를 프로토타입에 정의하지 못하도록 강제하는 장치는 없으므로 확실히 확인하려면 항상 hasOwnProperty를 사용하는 편이 좋습니다.예제를 보십시오.class Super {\tconstructor () {\t\tthis.name = \"Super\";\t\tthis.isSuper = true;\t}}// 유효하지만, 권장하지는 않습니다.Super.prototype.sneaky = 'not recommended';class Sub extends Super {\tconstructor() {\t\tsuper();\t\tthis.name = 'Sub';\t\tthis.isSub = true;\t}}const obj = new Sub();for (let p in obj) {\tconsole.log(`${p}: ${obj[p]}` + (obj.hasOwnProperty(p) ? '' : ' (inherited)'));}이 프로그램을 실행한 결과는 다음과 같습니다.name: SubisSuper: trueisSub: truesneaky: not recommended! (inherited)name, isSuper, isSub 프로퍼티는 모두 프로토타입 체인이 아니라 인스턴스에 정의됏습니다(슈퍼클래스 생성자에서 선언한 프로퍼티는 서브클래스 인스턴스에도 정의됩니다).반면 sneaky 프로퍼티는 슈퍼클래스의 프로토타입에 직접 정의했습니다.Object.keys를 사용하면 프로토타입 체인에 정의된 프로퍼티를 나열하는 문제를 피할 수 있습니다.왜냐면 Object.keys는 상속안된 프로퍼티 중 문자열로 표현할 수 있는 것만 나열하므로..(맞나?)"
}, 

{
"id": "-javascript-2020-05-10-javascript155",
"title": "9.2.6 다형성",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript155/",
"date": "2020-05-10",
"content": "좀 어려워 보이는 다형성(polymorphism) 이란 단어는 객체지향 언어에서 여러 슈퍼클래스의 멤버인 인스턴스를 가리키는 말입니다.대부분의 객체지향 언어에서 다형성은 특별한 경우에 속합니다.자바스크립트는 느슨한 타입을 사용하고 어디서든 객체를 쓸 수 있으므로(정확한 결과가 보장되진 않지만), 어떤 면에서는 자바스크립트의 객체는 모두 다형성을 갖고 있다고 할 수 있습니다.자바스크립트 코드를 작성하다 보면 ‘이런 메서드가 있고 저런 메서드가 있으니 아마 그 클래스의 인스턴스일 것이다’ 처럼 집작할 때가 많습니다.Car 예제에 적용해 본다면,class Vehicle {\tconstructor() {\t\tthis.passengers = [];\t\tconsole.log(\"Vehicle created\");\t}\taddPassenger(p) {\t\tthis.passengers.push(p);\t}}class Car extends Vehicle {\tconstructor() {\t\tsuper();\t\tconsole.log(\"Car created\");\t}\tdeployAirbags() {\t\tconsole.log(\"BWOOSH!\");\t}}const v = new Vehicle();v.addPassenger(\"Frank\");v.addPassenger(\"Judy\");v.passengers; // [\"Frank\", \"Judy\"]const c = new Car();c.addPassenger(\"Alice\");c.addPassenger(\"Cameron\");c.passengers; // [\"Alice\", \"Cameron\"]v.deployAirbags(); // errorc.deployAirbags(); // \"BWOOSH!\"deployAirbags 메서드가 있는 객체는 Car의 인스턴스라고 생각할 수 있습니다.물론 아닐 수도 있지만, 그 같은 집작이 근거 없는 추측은 절대 아닙니다.자바스크립트에는 객체가 클래스의 인스턴스인지 확인하는 instanceof 연산자가 있습니다.이 연산자를 속일 수도 있지만, prototype과 __proto__ 프로퍼티에 손대지 않았다면 정확한 결과를 기대할 수 있습니다.class Vehicle {\tconstructor() {\t\tthis.passengers = [];\t\tconsole.log(\"Vehicle created\");\t}\taddPassenger(p) {\t\tthis.passengers.push(p);\t}}class Car extends Vehicle {\tconstructor() {\t\tsuper();\t\tconsole.log(\"Car created\");\t}\tdeployAirbags() {\t\tconsole.log(\"BWOOSH!\");\t}}class Motorcycle extends Vehicle {}const c = new Car();const m = new Motorcycle();c instanceof Car; // truec instanceof Vehicle; // truem instanceof Car; // falsem instanceof Motorcycle; // truem instanceof Vehicle; // true  NOTE_자바스크립트의 모든 객체는 루트 클래스인 Object의 인스턴스입니다.즉, 객체 o에서 o instanceof Object는 항상 true입니다(__proto__ 프로퍼티를 수정한다면 다른 결과가 나올 수 있지만, 그렇게 해서는 안됩니다).모든 객체가 Object의 인스턴스인 것은 toString 같은 중요한 메서드를 상속하기 위해서이며, 염두에 둘 만큼 중요한 영향은 없습니다."
}, 

{
"id": "-javascript-2020-05-10-javascript154",
"title": "9.2.5 상속",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript154/",
"date": "2020-05-10",
"content": "프로토타입을 이해하면서 우리는 이미 상속의 일면을 봤습니다.클래스의 인스턴스는 클래스의 기능을 모두 상속합니다.상속은 한 단계로 끝나지 않습니다.객체의 프로토타입에서 메서드를 찾지 못하면 자바스크립트는 프로토타입의 프로토타입을 검색합니다.프로토타입 체인 은 이런 식으로 만들어집니다.자바스크립트는 조건에 맞는 프로토타입을 찾을 때까지 프로토타입 체인을 계속 거슬러 올라갑니다.조건에 맞는 프로토타입을 찾지 못하면 에러를 일으킵니다.클래스의 계층 구조를 만들 때 프로토타입 체인을 염두에 두면 효율적인 구조를 만들 수 있습니다.즉, 프로토타입 체인에서 가장 적절한 위치에 메서드를 정의하는 겁니다.자동차는 운송 수단의 읠종입니다.예를 들어 자동차에는 deployAirbags 이란 메서드가 있을 수 있습니다.이 메서드를 운송 수단 클래스에 정의할 수도 있겠지만, 에어백이 달린 보트는 본 적이 없겠죠?반면 운송 수단은 대부분 승객을 태울 수 있으므로, addPassenger 메서드는 운송 수단 클래스에 적당합니다.이런 시나리오를 자바스크립트로 만들어 봅시다.class Vehicle {\tconstructor() {\t\tthis.passengers = [];\t\tconsole.log(\"Vehicle created\");\t}\taddPassenger(p) {\t\tthis.passengers.push(p);\t}}class Car extends Vehicle {\tconstructor() {\t\tsuper();\t\tconsole.log(\"Car created\");\t}\tdeployAirbags() {\t\tconsole.log(\"BWOOSH!\");\t}}처음 보는 키워드가 눈에 띕니다.extends 키워드는 Car를 Vehicle의 서브클래스로 만듭니다.super() 도 처음 보는 것입니다.super() 는 슈퍼클래스의 생성자를 호출하는 특별한 함수입니다.서브클래스에서는 이 함수를 반드시 호출해야 합니다.호출하지 않으면 에러가 일어납니다.예제를 봅시다.class Vehicle {\tconstructor() {\t\tthis.passengers = [];\t\tconsole.log(\"Vehicle created\");\t}\taddPassenger(p) {\t\tthis.passengers.push(p);\t}}class Car extends Vehicle {\tconstructor() {\t\tsuper();\t\tconsole.log(\"Car created\");\t}\tdeployAirbags() {\t\tconsole.log(\"BWOOSH!\");\t}}const v = new Vehicle();v.addPassenger(\"Frank\");v.addPassenger(\"Judy\");v.passengers; // [\"Frank\", \"Judy\"]const c = new Car();c.addPassenger(\"Alice\");c.addPassenger(\"Cameron\");c.passengers; // [\"Alice\", \"Cameron\"]v.deployAirbags(); // errorc.deployAirbags(); // \"BWOOSH!\"c에서는 deployAirbags를 호출할 수 있지만, v에서는 불가능합니다.달리 말하면, 상속은 (당연히) 단방향입니다.Car 클래스의 인스턴스는 Vehicle 클래스의 모든 메서드에 접근할 수 있지만, 반대는 불가능합니다."
}, 

{
"id": "-issue-2020-05-10-issue10",
"title": "ES6 버튼 클릭기능 구현하기",
"author": null,
"tags": [],
"url": "/issue/2020/05/10/issue10/",
"date": "2020-05-10",
"content": "똑같은 기능을 하지만 서로 다른 소스 두 가지let caseButton = document.querySelectorAll('.case_view a'),    error = document.querySelectorAll('.error');let caseViewFunc = (_index) =&gt; {    return tabClickEevent = (e) =&gt; {        e.preventDefault();        for(j = 0; j &lt; error.length; j++) {            _index == j ? error[_index].style.display = null : error[j].style.display = 'none';        }    }}for (i = 0; i &lt; caseButton.length; i++) {    caseButton[i].onclick = caseViewFunc(i);}let btn = document.querySelectorAll('.case_view a'),    txt = document.querySelectorAll('.error');btn = Array.prototype.slice.call(btn);txt = Array.prototype.slice.call(txt);btn.map((x, i) =&gt; {    x.addEventListener('click', function () {        if (txt[i].style.display === 'none') {            txt[i].style.display = 'block';        } else {            txt[i].style.display = 'none';        }    })})"
}, 

{
"id": "-javascript-2020-05-10-javascript153",
"title": "9.2.4 정적 메서드",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript153/",
"date": "2020-05-10",
"content": "지금까지 우리는 인스턴스 메서드, 즉 인스턴스에서 사용하게끔 만든 메서드를 주로 살펴봤습니다.메서드에는 인스턴스 메서드 외에도 정적 메서드(클래스 메서드) 가 있습니다.이 메서드는 특정 인스턴스에 적용되지 않습니다.정적 메서드에서 this는 인스턴스가 아니라 클래스 자체에 묶입니다.하지만 일반적으로 정적 메서드에는 this 대신 클래스 이름을 사용하는 것이 좋은 습관입니다.정적 메서드는 클래스에 관련되지만 인스턴스와는 관련이 없는 범용적인 작업에 사용됩니다.예제로 자동차 식별 번호(VIN)을 붙이는 메서드를 생각해 봅시다.개별 자동차가 자신만의 VIN을 생성한다는 것은 불가능합니다.다른 자동차에 같은 VIN이 이미 부여됐는지 자동차가 어떻게 알겠습니까?VIN을 할당한다는 것은 자동차 전체를 대상으로 하는 추상적인 개념이므로 정적 메서드로 사용하는 게 어울립니다.정적 메서드는 여러 인스턴스를 대상으로 하는 작업에도 종종 쓰입니다.예를 들어 두 자동차의 제조사와 모델이 모두 같으면 true를 반환하는 areSimilar 메서드, 두 자동차의 VIN이 같으면 true를 반환하는 areSame 메서드를 만들어 봅시다.class Car {\tstatic getNextVin() {\t\treturn Car.nextVin++; // this.nextVin++ 라고 써도 되지만,\t\t                      // Car를 앞에 쓰면 정적 메서드라는 점을\t\t\t\t\t\t\t\t\t\t\t\t\t// 상기하기 쉽습니다.\t}\t\tconstructor(make, model) {\t\tthis.make = make;\t\tthis.model = model;\t\tthis.vin = Car.getNextVin();\t}\t\tstatic areSimilar(car1, car2) {\t\treturn car1.make === car2.make &amp;&amp; car.model === car2.model;\t}\tstatic areSame(car1, car2) {\t\treturn car1.vin === car2.vin;\t}}Car.nextVin = 0;const car1 = new Car(\"Tesla\", \"S\");const car2 = new Car(\"Mazda\", \"3\");const car3 = new Car(\"Mazda\", \"3\");car1.vin; // 0car2.vin; // 1car3.vin; // 2Car.areSimilar(car1, car2); // falseCar.areSimilar(car2, car3); // trueCar.areSame(car2, car3); // falseCar.areSame(car2, car2); // true"
}, 

{
"id": "-javascript-2020-05-10-javascript152",
"title": "9.2.3 프로토타입",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript152/",
"date": "2020-05-10",
"content": "클래스의 인스턴스에서 사용할 수 있는 메서드라고 하면 그건 프로토타입(prototype) 메서드를 말하는 겁니다.예를 들어 Car의 인스턴스에서 사용할 수 있는 shift 메서드는 프로토타입 메서드입니다.프로토타입 메서드는 Car.prototype.shift 처럼 표기할 때가 많습니다.Array의 forEach를 Array.prototype.forEach 라고 쓰는 것과 마찬가지로 말입니다.이제 프로토타입이 무엇인지, 자바스크립트가 프로토타입체인을 통해 어떻게 동적 디스패치(dynamic dispatch) 를 구현하는지 알아봅시다.  NOTE_최근에는 프로토타입 메서드를 #으로 표시하는 표기법이 널리 쓰입니다.예를 들어 Car.prototype.shift를 Car#shift 로 쓰는 겁니다.모든 함수에는 prototype이라는 특별한 프로퍼티가 있습니다.일반적인 함수에서는 프로토타입을 사용할 일이 없지만, 객체 생성자로 동작하는 함수에서는 프로토타입이 대단히 중요합니다.  NOTE_객체 생성자. 즉 클래스는 Car 처럼 항상 첫 글자를 대문자로 표기합니다.자바스크립트에서 이런 표기법을 요구하는 것은 아니지만, 일반적인 함수 이름이 대문자로 시작하거나 객체 생성자가 소문자로 시작한다면 이를 경고하는 린트 프로그램이 많습니다.함수의 prototype 프로퍼티가 중요해지는 시점은 new 키워드로 새 인스턴스를 만들었을 때입니다.new 키워드로 만든 새 객체는 생성자의 prototype 프로퍼티에 접근할 수 있습니다.객체 인스턴스는 생성자의 prototype 프로퍼티를 __proto__ 프로퍼티에 저장합니다.  CAUTION___proto__ 프로퍼티는 자바스크립트의 내부 동작 방식에 영향을 미칩니다.밑줄 두 개로 둘러싼 프로퍼티는 모두 그렇습니다.이런 프로퍼티를 수정하는 것은 정말로 위험합니다.이들을 적절하고 현명하게 사용할 수 있는 경우가 전혀 없는 건 아니지만, 자바스크립트를 충분히 이해하기 전에는 이들 프로퍼티를 살펴보기만 하고 손대지는 말길 권합니다.동적 디스패치프로토타입에서 중요한 것은 동적 디스패치라는 매커니즘입니다.여기서 디스패치는 메서드 호출과 같은 의미입니다.객체의 프로퍼티나 메서드에 접근하려 할 때 그런 프로퍼티나 메서드가 존재하지 않으면 자바스크립트는 객체의 프로토타입에서 해당 프로퍼티나 메서드를 찾습니다.클래스의 인스턴스는 모두 같은 프로토타입을 공유하므로 프로토타입에 프로퍼티나 메서드가 있다면 해당 클래스의 인스턴스는 모두 그 프로퍼티나 메서드에 접근할 수 있습니다.  TIP클래스의 프로토타입에서 데이터 프로퍼티를 수정하는 것은 일반적으로 권장하지 않습니다.모든 인스턴스가 그 프로퍼티의 값을 공유하기는 하지만, 인스턴스 중 하나에 그런 이름의 프로퍼티가 있다면 해당 인스턴스는 프로토타입에 있는 값이 아니라 인스턴스에 있는 값을 사용합니다.이는 혼란과 버그를 초래할 수 있습니다.인스턴스에 초깃값이 필요하다면 생성자에서 만드는 편이 낫습니다.인스턴스에서 메서드나 프로퍼티를 정의하면 프로토타입에 있는 것을 가리는 효과가 있습니다.자바스크립트는 먼저 인스턴스를 체크하고 거기에 없으면 프로토타입을 체크하기 때문입니다.예제를 봅시다.const Car = (function() {\t\tconst carProps = new WeakMap();\t\tclass Car {\t\tconstructor (make, model) {\t\t\tthis.make = make;\t\t\tthis.model = model;\t\t\tthis._userGears = ['P', 'N', 'R', 'D'];\t\t\tcarProps.set(this, { userGear: this._userGears[0] });\t\t}\t\t\t\tget userGear() { return carProps.get(this).userGear; }\t\tset userGear(value) {\t\t\tif(this._userGears.indexOf(value) &lt; 0)\t\t\t\tthrow new Error(`Invalid gear: ${value}`);\t\t\tcarProps.get(this).userGear = value;\t\t}\t\t\t\tshift(gear) { this.userGear = gear; }\t}\t\treturn Car;})();const car1 = new Car();const car2 = new Car();car1.shift === Car.prototype.shift; // truecar1.shift('D');car1.shift('d'); // errorcar1.userGear; // 'D'car1.shift === car2.shift // truecar1.shift = function (gear) { this.userGear = gear.toUpperCase(); }car1.shift === Car.prototype.shift; // falsecar1.shift === car2.shift; // falsecar1.shift('d');car1.userGear; // 'D'이 예제는 자바스크립트에서 동적 디스패치를 어떻게 구현하는지 잘 보여줍니다.car1 객체에는 shift 메서드가 없지만, car1.shift(‘D’) 를 호출하면 car1의 프로토타입에서 그런 이름의 메서드를 검색합니다.car1에 shift 메서드를 추가하면 car1과 프로토타입에 같은 이름의 메서드가 존재하게 됩니다.이제 car1.shift(‘d’)를 호출하면 car1의 메서드가 호출되고 프로토타입의 메서드는 호출되지 않습니다.프로토타입 체인과 동적 디스패치를 항상 숙지하고 있을 필요는 없지만, 가끔 문제가 발생할 때 세부사항을 알고 있으면 도움이 됩니다."
}, 

{
"id": "-javascript-2020-05-10-javascript151",
"title": "9.2.2 클래스는 함수다",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript151/",
"date": "2020-05-10",
"content": "ES6에서 class 키워드를 도입하기 전까지, 클래스를 만든다는 것은 곧 클래스 생성자로 사용할 함수를 만든다는 의미였습니다.class 문법이 훨씬 더 직관적이고 단순하긴 하지만, 사실 class는 단축 문법일 뿐이며 자바스크립트의 클래스 자체가 바뀐 것은 아닙니다.따라서 자바스크립트의 클래스 자체를 이해하는 것이 중요합니다.클래스는 사실 함수일 뿐입니다.ES5에서는 Car 클래스를 다음과 같이 만들었을 겁니다.function Car(make, model) {\tthis.make = make;\tthis.model = model;\tthis._userGears = ['P', 'N', 'R', 'D'];\tthis._userGear = this.userGears[0];}ES6에서도 똑같이 할 수 있습니다.결과는 완전히 동일합니다.다음 예제를 보십시오.function Es5Car(make, model) {\tthis.make = make;\tthis.model = model;\tthis._userGears = ['P', 'N', 'R', 'D'];\tthis._userGear = this.userGears[0];}class Es6Car {\tconstructor(make, model) {\t\tthis.make = make;\t\tthis.model = model;\t\tthis.userGears = ['P', 'N', 'R', 'D'];\t\tthis.userGear = this.userGears[0];\t}}typeof Es5Car // \"function\"typeof Es6Car // \"function\"ES6에서 클래스가 바뀐 것은 아닙니다.단지 간편한 새 문법이 생겼을 뿐입니다."
}, 

{
"id": "-javascript-2020-05-10-javascript150",
"title": "9.2.1 클래스와 인스턴스 생성",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript150/",
"date": "2020-05-10",
"content": "ES6 이전에 자바스크립트에서 클래스를 만드는 건 직관적이지도 않고 무척 번거로운 일이었습니다.ES6에서는 클래스를 만드는 간편한 새 문법을 도입했습니다.class Car {\tconstructor() {\t\t}}위 코드는 새 클래스 Car를 만듭니다.아직 인스턴스(특정 자동차)는 만들어지지 않았지만 언제든 만들 수 있습니다.인스턴스를 만들 때는 new 키워드를 사용합니다.class Car {\tconstructor() {\t\t}}const car1 = new Car();const car2 = new Car();이제 Car 클래스의 인스턴스가 두 개 생겼습니다.Car 클래스를 더 수정하기 전에, 객체가 클래스의 인스턴스인지 확인하는 instanceof 연산자에 대해 알아봅시다.class Car {\tconstructor() {\t\t}}const car1 = new Car();const car2 = new Car();car1 instanceof Car // truecar1 instanceof Array // false이 예제를 보면 car1은 Car의 인스턴스이고 Array의 인스턴스는 아님을 알 수 있습니다.Car 클래스를 조금 더 흥미롭게 만들어 봅시다.제조사(make)와 모델 데이터, 변속(shift) 기능을 추가할 겁니다.class Car {\tconstructor(make, model) {\t\tthis.make = make;\t\tthis.model = model;\t\tthis.userGears = ['P', 'N', 'R', 'D'];\t\tthis.userGear = this.userGears[0];\t}\tshift(gear) {\t\tif(this.userGears.indexOf(gear) &lt; 0)\t\t\tthrow new Error(`Invalid gear: ${gear}`);\t\tthis.userGear = gear;\t}}여기서 this 키워드는 의도한 목적, 즉 메서드를 호출한 인스턴스를 가리키는 목적으로 쓰였습니다.this를 일종의 플레이스홀더로 생각해도 좋습니다.클래스를 만들 때 사용한 this 키워드는 나중에 만들 인스턴스의 플레이스홀더입니다.메서드를 호출하는 시점에서 this가 무엇인지 알 수 있게 됩니다.이 생성자를 실행하면 인스턴스를 만들면서 자동차의 제조사와 모델을 지정할 수 있고, 몇 가지 기본값도 있습니다.userGears는 사용할 수 있는 기어 목록이고 gear는 현재 기어이며 사용할 수 있는 첫 번째 기어로 초기화됩니다.생성자 외에 shift 메서드도 만들었습니다.이 메서드는 기어 변속에 사용됩니다.이제 이 클래스를 실제로 사용해 봅시다.class Car {\tconstructor(make, model) {\t\tthis.make = make;\t\tthis.model = model;\t\tthis.userGears = ['P', 'N', 'R', 'D'];\t\tthis.userGear = this.userGears[0];\t}\tshift(gear) {\t\tif(this.userGears.indexOf(gear) &lt; 0)\t\t\tthrow new Error(`Invalid gear: ${gear}`);\t\tthis.userGear = gear;\t}}const car1 = new Car(\"Tesla\", \"Model S\");const car2 = new Car(\"Mazda\", \"3i\");car1.shift('D');car2.shift('R');이 예제에서 car1.shif(‘D’) 를 호출하면 this는 car1에 묶입니다.마찬가지로 car2.shift(‘R’) 를 호출하면 this는 car2에 묶입니다.다음과 같이 car1이 주행 중이고(D) car2가 후진 중임을(R) 확인할 수 있습니다.car1.userGear // \"D\"car2.userGear // \"R\"Car 클래스에 shift 메서드를 사용하면 잘못된 기어를 선택하는 실수를 방지할 수 있을 것처럼 보입니다.하지만 완벽하게 보호되는 건 아닙니다.직접 car1.userGear = ‘X’ 라고 설정한다면 막을 수 없습니다.대부분의 객체지향 언어에서는 메서드와 프로퍼티에 어느 수준까지 접근할 수 있는지 대단히 세밀하게 설정할 수 있는 메커니즘을 제공해서 car1.userGear = ‘X’ 같은 실수를 막을 수 있게 합니다.하지만 자바스크립트에는 그런 메커니즘이 없고, 이는 언어의 문제로 자주 비판을 받습니다.프로퍼티 직접 수정 방지Car 클래스를 다음과 같이 수정하면 실수로 기어 프로퍼티를 고치지 않도록 어느 정도 막을 수 있습니다.class Car {\tconstructor(make, model) {\t\tthis.make = make;\t\tthis.model = model;\t\tthis._userGears = ['P', 'N', 'R', 'D'];\t\tthis._userGear = this._userGears[0];\t}\t\tget userGear() { return this._userGear; }\tset userGear(value) {\t\tif (this._userGears.indexOf(value) &lt; 0)\t\t\tthrow new Error(`Invalid gear: ${value}`);\t\tthis._userGear = value;\t}\t\tshift(gear) {this.userGear = gear;}}예민한 독자라면 여전히 car1._userGear = ‘X’ 처럼 _userGear를 직접 바꿀 수 있다고 지적할 겁니다.이 예제에서는 외부에서 접근하면 안 되는 프로퍼티 이름 앞에 밑줄을 붙이는, 소위 ‘가짜 접근 제한’을 사용했습니다.진정한 제한이라기보다는 “아, 밑줄이 붙은 프로퍼티에 접근하려고 하네? 이건 실수로군.” 하면서 빨리 찾을 수 있도록 하는 방편이라고 봐야 합니다.프로퍼티를 꼭 보호해야 한다면 스코프를 이용해 보호하는 WeakMap 인스턴스(10장에서 설명합니다)를 사용할 수 있습니다.Car 클래스를 다음과 같이 고치면 기어 프로퍼티를 완벽하게 보호할 수 있습니다.const Car = (function() {\t\tconst carProps = new WeakMap();\t\tclass Car {\t\tconstructor (make, model) {\t\t\tthis.make = make;\t\t\tthis.model = model;\t\t\tthis._userGears = ['P', 'N', 'R', 'D'];\t\t\tcarProps.set(this, { userGear: this._userGears[0] });\t\t}\t\t\t\tget userGear() { return carProps.get(this).userGear; }\t\tset userGear(value) {\t\t\tif(this._userGears.indexOf(value) &lt; 0)\t\t\t\tthrow new Error(`Invalid gear: ${value}`);\t\t\tcarProps.get(this).userGear = value;\t\t}\t\t\t\tshift(gear) { this.userGear = gear; }\t}\t\treturn Car;})();여기서는 즉시 호출하는 함수 표현식을 써서 WeakMap을 클로저로 감싸고 바깥에서 접근할 수 없게 했습니다.WeakMap은 클래스 외부에서 접근하면 안 되는 프로퍼티를 안전하게 저장합니다.프로퍼티 이름에 심볼을 쓰는 방법도 있습니다.이렇게 해도 어느 정도는 보호할 수 있지만, 클래스에 들어 있는 심볼 프로퍼티 역시 접근이 불가능한 것은 아니므로 이 방법에도 한계가 있다고 해야 합니다."
}, 

{
"id": "-javascript-2020-05-10-javascript149",
"title": "9.2 객체지향 프로그래밍",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript149/",
"date": "2020-05-10",
"content": "객체지향 프로그래밍(OOP)은 컴퓨터 과학에서 전통적인 패러다임입니다.우리가 알고 있는 OOP의 개념 중 일부는 1950년대부터 있었지만, 시뮬러 67(Simula 67)과 스몰토크(Smalltalk)가 등장하면서 OOP의 형태가 갖춰지기 시작했습니다.OOP의 기본 아이디어는 단순하고 직관적입니다.객체는 데이터와 기능을 논리적으로 묶어 놓은 겁니다.OOP는 우리가 사물을 이해하는 자연스러운 방식을 반영하도록 설계됐습니다.만약 자동차가 객체라면 그 데이터에는 제조사, 모델, 도어 숫자, 차량번호 등이 있을 겁니다.그리고 그 기능으로는 가속, 변속, 문 열기, 헤드라이트 켜기 등이 있을 겁니다.또한, OOP는 사물에 관해 추상적으로(어떤 자동차), 구체적으로(특정 자동차) 생각할 수 있게 합니다.본격적으로 시작하기 전에 OOP의 기본 용어에 대해 알아봅시다.클래스는 어떤 자동차처럼 추상적이고 범용적인 것입니다.인스턴스 는 특정 자동차처럼 구체적이고 한정적인 것입니다.기능은 메서드라고 부릅니다.클래스 에 속하지만 특정 인스턴스 에 묶이지는 않는 기능을 클래스 메서드 라고 합니다.예를 들어 ‘시동을 거는’ 기능은 클래스 메서드 라 할 수 있습니다.인스턴스 를 처음 만들 때는 생성자(constructor) 가 실행됩니다.생성자는 객체 인스턴스를 초기화합니다.계층OOP는 클래스를 계층적으로 분류하는 수단도 제공합니다.예를 들어 자동차보다 더 범용적인 운송 수단(vehicle) 클래스가 있다고 합시다.운송 수단 클래스에는 자동차와 마찬가지로 급유나 충전 없이 이동할 수 있는 거리인 범위 프로퍼티가 있겠지만, 자동차와 달리 바퀴는 없을 수도 있습니다.예를 들어 보트는 바퀴가 없는 운송 수단입니다.이때 운송 수단을 자동차의 슈퍼 클래스(superclass) 라 부르고, 자동차를 운송 수단의 서브 클래스(subclass) 라 부릅니다.운송 수단 클래스에는 자동차, 보트, 비행기, 오토바이, 자전거 등 여러 가지 서브클래스가 있을 수 있습니다.서브클래스 역시 서브클래스를 가질 수 있습니다.예를 들어 보트 서브클래스에는 요트, 카누, 예인선, 모터보트 등의 서브클래스가 있을 수 있습니다.이 장에서는 편의상 쭉 자동차를 예제로 사용하겠습니다."
}, 

{
"id": "-javascript-2020-05-10-javascript148",
"title": "9.1.2 Object.keys",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript148/",
"date": "2020-05-10",
"content": "Object.keys 는 객체에서 나열 가능한 문자열 프로퍼티를 배열로 반환합니다.const SYM = Symbol();const o = { a: 1, b: 2, c: 3, [SYM]: 4 };Object.keys(o).forEach(prop =&gt; console.log(`${prop}: ${o[prop]}`));이 예제는 for … in 루프를 썼을 때와 같은 결과이고 hasOwnProperty 를 체크할 필요는 없습니다.객체의 프로퍼티 키를 배열로 가져와야 할 때는 Object.keys가 편리합니다.예를 들어 객체에서 x로 시작하는 프로퍼티를 모두 가져온다면 다음과 같이 할 수 있습니다.const o = { apple: 1, xochitl: 2, balloon: 3, guitar: 4, xylophone: 5, };Object.keys(o)\t.filter(prop =&gt; prop.match(/^x/))\t.forEach(prop =&gt; console.log(`${prop} : ${o[prop]}`));"
}, 

{
"id": "-javascript-2020-05-10-javascript147",
"title": "9.1.1 for ... in",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript147/",
"date": "2020-05-10",
"content": "그동안은 객체 프로퍼티를 나열할 때 for … in 을 주로 사용했습니다.문자열 프로퍼티가 몇 개 있고 심볼 프로퍼티가 하나 있는 객체가 있다고 합시다.const SYM = Symbol();const o = { a: 1, b: 2, c: 3, [SYM]: 4 };for (let prop in o) {\tif (!o.hasOwnProperty(prop)) continue;\tconsole.log(`${prop}: ${o[prop]}`);}상당히 단순해 보입니다만, hasOwnProperty 가 무슨 의미인지 궁금한 독자도 있을 겁니다.hasOwnProperty 는 이 장 후반에 알게 될 상속된 프로퍼티가 for … in 에 나타날 위험을 제거하기 위해 사용합니다.이 예제에서는 생략하더라도 아무 차이도 없습니다.하지만 다른 타입의 객체, 특히 다른 사람이 만든 객체의 프로퍼티를 나열하다 보면 예상치 못한 상황이 생길 수 있으므로 hasOwnProperty 를 쓰는 습관을 들이길 권합니다.hasOwnProperty가 왜 중요한지, 생략해도 안전할 때는 언제인지는 곧 알게 됩니다.for … in 루프에는 키가 심볼인 프로퍼티는 포함되지 않습니다.  CAUTION_for … in 을 배열에 사용할 수도 있겠지만, 그리 좋은 생각은 아닙니다.배열에는 일반적인 for 루프나 forEach를 사용하십시오."
}, 

{
"id": "-javascript-2020-05-10-javascript146",
"title": "9.1 프로퍼티 나열",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript146/",
"date": "2020-05-10",
"content": "일반적으로 어떤 컨테이너의 콘텐츠를 리스트로 나열한다고 하면, 보통 배열을 생각하지 객체를 생각하는 사람은 별로 없습니다.하지만 객체도 분명 컨테이너이고 프로퍼티 나열을 지원합니다.특별히 복잡한 작업이 필요하지는 않습니다.프로퍼티 나열에서 기억해야 할 것은 순서가 보장되지 않는다는 점입니다.여러 번 테스트를 해 봤는데도 프로퍼티가 입력한 순서대로 나열될 수도 있습니다.거의 항상 그렇게 될 수도 있습니다.하지만 자바스크립트가 그런 순서를 명시적으로 보장하는 것도 아니고, 브라우저나 노드 등의 프로그램에서 속도나 효율 향상을 목적으로 언제든 바꿀 수도 있습니다.따라서 입증할 수 없는 테스트를 근거로 확실하다는 착각에 빠지지 마십시오.객체 프로퍼티에는 순서가 없습니다.주의할 점은 충분히 숙지했으니 이제 객체의 프로퍼티를 나열하는 방법을 알아봅시다."
}, 

{
"id": "-javascript-2020-05-10-javascript145",
"title": "9. 객체와 객체지향 프로그래밍",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript145/",
"date": "2020-05-10",
"content": "3장에서 객체에 관해 기본적인 내용을 훑어봤습니다.이제 자바스크립트의 객체를 더 깊이 살펴볼 때입니다.배열과 마찬가지로 자바스크립트 객체 역시 컨테이너지만, 크게 보면 다음 두 가지 측면에서 배열과 다릅니다.  배열은 값을 가지며 각 값에는 숫자형 인덱스가 있습니다.객체는 프로퍼티를 가지며 각 프로퍼티에는 문자열이나 심볼 인덱스가 있습니다.  배열에는 순서가 있습니다.즉, arr[0]은 항상 arr[1] 보다 앞에 있습니다.반면 객체에는 그런 순서가 보장되지 않습니다.obj.a가 obj.b보다 앞에 있다고 말할 수는 없습니다.이런 차이는 중요하긴 하지만, 다분히 이론적입니다.그러니 객체를 정말로 객체답게 만드는 프로퍼티에 대해 생각해 봅시다.프로퍼티는 키(문자열 또는 심볼) 과 값으로 구성됩니다.객체의 진짜 특징은 키를 통해 프로퍼티에 접근할 수 있다는 점입니다."
}, 

{
"id": "-javascript-2020-05-10-javascript144",
"title": "8.8 요약",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript144/",
"date": "2020-05-10",
"content": "자바스크립트 Array 클래스에는 강력하고 유연한 메서드가 많지만, 때로는 어떤 메서드가 최선일지 판단하기 어려울 때도 있습니다.[표 8-1]부터 [표 8-4]는 Array 메서드를 요약한 겁니다.콜백 함수를 받는 find, findIndex, some, every, map, filter, reduce에서 콜백 함수가 제공받는 매개변수는 [표 8-1]과 같습니다.표 8-1 배열 함수의 매개변수(순서대로)            메서드      설명                  reduce에만 적용      누적값, 초깃값 또는 마지막 호출에서 반환한 값              모든 메서드      요소(현재 요소의 값)              모든 메서드      현재 요소의 인덱스              모든 메서드      배열 자체(그다지 쓸모는 없음)      콜백을 받는 메서드들은 또한 옵션으로 콜백을 호출할 때 this로 사용할 값을 받을 수 있습니다.이 매개변수를 활용하면 콜백 함수를 메서드처럼 사용할 수 있습니다.표 8-2 배열 컨텐츠 조작            하고 싶은 일      사용할 메서드      수정 또는 사본                  스택(후입 선출)을 만들 때      push(바뀐 길이 반환), pop      배열 수정              큐(선입 선출)를 만들 때      unshift(바뀐 길이 반환), shift      배열 수정              여러 요소를 배열 마지막에 추가할 때      concat      사본 반환              배열 일부가 필요할 때      slice      사본 반환              임의의 위치에 요소를 추가하거나 제거할 때      splice      배열 수정              배열 안에서 요소를 교체할 때      copyWithin      배열 수정              배열을 채울 때      fill      배열 수정              배열을 반대로 정렬할 때      reverse      배열 수정              배열을 정렬할 때      sort(정렬 함수 사용 가능)      배열 수정      표 8-3 배열 검색            찾고자 하는 것      사용할 메서드                  요소의 인덱스      indexOf(단순한 값), findIndex(복잡한 값)              인덱스를 뒤에서부터 찾을 때      lastIndexOf(단순한 값)              요소 자체      find              조건을 만족하는 요소가 들어있는지 확인할 때      some              모든 요소가 그 조건을 만족하는지 확인할 때      every      표 8-4 배열 변형            하고 싶은 일      사용할 메서드      수정 또는 사본                  배열의 모든 요소를 변형할 때      map      사본 반환              조건에 맞는 요소만 남길 때      filter      사본 반환              배열 전체를 다른 데이터 타입으로 변형할 때      reduce      사본 반환              요소를 문자열로 바꿔서 하나로 합칠 때      join      사본 반환      "
}, 

{
"id": "-javascript-2020-05-10-javascript143",
"title": "8.7 문자열 병합 join",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript143/",
"date": "2020-05-10",
"content": "배열의 문자열 요소들을 몇몇 구분자로 합치려 할 때가 많습니다.Array.prototype.join은 매개변수로 구분자 하나를 받고 요소들을 하나로 합친 문자열을 반환합니다.이 매개변수가 생략됐을 때의 기본값은 쉼표이며, 문자열 요소를 합칠 때 정의되지 않은 요소, 삭제된 요소, null, undefined는 모두 빈 문자열로 취급합니다.const arr = [1, null, \"hello\", \"world\", true, undefined];delete arr[3];arr.join(); // \"1, , hello, , true,\"arr.join(''); // \"1hellotrue\"arr.join(' -- '); // \"1 --  -- hello --  -- true -- \"문자열 병합과 Array.prototype.join 을 함께 쓰면 HTML &lt;ul&gt; 리스트 같은 것도 만들 수 있습니다.이때 빈 배열에 사용하면 빈 &lt;li&gt; 요소 하나만 나올 겁니다.const attributes = [\"Nimble\", \"Perceptive\", \"Generous\"];const html = '&lt;ul&gt;&lt;li&gt;' + attributes.join('&lt;/li&gt;&lt;li&gt;') + '&lt;/li&gt;&lt;/ul&gt;';// html : \"&lt;ul&gt;&lt;li&gt;Nimble&lt;/li&gt;&lt;li&gt;Perceptive&lt;/li&gt;&lt;li&gt;Generous&lt;/li&gt;&lt;/ul&gt;\";"
}, 

{
"id": "-javascript-2020-05-10-javascript142",
"title": "8.6 삭제되거나 정의되지 않은 요소들",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript142/",
"date": "2020-05-10",
"content": "Array 메서드는 삭제되거나 정의되지 않은 요소들을 다룰 때 좀 당혹스럽게 동작하곤 합니다.map과 filter, reduce는 삭제되거나 정의되지 않은 요소들에서 콜백함수를 호출하지 않습니다.예를 들어 ES5에서 배열을 초기화할 때 다음과 같은 방법을 시도해 보고 실망했던 독자도 있을 겁니다.  역주_ES6에서는 기대한 대로 동작한다는 것처럼 읽힐 수도 있지만, 저자는 앞에서 설명한 fill 메서드를 염두에 두고 이렇게 표현한 것으로 보입니다.const arr = Array(10).map(function(x) { return 5 });arr의 요소는 전부 undefined 입니다.이와 비슷하게, 배열 중간의 요소를 삭제하고 map을 호출하면 배열 가운데 ‘구멍’이 생깁니다.const arr = [1, 2, 3, 4, 5];delete arr[2];arr.map(x =&gt; 0); // [0, 0, undefined, 0, 0]일반적으로 배열을 다룰 때는 모든 요소가 명시적으로 정의된 배열을 다루고, 의도적으로 배열 안에 빈 부분을 만든다 하더라도 배열에 delete를 쓰지는 않을 테니 현실적으로는 이런 동작이 문제를 일으킬 가능성은 거의 없습니다.하지만 알아둬서 나쁠 것은 없습니다."
}, 

{
"id": "-javascript-2020-05-10-javascript141",
"title": "8.5 배열의 마법 reduce",
"author": null,
"tags": [],
"url": "/javascript/2020/05/10/javascript141/",
"date": "2020-05-10",
"content": "reduce는 필자가 가장 좋아하는 메서드입니다.map이 배열의 각 요소를 변형한다면 reduce는 배열 자체를 변형합니다.reduce라는 이름은 이 메서드가 보통 배열을 값 하나로 줄이는 데 쓰이기 때문에 붙었습니다.예를 들어 배열에 들어있는 숫자를 더하거나 평균을 구하는 것은 배열을 값 하나로 줄이는 동작입니다.하지만 reduce가 반환하는 값 하나는 객체일 수도 있고 다른 배열일 수도 있습니다.사실 reduce는 map과 filter를 비롯해 여태까지 설명한 배열 메서드의 동작을 대부분 대신할 수 있습니다.reduce는 map이나 filter와 마찬가지로 콜백함수를 받습니다.그런데 여태까지 설명한 콜백에서 첫 번째 매개변수는 항상 현재 배열 요소였지만, reduce는 다릅니다.reduce가 받는 첫 번째 매개변수는 배열이 줄어드는 대상인 어큐뮬레이터(accumulator) 입니다.두 번째 매개변수부터는 여태까지 설명한 콜백의 순서대로 현재 배열 요소, 현재 인덱스, 배열 자체입니다.  역주_ 어큐뮬레이터 사전에는 누산기라는 뜻이 있지만 적절하지 않다고 생각해서 음차 표기합니다. 본문에서는 어큐뮬레이터라는 표현은 되도록 자제하고 ‘누적값’, ‘전 단계의 결과’ 등 문맥에 맞게 쓰겠습니다.reduce는 초깃값도 옵션으로 받을 수 있습니다.배열의 숫자를 더하는 단순한 예제를 봅시다.const arr = [5, 7, 2, 4];const sum = arr.reduce((a, x) =&gt; a +=x, 0);reduce의 콜백 함수는 매개변수로 누적값 a와 현태 배열 요소 x를 받았습니다.이 예제에서 누적값은 0으로 시작합니다.reduce의 첫 예제이니 자바스크립트가 하는 방식대로 한 단계씩 진행하며 이해해보기로 합시다.  첫 번째 배열 요소 5에서 (익명) 함수를 호출합니다.a의 초깃값은 0이고 x의 값은 5입니다.함수는 a와 x(5)의 합을 반환합니다.이 값은 다음 단계에서 a의 값이 됩니다.  두 번째 배열 요소 7에서 함수를 호출합니다.a의 초깃값은 이전 단계에서 전달한 5이고, x의 값은 7입니다.함수는 a와 x의 합 12를 반환합니다.이 값은 다음 단계에서 a의 값이 됩니다.  세 번째 배열 요소 2에서 함수를 호출합니다.이 단계에서 a는 12이고 x는 2입니다.함수는 a와 x의 합인 14를 반환합니다.  네 번째이자 마지막 배열 요소인 4에서 함수를 호출합니다.a는 14이고 x는 4입니다.함수는  a와 x의 합인 18을 반환하며 이 값은 reduce의 값이고 sum에 할당되는 값입니다.예민한 독자라면 a에 값을 할당할 필요도 없다는 것을 눈치챘을 겁니다.화살표 함수에서 명시적인 return문이 필요하지 않았던 것처럼, 함수에서 중요한 건 무엇을 반환하는가 이므로 그냥 a + x를 반환해도 됐을 겁니다.하지만 reduce를 더 잘 활용하려면 누적값이 어떻게 변하는지 생각하는 습관을 기르는 게 좋습니다.더 흥미로운 예제를 보기 전에, 누적값이 undefined로 시작한다면 어떻게 될지 생각해 봅시다.누적값이 제공되지 않으면 reduce는 첫 번째 배열 요소를 초깃값으로 보고 두 번째 요소에서부터 함수를 호출합니다.앞 예제에서 초깃값을 생략하고 다시 생각해 봅시다.const arr = [5, 7, 2, 4];const sum = arr.reduce((a, x) =&gt; a += x);  두 번째 배열 요소 7에서 함수가 호출됩니다.a의 초깃값은 첫 번째 배열 요소인 5이고 x의 값은 7입니다.함수는 a와 x의 합인 12를 반환하고 이 값이 다음 단계에서 a의 값입니다.  세 번째 배열 요소 2에서 함수를 호출합니다.a의 초깃값은 12이고 x의 값은 2입니다.함수는 a와 x의 합인 14를 반환합니다.  네 번째이자 마지막 배열 요소인 4에서 함수를 호출합니다.a는 14이고 x는 4입니다.함수는 a와 x의 합인 18을 반환하며 이 값은 reduce의 값이고 sum에 할당되는 값입니다.단계는 하나 줄었지만 결과는 같습니다.이 예제를 포함해, 배열의 첫 번째 요소가 그대로 초깃값이 될 수 있을 때는 초깃값을 생략해도 됩니다.reduce는 보통 숫자나 문자열 같은 원시 값을 누적값으로 사용하지만, 객체 또한 누적값이 될 수 있고 이를 통해 아주 다양하게 활용할 수 있는데도 간과하는 사람들이 많습니다.예를 들어 영단어로 이루어진 배열이 있고 각 단어를 첫 글자에 따라 묶는다고 하면 reduce와 함께 객체를 쓸 수 있습니다.const words = [\t\"Beachball\",\t\"Rodeo\",\t\"Angel\",\t\"Aardvark\",\t\"Xylophone\",\t\"November\",\t\"Chocolate\",\t\"Papaya\",\t\"Uniform\",\t\"Joker\",\t\"Clover\",\t\"Bali\"];const alpahbetical = words.reduce((a, x) =&gt; {\tif (!a[x[0]]) a[x[0]] = [];\ta[x[0]].push(x);\treturn a;}, {})이 예제는 조금 더 복잡하지만 원칙은 같습니다.배열의 모든 요소에서 콜백 함수는 전 단계의 결과에 이 단어의 첫 번째 글자인 프로퍼티가 있는지 확인합니다.그런 프로퍼티가 없다면 빈 배열을 추가합니다.즉, “Beachball”을 만나면 a.B 프로퍼티를 확인하는 데 그런 프로퍼티는 없으므로 빈 배열을 만듭니다.그리고 그 단어를 적절한 배열에 추가합니다.“Beachball”은 a.B 프로퍼티가 없었으므로 빈 배열에 추가되고, 마지막으로 {B : [Beachball]}인 a를 반환합니다.reduce는 통계에도 사용할 수 있습니다.예를 들어 데이터 셋의 평균(mean) 과 분산(variabce) 을 계산한다고 해 봅시다.const data = [3.3, 5, 7.2, 12, 4, 6, 10.3];// 도널드 커누스(Donald Knuth)가 분산 계산을 위해 만든 알고리즘입니다.// [컴퓨터 프로그래밍의 예술 : 준수치적 알고리즘(개정 3판)]const stats = data.reduce((a, x) =&gt; {\ta.N++;\tlet delta = x - a.mean;\ta.mean += delta/a.N;\ta.M2 += delta * (x - a.mean);\treturn a;}, {N: 0, mean: 0, M2: 0})if(stats.N &gt; 2) {\tstats.variance = stats.M2 / (stats.N - 1);\tstats.stdev = Math.sqrt(stats.variance);}변수 여러 개, 특히 mean과 M2를 사용해야 하므로 이번에도 객체를 누적값으로 썼습니다.원한다면 N 대신 인덱스에서 1을 뺀 값을 써도 되긴 합니다.reduce의 유연성을 알아보기 위한 한 가지 예제를 더 살펴보겠습니다.예제 자체는 매우 조악하지만, 이번에는 문자열을 누적값으로 사용합니다.const words = [\t\"Beachball\",\t\"Rodeo\",\t\"Angel\",\t\"Aardvark\",\t\"Xylophone\",\t\"November\",\t\"Chocolate\",\t\"Papaya\",\t\"Uniform\",\t\"Joker\",\t\"Clover\",\t\"Bali\"];const longWords = words.reduce((a, w) =&gt; w.length &gt; 6 ? a+\" \"+w : a, \"\").trim();// longWords: \"Beachball Aardvark Xylophone November Chocolate Uniform\"이 예제는 문자열 누적값을 써서 6글자가 넘는 단어를 모아 문자열 하나로 만들었습니다.reduce 대신 filter와 join을 써서 같을 결과를 얻을 수 있습니다.이건 독자의 연습문제로 남겨 두겠습니다.reduce 다음에 trim을 호출한 이유를 먼저 생각해 보십시오.reduce의 잠재력을 잘 활용할 수 있게 되길 바랍니다.reduce는 배열 메서드 중에서 가장 범용적이고 가장 강력한 메서드입니다."
}, 

{
"id": "-javascript-2020-05-09-javascript140",
"title": "8.4 map과 filter - 사본",
"author": null,
"tags": [],
"url": "/javascript/2020/05/09/javascript140/",
"date": "2020-05-09",
"content": "map 과 filter 는 배열 메서드 중 가장 유용한 메서드입니다.이들 메서드로 할 수 있는 일은 정말 다양합니다.map은 배열 요소를 변형합니다.무엇으로 변형하냐고요?뭐든 가능합니다.숫자가 들어있는 객체가 있는데, 필요한 건 숫자라고요?간단합니다.함수로 구성된 배열이 있는데, 프로미스(promise)가 필요하다고요?간단합니다.일정한 형식의 배열을 다른 형식으로 바꿔야 한다면 map을 쓰십시오.map과 filter는 모두 사본을 반환하며 원래 배열은 바뀌지 않습니다.예제를 봅시다.const cart = [ {name: \"Widget\", price: 9.95 }, { name: \"Gadget\", price: 22.95 } ];const names = cart.map(x =&gt; x.name); // [\"Widget\", \"Gadget\"]const prices = cart.map(x =&gt; x.price); // [9.95, 22.95]const discountPrices = prices.map(x =&gt; x * 0.8); // [7.96, 18.36]콜백 함수는 각 요소에서 호출될 때 요소 자체와 요소 인덱스, 배열 전체를 매개변수로 받습니다(배열 매개변수는 그다지 유용하지는 않습니다).다음 예제에는 두 배열에 상품과 가격이 따로 저장되어 이쓴데, 이 둘을 객체로 결합해 봅시다.const items = [\"Widget\", \"Gadget\"];const prices = [9.95, 22.95];const cart = items.map((x, i) =&gt; ({ name: x, price: prices[i]}));// cart: [{name: \"Widget\", price: 9.95}, {name: \"Gadget\", price: 22.95}]이 예제는 조금 더 복잡하지만, map 함수의 가능성을 잘 표현합니다.여기서 우리는 요소 자체(x)만 사용하디 않고 인덱스(i)도 사용했습니다.인덱스를 쓴 까닭은 items의 요소와 prices의 요소를 인덱스에 따라 결합하기 위해서입니다.여기서 map은 다른 배열에서 정보를 가져와서 문자열로 이루어진 배열을 객체 배열로 변형했습니다.객체를 괄호로 감싼 이유는, 이렇게 하지 않으면 화살표 표기법에서 객체 리터럴의 중괄호를 블록으로 판단하기 때문입니다.filter는 이름이 암시하듯 배열에서 필요한 것들만 남길 목적으로 만들어졌습니다.filter는 map과 마찬가지로 사본을 반환하며 새 배열에는 필요한 요소만 남습니다.어떤 요소를 남길지는 마음대로입니다.어떤 요소를 남길지 판단할 함수를 넘길 것 같다고요?정답입니다.예제를 봅시다.// 카드 덱을 만듭니다.const cards = [];for (let suit of ['H', 'C', 'D', 'S']) // 하트, 클로버, 다이아몬드, 스페이드\tfor (let value=1; value&lt;=13; value++)\t\tcards.push({suit, value});\t\t// value가 2인 카드cards.filter(c =&gt; c.value === 2);// 다이아몬드cards.filter(c =&gt; c.suit === 'D');// 킹, 퀸, 주니어cards.filter(c =&gt; c.value &gt; 10);// 하트의 킹, 퀸, 주니어cards.filter(c =&gt; c.value &gt; 10 &amp;&amp; c.suit === 'H');map과 filter를 결합하면 정말 다양한 일을 할 수 있습니다.예를 들어 앞에서 만든 카드 덱을 짧은 문자열로 표현하고 싶다고 합시다.카드 그림(suit)(하트, 클로버, 다이아몬드, 스페이드)에는 유니코드 코드 포인트를 쓰고 에이스와 킹, 퀸, 주니어는 숫자 대신 각각 A, K, Q, J를 쓰겠습니다.여기에 필요한 함수는 조금 길어지므로 익명 함수를 쓰지 않고 따로 만들겠습니다.const cards = [];for (let suit of ['H', 'C', 'D', 'S']) // 하트, 클로버, 다이아몬드, 스페이드\tfor (let value=1; value&lt;=13; value++)\t\tcards.push({suit, value});\t\tfunction cardToString(c) {\tconst suits = {'H': '\\u2665', 'C': '\\u2663', 'D': '\\u2666', 'S': '\\u2660'}\tconst values = { 1: 'A', 11: 'J', 12: 'Q', 13: 'K'};\t// cardToString을 호출할 때마다 매번 값을 만드는 건 그리 효율적인 방법은 아닙니다.\t// 더 효율적인 방법은 독자의 연습문제로 남기겠습니다.\tfor (let i=2; i&lt;=10; i++) values[i] = i;\treturn values[c.value] + suits[c.suit];}// value가 2인 카드cards.filter(c =&gt; c.value === 2).map(cardToString);// 하트의 킹, 퀸, 주니어cards.filter(c =&gt; c.value &gt; 10 &amp;&amp; c.suit === 'H').map(cardToString);"
}, 

{
"id": "-javascript-2020-05-09-javascript139",
"title": "8.3 배열 검색 - indexOf, lastIndexOf, findIndex, find, some, every",
"author": null,
"tags": [],
"url": "/javascript/2020/05/09/javascript139/",
"date": "2020-05-09",
"content": "indexOf, lastIndexOf배열 안에서 뭔가 찾으려 할 때는 몇 가지 방법이 있습니다.indexOf 부터 알아봅시다.indexOf는 찾고자 하는 것과 정확히 일치(===)하는 첫 번째 요소의 인덱스를 반환합니다.indexOf의 짝인 lastIndexOf는 배열의 끝에서부터 검색합니다.배열의 일부분만 검색하려면 시작 인덱스를 지정할 수 있습니다.indexOf와 lastIndexOf는 일치하는 것을 찾지 못하면 -1을 반환합니다.const o = {name: \"Jerry\"};const arr = [1, 5, \"a\", o, true, 5, [1, 2], \"9\"];arr.indexOf(5); // 1arr.lastIndexOf(5); // 5arr.indexOf(\"a\"); // 2arr.lastIndexOf(\"a\"); // 2arr.indexOf({name: \"Jerry\"}); // -1arr.indexOf(o); // 3arr.indexOf([1, 2]); // -1arr.indexOf(\"9\"); // 7arr.indexOf(9); // -1arr.indexOf(\"a\", 5); // -1arr.indexOf(5, 5); // 5arr.lastIndexOf(5, 4); // 1arr.lastIndexOf(true, 3); // -1findIndexfindIndex는 일치하는 것을 찾지 못했을 때 -1을 반환한다는 점에서는 indexOf와 비슷하지만, 보조 함수를 써서 검색 조건을 지정할 수 있으므로 indexOf 보다 더 다양한 상황에서 활용할 수 있습니다.하지만 findIndex는 검색을 시작할 인덱스를 지정할 수 없고, 뒤에서부터 찾는 findLastIndex 같은 짝도 없습니다.const arr = [{ id: 5, name: \"Judith\" }, { id: 7, name: \"Francis\" }];arr.findIndex(o =&gt; o.id === 5); // 0arr.findIndex(o =&gt; o.name === \"Francis\"); // 1arr.findIndex(o =&gt; o === 3); // -1arr.findIndex(o =&gt; o.id === 17);  // -1findindexOf와 findIndex는 조건에 맞는 요소의 인덱스를 찾을 때 알맞지만,조건에 맞는 요소의 인덱스가 아니라 요소 자체를 원할 때는 find를 사용합니다.find는 findIndex와 마찬가지로 검색 조건을 함수로 전달할 수 있습니다.조건에 맞는 요소가 없을 때는 undefined를 반환합니다.const arr = [{ id: 5, name: \"Judith\" }, { id: 7, name: \"Francis\" }];arr.find(o =&gt; o.id === 5); // 객체 {id: 5, name: \"Judith\"}arr.find(o =&gt; o.id === 2); // undefinedfind와 findIndex에 전달하는 함수는 배열의 각 요소를 첫 번째 매개변수 로 받고, 현재 요소의 인덱스와 배열 자체도 매개변수 로 받습니다. 이런 점을 다양하게 응용할 수 있습니다.예를 들어, 특정 인덱스보다 뒤에 있는 제곱수를 찾아야 한다고 합시다.const arr = [1, 17, 16, 5, 4, 16, 10, 3, 49];arr.find((x, i) =&gt; i &gt; 2 &amp;&amp; Number.isInteger(Math.sqrt(x))); // 4find와 findIndex에 전달하는 함수의 this도 수정할 수 있습니다.이를 이용해서 함수가 객체의 메서드인 것처럼 호출할 수 있습니다.ID를 조건으로 Person 객체를 검색하는 예제를 보십시오.두 방법의 결과는 같습니다.class Person {\tconstructor(name) {\t\tthis.name = name;\t\tthis.id = Person.nextId++;\t}}Person.nextId = 0;const jamie = new Person(\"Jamie\"),\tjuliet = new Person(\"Juliet\"),\tpeter = new Person(\"Peter\"),\tjay = new Person(\"Jay\");\tconst arr = [jamie, juliet, peter, jay];// 옵션 1 : ID를 직접 비교하는 방법arr.find(p =&gt; p.id === juliet.id); // juliet 객체// 옵션 2 : \"this\" 매개변수를 이용하는 방법arr.find(function (p) {\treturn p.id === this.id}, juliet);   // juliet 객체이렇게 간단한 예제에서는 find와 findIndex에서 this 값을 바꾸는 의미가 별로 없지만, 나중에 이 방법이 더 유용하게 쓰이는 경우를 보게 될 겁니다.간혹 조건을 만족하는 요소의 인덱스도, 요소 자체도 필요 없고, 조건을 만족하는 요소가 있는지 없는지만 알면 충분할 때가 있습니다.물론 앞에서 설명한 함수를 사용하고 -1 이나 null이 반환되는지 확인해도 되지만, 자바스크립트에는 이럴 때 쓰라고 만든 some과 every 메서드가 있습니다.somesome은 조건에 맞는 요소를 찾으면 즉시 검색을 멈추고 true를 반환하며, 조건에 맞는 요소를 찾지 못하면 false를 반환합니다.예제를 보십시오.const arr = [5, 7, 12, 15, 17];arr.some(x =&gt; x%2 === 0); // true; 12는 짝수입니다.arr.some(x =&gt; Number.isInteger(Math.sqrt(x))); // false; 제곱수가 없습니다.everyevery는 배열의 모든 요소가 조건에 맞아야 true를 반환하며 그렇지 않다면 false를 반환합니다.every는 조건에 맞지 않는 요소를 찾아야만 검색을 멈추고 false를 반환합니다.조건에 맞지 않는 요소를 찾지 못하면 배열 전체를 검색합니다.const arr = [4, 6, 16, 36];arr.every(x =&gt; x%2 === 0); // true; 홀수가 없습니다.arr.every(x =&gt; Number.isInteger(Math.sqrt(x))); // false; 6은 제곱수가 아닙니다.이 장에서 소개하는 메서드 중 콜백 함수를 받는 모든 메서드가 그렇듯, some 과 every도 콜백 함수를 호출할 때 this로 사용할 값을 두 번째 매개변수로 받을 수 있습니다."
}, 

{
"id": "-javascript-2020-05-09-javascript138",
"title": "8.2.7 reverse, sort 배열 정렬과 역순 정렬 - 수정",
"author": null,
"tags": [],
"url": "/javascript/2020/05/09/javascript138/",
"date": "2020-05-09",
"content": "reverse는 이름 그대로 배열 요소의 순서를 반대로 바꿉니다(수정).const arr = [1, 2, 3, 4, 5];arr.reverse(); // arr은 이제 [5, 4, 3, 2, 1] 입니다.sort는 배열 요소의 순서를 정렬합니다.const arr = [5, 3, 2, 4, 1];arr.sort(); // arr은 이제 [1, 2, 3, 4, 5] 입니다.sort는 정렬 함수를 받을 수 있습니다.이 기능은 매우 편리합니다.예를 들어 일반적으로는 객체가 들어있는 배열을 정렬할 수 없지만, 정렬 함수를 사용하면 가능합니다.const arr = [    {name: \"Suzanne\"},     {name: \"Jim\"},     {name: \"Trevor\"},     {name: \"Amanda\"}];// 오름차순arr.sort((a, b) =&gt; {    console.log(a);    console.log(b);    return a.name &lt; b.name ? -1 : a.name &gt; b.name ? 1 : 0;});// 간단하게 (오름차순)arr.sort((a, b) =&gt; a.name &lt; b.name ? -1 : a.name &gt; b.name ? 1 : 0);// 내림차순arr.sort((a, b) =&gt; {    console.log(a);    console.log(b);    return a.name &gt; b.name ? -1 : a.name &lt; b.name ? 1 : 0;});// 간단하게 (내림차순)arr.sort((a, b) =&gt; a.name &gt; b.name ? -1 : a.name &lt; b.name ? 1 : 0);// name 프로퍼티의 두 번째 글자의 알파벳 순서로 정렬arr.sort((a, b) =&gt; {    console.log(a);    console.log(b);    return a.name[1] &lt; b.name[1] ? -1 : a.name[1] &gt; b.name[1] ? 1 : 0;});// name 프로퍼티의 두 번째 글자의 알파벳 역순으로 정렬arr.sort((a, b) =&gt; {    console.log(a);    console.log(b);    return a.name[1] &gt; b.name[1] ? -1 : a.name[1] &lt; b.name[1] ? 1 : 0;});  TIP이 예제의 정렬 함수에서는 불리언을 반환했지만, 숫자를 반환하는 함수도 쓸 수 있습니다.0이 반환되면 sort는 요소가 순서상 같다고 간주하고 순서를 바꾸지 않습니다.이를 응용하면 알파벳 순으로 정렬하면서 k로 시작하는 단어만 원래 순서를 유지한다는 식의 응용이 가능합니다.즉, k로 시작하는 단어는 j로 시작하는 어떤 단어보다 뒤에 있고 i로 시작하는 어떤 단어보다 앞에 있지만,k로 시작하는 단어들은 순서를 그대로 유지하는 겁니다.const arr = [    {name: \"Suzanne\"},     {name: \"Jim\"},     {name: \"Trevor\"},     {name: \"Tree\"},    {name: \"Tara\"},    {name: \"Amanda\"}];arr.sort((a, b) =&gt; {    console.log(a);    console.log(b);    return a.name &lt; b.name ? -1 : a.name &gt; b.name ? 1 : 0;});const arr = [    {name: \"Suzanne\"},     {name: \"Jim\"},     {name: \"Trevor\"},     {name: \"Tree\"},    {name: \"Tara\"},    {name: \"Amanda\"}];arr.sort((a, b) =&gt; a.name[0] &lt; b.name[0] ? -1 : a.name[0] &gt; b.name[0] ? 1 : 0);"
}, 

{
"id": "-javascript-2020-05-09-javascript137",
"title": "8.2.6 fill 특정 값으로 배열 채우기 - 수정",
"author": null,
"tags": [],
"url": "/javascript/2020/05/09/javascript137/",
"date": "2020-05-09",
"content": "ES6에서 도입한 새 메서드 fill은 환영할만한 좋은 메서드입니다.이 메서드는 정해진 값으로 배열을 채웁니다.크기를 지정해서 배열을 생성하는 Array 생성자와 잘 어울립니다.배열의 일부만 채우려 할 때는 시작 인덱스와 끝 인덱스를 지정하면 됩니다.음수 인덱스도 사용할 수 있습니다.다음 예제를 보십시오.const arr = new Array(5).fill(1); // arr에 [1, 1, 1, 1, 1] 로 초기화됩니다.arr.fill(\"a\"); // arr은 이제 [\"a\", \"a\", \"a\", \"a\", \"a\"] 입니다.arr.fill(\"b\", 1); // arr은 이제 [\"a\", \"b\", \"b\", \"b\", \"b\"] 입니다.arr.fill(\"c\", 2, 4); // arr은 이제 [\"a\", \"b\", \"c\", \"c\", \"b\"] 입니다.arr.fill(5.5, -4); // arr은 이제 [\"a\", 5.5, 5.5, 5.5, 5.5] 입니다.arr.fill(0, -3, -1); // arr은 이제 [\"a\", 5.5, 0, 0, 5.5] 입니다."
}, 

{
"id": "-javascript-2020-05-09-javascript136",
"title": "8.2.5 copyWithin 배열 안에서 요소 교체하기",
"author": null,
"tags": [],
"url": "/javascript/2020/05/09/javascript136/",
"date": "2020-05-09",
"content": "copyWithin은 ES6에서 도입한 새 메서드입니다.이 메서드는 배열 요소를 복사해서 다른 위치에 붙여넣고, 기존의 요소를 덮어씁니다.첫 번째 매개변수는 복사한 요소를 붙여넣을 위치이고, 두 번째 매개변수는 복사를 시작할 위치이고, 세 번째 매개변수는 복사를 끝낼 위치입니다(생략할 수 있습니다).slice와 마찬가지로, 음수 인덱스를 사용하면 배열의 끝에서부터 셉니다.예제를 보십시오.const arr = [1, 2, 3, 4];arr.copyWithin(1, 2); // arr은 이제 [1, 3, 4, 4] 입니다.arr.copyWithin(2, 0, 2); // arr은 이제 [1, 3, 1, 3] 입니다.arr.copyWithin(0, -3, -1); // arr은 이제 [3, 1, 1, 3] 입니다."
}, 

{
"id": "-javascript-2020-05-09-javascript135",
"title": "8.2.4 splice 임의의 위치에 요소 추가하거나 제거하기 - 수정",
"author": null,
"tags": [],
"url": "/javascript/2020/05/09/javascript135/",
"date": "2020-05-09",
"content": "splice는 배열을 자유롭게 수정할 수 있습니다.첫 번째 매개변수는 수정을 시작할 인덱스이고, 두 번째 매개변수는 제거할 요소 숫자입니다.아무 요소도 제거하지 않을 때는 0을 넘깁니다.나머지 매개변수는 배열에 추가될 요소입니다.다음 예제를 보십시오.const arr = [1, 5, 7];arr.splice(1, 0, 2, 3, 4); // []. arr은 이제 [1, 2, 3, 4, 5, 7] 입니다.arr.splice(5, 0, 6); // []. arr은 이제 [1, 2, 3, 4, 5, 6, 7] 입니다.arr.splice(1, 2);  // [2, 3]. arr은 이제 [1, 4, 5, 6, 7] 입니다.arr.splice(2, 1, 'a', 'b'); // [5]. arr은 이제 [1, 4, 'a', 'b', 6, 7] 입니다."
}, 

{
"id": "-issue-2020-05-08-issue09",
"title": "gulp sass, watch",
"author": null,
"tags": [],
"url": "/issue/2020/05/08/issue09/",
"date": "2020-05-08",
"content": "function sass() {  return gulp.src([    `${gulpConfig.src}/scss/**/*.{scss, sass}`,    `!${gulpConfig.src}/scss/vendor/*-mixins.scss`  ], { sourcemaps: true })    .pipe($.sassGlob())    .pipe($.sass({      outputStyle: 'expanded'    }).on('error', $.sass.logError))    .pipe($.autoprefixer({      overrideBrowserslist: gulpConfig.autoprefixer,      remove: false,      cascade: false    }))    .pipe($.base64Inline())    .pipe(gulp.dest(`${gulpConfig.src}/css`))    .pipe(gulp.dest(`${gulpConfig.dist}/css`, { sourcemaps: true }))}function server() {  // serve files from the build folder  browserSync.init({    port: 8030,    ui: {      port: 8033,      weinre: {        port: 8133      }    },    cors: false, // if you need CORS, set true    server: {      baseDir: `${gulpConfig.dist}/`    }  },function(){})  // watch files and run tasks  gulp.watch([    `${gulpConfig.src}/img/**/*`,    `!${gulpConfig.src}/img/*.png`,    `!${gulpConfig.src}/img/*.svg`  ], gulp.series(sprites, copy_image, sass, browserSyncReload));  gulp.watch([    `${gulpConfig.src}/scss/**/*`,    `!${gulpConfig.src}/scss/vendor/*-mixins.scss`  ], gulp.series(sass, browserSyncReload));  gulp.watch(`${gulpConfig.src}/html/**/*`, gulp.series(process_html, browserSyncReload));  gulp.watch('index.html', gulp.series(make_indexfile, browserSyncReload));}handlebar link"
}, 

{
"id": "-issue-2020-05-08-issue08",
"title": "php 파일 gulp 실행하기",
"author": null,
"tags": [],
"url": "/issue/2020/05/08/issue08/",
"date": "2020-05-08",
"content": "11번가 gulp 세팅하면서 알게된 점입니다.11번가는 html 파일들이 php 문법으로 되어있었습니다.때문에 일반적으로 마크업에서 하듯이 걸프의 browser-sync 모듈로 로컬서버를 열게되면 php 문법이 해석되지않아 페이지들이 제대로 안 보이는 문제점이 있습니다.이 문제를 해결하기 위해선 browser-sync 모듈이 php 문법을 해석하고 컴파일할 수 있도록 기존 php 서버와 연결을 해줘야됩니다.저희 회사엔 기본적으로 로컬서버가 제공되므로 로컬서버 기준으로 예시를 보여드리도록 하겠습니다.방법 1.우선 gulp-connect-php 모듈과 browser-sync 모듈이 필요합니다.npm i -D gulp-connect-php browser-sync 해당 모듈을 설치해줍니다.그리고 로컬 서버의 포트번호를 확인합니다.그리고 식을 작성해줍니다.// php 서버const phpServer = () =&gt; {    phpConnect.server({        // browsersync가 프록시를 통해 연결되는 독립형 PHP 서버        // 웹 서버에 액세스하려는 포트입니다. 포트가 이미 사용 중이면 작업이 실패합니다.        port: 80,        keepalive: true,        base: \"../\"    }, function () {        browserSync({            // php 서버 포트번호와 동일해야됩니다.            proxy: 'localhost:80'        })    })    watch(\"../html/**/*.html\", browserSyncReload)    watch([        config.path.sprites.src,        `!${config.path.sprites.dest}`    ], series(cleanImg, sprites, sassBuild, browserSyncReload))    watch([        \"../sass/**/**/*\",        \"!../sass/**/sprites/*\"    ], series(sassBuild, browserSyncReload))}위에서 핵심은 php 파일을 해석하고 컴파일 할 수 있는 서버의 포트번호와 위 소스의 포트번호를 일치시켜야 된다는 겁니다.위와 같이 작성하면 gulp로도 php 파일을 확인하며 작업할 수 있습니다.만약 회사가 아닌 다른 PC에서 gulp를 활용하여 php파일을 작업해야될 경우일 땐, 다음과 같이 하시면 됩니다.방법2.Mac을 사용하시는 분이라면 https://www.mamp.info/en/downloads/?m=1581611990&amp; 왼쪽 사이트에 접속하셔서해당 프로그램을 다운받으시면 됩니다.윈도우라면 https://www.apachefriends.org/index.html 왼쪽 사이트에 접속하셔서해당 프로그램을 다운받으시면 됩니다.위 프로그램들이 하는 역할은 PHP 파일을 해석할 수 있는 로컬서버를 쉽게 만들 수 있도록 도와줍니다.위 프로그램들에 관한 설명은 여러 블로그에 많아 생략하도록 하겠습니다.위 프로그램들의 로컬서버 포트번호와 gulpfile 소스의 포트번호를 마찬가지로 일치시켜주면 됩니다."
}, 

{
"id": "-javascript-2020-05-08-javascript134",
"title": "8.2.3 slice 배열 일부 가져오기 - 사본",
"author": null,
"tags": [],
"url": "/javascript/2020/05/08/javascript134/",
"date": "2020-05-08",
"content": "배열의 일부만 가져올 때는 slice 메서드를 사용합니다.slice 메서드는 매개변수 두 개를 받습니다.첫 번째 매개변수는 어디서부터 가져올지를,두 번째 매개변수는 어디까지 가져올지를 (바로 앞 인덱스까지 가져옵니다) 지정합니다.두 번째 매개변수를 생략하면 배열의 마지막까지 반환합니다.이 메서드에서는 음수 인덱스를 쓸 수 있고, 음수 인덱스를 쓰면 배열의 끝에서부터 요소를 셉니다.예제를 봅시다.const arr = [1, 2, 3, 4, 5];arr.slice(3); // [4, 5]. arr은 바뀌지 않았습니다.arr.slice(2, 4); // [3, 4]. arr은 바뀌지 않았습니다.arr.slice(-2); // [4, 5]. arr은 바뀌지 않았습니다.arr.slice(1, -2); // [2, 3]. arr은 바뀌지 않았습니다.arr.slice(-2, -1); // [4]. arr은 바뀌지 않았습니다."
}, 

{
"id": "-javascript-2020-05-08-javascript133",
"title": "8.2.2 concat 배열의 끝에 여러 요소 추가하기 - 사본",
"author": null,
"tags": [],
"url": "/javascript/2020/05/08/javascript133/",
"date": "2020-05-08",
"content": "concat 메서드는 배열의 끝에 여러 요소를 추가한 사본을 반환합니다.concat 에 배열을 넘기면 이 메서드는 배열을 분해해서 원래 배열에 추가한 사본을 반환합니다.예제를 보십시오.const arr = [1, 2, 3];arr.concat(4, 5, 6);  // [1, 2, 3, 4, 5, 6]. arr은 바뀌지 않습니다.arr.concat([4, 5, 6]); // [1, 2, 3, 4, 5, 6]. arr은 바뀌지 않습니다.arr.concat([4, 5], 6);  // [1, 2, 3, 4, 5, 6]. arr은 바뀌지 않습니다.arr.concat([4, [5, 6]]); // [1, 2, 3, 4, [5, 6]]. arr은 바뀌지 않습니다.concat 은 제공받은 배열을 한 번만 분해합니다.배열 안에 있는 배열을 다시 분해하지는 않습니다."
}, 

{
"id": "-javascript-2020-05-06-javascript132",
"title": "8.2.1 push, pop, shift, unshift 배열의 처음이나 끝에서 요소 하나를 추가하거나 제거하기 - 수정",
"author": null,
"tags": [],
"url": "/javascript/2020/05/06/javascript132/",
"date": "2020-05-06",
"content": "배열의 처음은 첫 번째 요소, 즉 인덱스가 0인 요소를 말합니다.마찬가지로 배열의 끝은 인덱스가 가장 큰 요소, 즉 배열이 arr이라면 arr.length - 1 인 요소를 말합니다.push와 pop은 각각 배열의 끝에 요소를 추가하거나 제거합니다(수정).  역주_ 수정이 장에서 (수정)이라는 표현은 배열 자체를 수정한다는 뜻입니다.(사본)이라는 표현은 원래 배열은 바뀌지 않고 변경된 내용을 반영한 새 배열을 반환한다는 뜻입니다.shift 와 unshift 는 각각 배열의 처음에 요소를 제거하거나 추가합니다(수정).push와 unshift는 새 요소를 추가해서 늘어난 길이를 반환하고, pop과 shift는 제거된 요소를 반환합니다.다음은 이들 메서드의 예제입니다.const arr = [\"b\", \"c\", \"d\"];arr.push(\"e\");  // 4. arr은 이제 [\"b\", \"c\",  \"d\", \"e\"] 입니다.arr.pop();  // \"e\". arr은 이제 [\"b\", \"c\", \"d\"] 입니다.arr.unshift(\"a\");  // 4. arr은 이제 [\"a\", \"b\", \"c\", \"d\"] 입니다.arr.shift();  // \"a\". arr은 이제 [\"b\", \"c\", \"d\"] 입니다."
}, 

{
"id": "-javascript-2020-05-06-javascript131",
"title": "8.2 배열 요소 조작",
"author": null,
"tags": [],
"url": "/javascript/2020/05/06/javascript131/",
"date": "2020-05-06",
"content": "메서드를 설명하기에 앞서, 자주 사용하는 배열 조작 메서드에 대해 짚고 넘어갈 점이 있습니다.애석하게도 배열 메서드 중 일부는 배열 ‘자체를 수정하며, 다른 일부는 새 배열을 반환합니다.예를 들어 push는 배열 자체를 수정하며, concat은 새 배열을 반환합니다.메서드 이름에 이런 차이점에 대한 힌트가 전혀 없으므로 프로그래머가 전부 기억해야 합니다.  NOTE_루비 같은 언어는 이름만 봐도 대상 자체를 수정하는지, 아니면 새로운 것을 반환하는지 알 수 있도록 만들어져 있습니다.예를 들어 루비에서 문자열 str에서 str.downcase를 호출하면 소문자 버전이 반환되지만 str 자체는 바뀌지 않습니다.반면 str.downcase! 를 호출하면 소문자 버전이 반환되지만 str 자체가 바뀝니다.필자는 자바스크립트 표준 라이브러리에서 어떤 메서드가 데이터 자체를 수정하고 어떤 메서드가 사본을 반환하는지에 관한 아무런 단서도 제공하지 않는다는 점은 불필요한 기억을 강요하는 단점이라고 생각합니다."
}, 

{
"id": "-javascript-2020-05-05-javascript130",
"title": "8.1 배열의 기초",
"author": null,
"tags": [],
"url": "/javascript/2020/05/05/javascript130/",
"date": "2020-05-05",
"content": "본격적으로 시작하기 전에 먼저 배열의 기본적인 사항을 다시 떠올려 봅시다.  배열은 객체와 달리 본질에서 순서가 있는 데이터 집합이며 0으로 시작하는 숫자형 인덱스를 사용합니다.  자바스크립트의 배열은 비균질적(nonhomogeneous) 입니다. 즉, 한 배열의 요소가 모두 같은 타입일 필요는 없습니다. 배열은 다른 배열이나 객체도 포함할 수 있습니다.  배열 리터럴은 대괄호로 만들고, 배열 요소에 인덱스로 접근할 때도 대괄호를 사용합니다.  모든 배열에는 요소가 몇 개 있는지 나타내는 length 프로퍼티가 있습니다.  배열에 배열 길이보다 큰 인덱스를 사용해서 요소를 할당하면 배열은 자동으로 그 인덱스에 맞게 늘어나며, 빈자리는 undefined로 채워집니다.  Array 생성자를 써서 배열을 만들 수도 있지만 그렇게 해야 하는 경우는 별로 없습니다.이 장을 시작하기 전에, 지금까지 짚어 본 내용이 모두 익숙한지 확인하십시오.// 배열 리터럴const arr1 = [1, 2, 3]; // 숫자로 구성된 배열const arr2 = [\"one\", 2, \"three\"]; // 비균질적 배열const arr3 = [[1, 2, 3], [\"one\", 2, \"three\"]]; // 배열을 포함한 배열const arr4 = [\t{ name: \"Fred\", type: \"object\", luckyNumbers: [5, 7, 13] },\t[\t\t{ name: \"Susan\", type: \"object\" },\t\t{ name: \"Anthony\", type: \"object\" },\t],\t1,\tfunction () { return \"arrays can contain functions too\"; },\t\"three\",];// 배열 요소에 접근하기arr1[0]; // 1arr1[2]; // 3arr3[1]; // [\"one\", 2, \"three\"]arr4[1][0]; // { name:\"Susan\", type: \"object\" }// 배열 길이arr1.length; // 3arr4.length; // 5arr4[1].length; // 2arr4[0].length; // undefined// 배열 길이 늘리기arr1[4] = 5;arr1; // [1, 2, 3, undefined, 5]arr1.length; // 5// 배열의 현재 길이보다 큰 인덱스에 접근하는 것만으로 배열의 길이가 늘어나지는 않습니다.arr2[10]; // undefinedarr2.length; // 3// Array 생성자(거의 사용하지 않습니다)const arr5 = new Array(); // 빈 배열const arr6 = new Array(1, 2, 3);  // [1, 2, 3]const arr7 = new Array(2);  // 길이가 2인 배열. 요소는 모두 undefined 입니다.const arr8 = new Array(\"2\"); // [\"2\"]"
}, 

{
"id": "-javascript-2020-05-05-javascript129",
"title": "8. 배열과 배열 처리",
"author": null,
"tags": [],
"url": "/javascript/2020/05/05/javascript129/",
"date": "2020-05-05",
"content": "자바스크립트의 배열 메서드는 필자가 가장 좋아하는 기능 중 하나입니다.프로그래밍을 하다보면 데이터 집합을 조작해야 할 일이 정말 많습니다.자바스크립트의 배열 메서드에 익숙해지면 이런 작업을 쉽게 처리할 수 있고 자바스크립트 개발 능력이 한 단계 올라갈 겁니다."
}, 

{
"id": "-javascript-2020-05-05-javascript128",
"title": "7.12 요약",
"author": null,
"tags": [],
"url": "/javascript/2020/05/05/javascript128/",
"date": "2020-05-05",
"content": "어떤 프로그래밍 언어에서든 스코프는 반드시 이해해야 할 중요한 부분입니다.자바스크립트는 let을 도입하면서 대부분의 최신 언어와 비슷하게 동작하게 됐습니다.자바스크립트가 클로저를 지원한 첫 번째 언어는 아니지만, 실무에서 널리 쓰이는 언어 중에서는 매우 빨리 지원한 편입니다.자바스크립트 개발자들은 클로저를 아주 유용하게 사용하고 있으며, 클로저는 최신 자바스크립트 개발에서 중요한 위치를 차지하고 있습니다."
}, 

{
"id": "-javascript-2020-05-05-javascript127",
"title": "7.11 스트릭트 모드",
"author": null,
"tags": [],
"url": "/javascript/2020/05/05/javascript127/",
"date": "2020-05-05",
"content": "ES5 문법에서는 암시적 전역 변수(implicit global) 라는 것이 생길 수 있었습니다.암시적 전역 변수는 여러 가지 골치 아픈 에러를 일으키곤 했습니다.간단히 말해 var로 변수를 선언하는 것을 잊으면 자바스크립트는 전역 변수를 참조하려 한다고 간주하고, 그런 전역 변수가 존재하지 않으면 스스로 만들었습니다.수많은 문제가 발생할 것은 불 보듯 뻔한 일입니다.이런 이유로 자바스크립트에서는 스트릭트 모드(strict mode) 를 도입했습니다.스트릭트 모드에서는 암시적 전역 변수를 허용하지 않습니다.스트릭트 모드를 사용하려면 문자열 “use strict”(작은 따옴표를 써도 됩니다) 하나만으로 이루어진 행을 코드 맨 앞에 쓰면 됩니다.전역 스코프에서 “use strict”를 사용하면 스크립트 전체가 스트릭트 모드로 실행되고, 함수 안에서 “use strict”를 사용하면 해당 함수만 스트릭트 모드로 실행됩니다.전역 스코프에 스트릭트 모드를 적용하면 스크립트 전체의 동작 방식이 바뀌므로 주의해야합니다.최신 웹사이트는 대부분 다양한 스크립트를 불러와서 사용하므로 전역 스코프에서 스트릭트 모드를 사용하면 불러온 스크립트 전체에 스트릭트 모드가 강제됩니다.모든 스크립트가 스트릭트 모드에서 정확히 동작한다면 멋진 일이겠지만 바라기 힘든 일입니다.따라서 일반적으로는 전역 스코프에서 스트릭트 모드를 사용하지 않는 편이 좋습니다.작성하는 함수 하나하나마다 전부 “use strict”를 붙이고 싶은 사람은 없을 테니, 코드 전체를 즉시 실행되는 함수 하나로 감싸면 됩니다.이에 관해서는 13장에서 다시 설명할 겁니다.(function () {\t'use strict';\t\t// 코드를 전부 이 안에 작성합니다.\t// 이 코드는 스트릭트 모드로 동작하지만,\t// 이 코드와 함께 동작하는 다른 스크립트는\t// 스트릭트 모드에 영향받지 않습니다.})()스트릭트 모드는 대부분의 경우에 바람직하므로 필자는 스트릭트 모드를 권합니다.린트 프로그램을 사용한다면 스트릭트 모드가 막아주는 문제를 대부분 막아주지만, 두 번 체크해서 나쁠 것은 전혀 없습니다.스트릭트 모드에 대해 더 자세히 알고 싶다면 MDN 문서를 보십시오."
}, 

{
"id": "-javascript-2020-05-05-javascript126",
"title": "7.10 사각지대",
"author": null,
"tags": [],
"url": "/javascript/2020/05/05/javascript126/",
"date": "2020-05-05",
"content": "사각지대(temporal dead zone) 란, let으로 선언하는 변수는 선언하기 전까지 존재하지 않는다는 직관적 개념을 잘 나타내는 표현입니다.스코프 안에서 변수의 사각지대는 변수가 선언되기 전의 코드입니다.변수를 선언하기 전에 사용할 일은 거의 없으므로 사각지대에 빠질 일도 거의 없지만, ES6 이전의 자바스크립트에 익숙한 사람이라면 주의해야할 경우가 하나 있습니다.typeof 연산자는 변수가 선언됐는지 알아볼 때 널리 쓰이고, 존재를 확인하는 안전한 방법으로 알려져 있습니다.즉, let 키워드가 도입되고 변수의 사각지대가 생기기 전에는 다음과 같은 코드는 항상 안전하며 에러가 발생하지도 않았습니다.if (typeof x === \"undefined\") {\tconsole.log(\"x doesn't exist or is undefined\");} else {\t// x를 사용해도 안전한 코드}하지만 이 코드를 let으로 변수 선언하면 안전하지 않습니다.다음 코드에서는 에러가 발생합니다.if (typeof x === \"undefined\") {\tconsole.log(\"x doesn't exist or is undefined\");} else {\t// x를 사용해도 안전한 코드}let x = 5;ES6에서는 typeof 연산자로 변수가 정의됐는지 확인할 필요가 거의 없으므로 typeof가 문제를 일으킬 소지도 거의 없습니다."
}, 

{
"id": "-javascript-2020-05-05-javascript125",
"title": "7.9 함수 호이스팅",
"author": null,
"tags": [],
"url": "/javascript/2020/05/05/javascript125/",
"date": "2020-05-05",
"content": "var로 선언된 변수와 마찬가지로, 함수 선언도 스코프 맨 위로 끌어올려집니다.따라서 함수를 선언하기 전에 호출할 수 있습니다.f(); // 'f'function f() {\tconsole.log('f');}잠깐, 변수에 할당한 함수 표현식은 끌어올려지지 않습니다.이들은 변수의 스코프 규칙을 그대로 따릅니다.다음 예제를 보십시오.f(); // ReferrenceError: f는 정의되지 않았습니다.let f = function() {\tconsole.log('f');}"
}, 

{
"id": "-javascript-2020-05-05-javascript124",
"title": "7.8 함수 스코프와 호이스팅",
"author": null,
"tags": [],
"url": "/javascript/2020/05/05/javascript124/",
"date": "2020-05-05",
"content": "ES6에서 let을 도입하기 전에는 var를 써서 변수를 선언했고, 이렇게 선언된 변수들은 함수 스코프로 불리는 스코프를 가졌습니다(var로 선언한 전역 변수는 명시적인 함수 안에 있지는 않지만 함수 스코프와 똑같이 동작합니다).let으로 변수를 선언하면, 그 변수는 선언하기 전에는 존재하지 않습니다.var로 선언한 변수는 현재 스코프 안이라면 어디서는 사용할 수 있으며, 심지어 선언하기도 전에 사용할 수 있습니다.예제를 보기 전에, 아직 선언되지 않은 변수와 값이 undefined인 변수는 다르다는 점을 상기해 봅시다.아직 선언되지 않은 변수는 에러를 일으키지만, 존재하되 값이 undefined인 변수는 에러를 일으키지 않습니다.let var1;let var2 = undefined;var1; // undefinedvar2; // undefinedundefinedVar; // ReferenceError: undefinedVar는 정의되지 않았습니다.let을 쓰면, 변수를 선언하기 전 사용하려 할 때 에러가 일어납니다.x; // ReferenceError: x는 정의되지 않았습니다.let x = 3; // 에러가 일어나서 실행이 멈췄으므로 여기에는 결코 도달할 수 없습니다.반면 var로 변수를 선언하면 선언하기 전에도 사용할 수 있습니다.x; // undefinedvar x = 3;x; // 3대관절 어떻게 된 걸까요?변수를 선언하지도 않았는데 그 변수에 접근할 수 있다는 건 이해할 수 없는 일입니다.var로 선언한 변수는 끌어올린다는 뜻의 호이스팅(hoisting) 이라는 매커니즘을 따릅니다.자바스크립트는 함수나 전역 스코프 전체를 살펴보고 var로 선언한 변수를 맨 위로 끌어올립니다.여기서 중요한 것은 선언만 끌어올려진다는 것이며, 할당은 끌어올려지지 않는다는 겁니다.자바스크립트는 이전 예제를 다음과 같이 해석합니다.var x; // 선언(할당은 아닌)이 끌어올려집니다.x; // undefinedx = 3;x; // 3좀 더 복잡한 예제를 살펴봅시다.이번에는 원래 코드와 자바스크립트가 해석한 코드를 1:1로 비교하겠습니다.// 원래 코드if (x !== 3) {\tconsole.log(y);\tvar y = 5;\tif (y === 5) {\t\tvar x = 3;\t}\tconsole.log(y);}if (x === 3) {\tconsole.log(y);}// 자바스크립트가 해석한 코드var x;var y;if (x !== 3) {\tconsole.log(y);\ty = 5;\tif (y === 5) {\t\tx = 3;\t}\tconsole.log(y);}if (x === 3) {\tconsole.log(y);}원래 코드가 모범적인 자바스크립트 코드라는 것은 아닙니다.변수를 선언하기도 전에 사용하면 불필요하게 혼란스럽고, 에러에도 취약합니다.이렇게 해야 할 현실적인 이유가 있는 것도 아닙니다.이 코드를 제시한 이유는 호이스팅이 어떻게 동작하는지 잘 보여주기 때문입니다.var를 이용해 변수를 선언하면 자바스크립트는 같은 변수를 여러 번 정의하더라도 무시합니다.// 원래 코드var x = 3;if (x === 3) {\tvar x = 2;\tconsole.log(x);}console.log(x);// 자바스크립트가 해석한 코드var x;x = 3;if (x === 3) {\tx = 2;\tconsole.log(x);}console.log(x);이 예제를 보면 같은 함수나 전역 스코프 안에서는 var로 새 변수를 만들 수 없으며, let으로 가능했던 변수 숨김도 불가능함을 알 수 있습니다.이 예제는 블록 안에서 두 번째 var문을 썼지만 변수 x는 하나뿐입니다.다시 말하자면, 이런 스타일을 권하는 건 절대 아닙니다.이런 스타일은 혼란을 초래할 뿐입니다.대부분의 독자, 특히 다른 언어에 익숙한 독자들은 이 예제를 힐끗 보고 필자가 if 문의 블록 스코프 안에 새 변수 x를 만들려 한다고 생각할 수 있지만, 그런 일은 일어나지 않습니다.var를 쓰면 혼란스럽고 쓸모없는 코드가 생길 수 있는데 왜 이런 키워드를 만들었는지 의문이 든다면 let 키워드가 만들어진 이유를 이해한 겁니다.물론 var를 써도 명확하고 이해하기 쉬운 코드를 작성할 수 있지만, 혼란스럽고 불명확한 코드를 작성할 위험은 여전합니다.var를 뜯어고치면 기존 코드가 모두 망가지므로 대신 ES6에서 let을 새로 만든 겁니다.필자는 let 대신 var를 써서 더 좋은 코드나 더 명확한 코드를 쓰는 방법을 도저히 떠올릴 수 없습니다.달리 말해 var에는 let보다 나은 점이 전혀 없습니다.필자를 포함해, 자바스크립트 커뮤니티에서는 대부분 let이 언젠가 var를 완전히 대체할 것으로 예상합니다.언젠가는 var가 최종적으로 폐기될 날이 올 수도 있습니다.그럼 왜 var와 호이스팅을 이해해야 할까요?이유는 두 가지 입니다.ES6를 어디에서는 쓸 수 있으려면 아직 시간이 더 필요하므로 ES5로 트랜스컴파일을 해야 합니다.기존 코드는 전부 ES5로 작성됐다는 건 말할 필요도 없겠죠.따라서 아직은 var가 어떻게 동작하는지 이해하고 있어야 합니다.두 번째 이유는, 함수 선언 역시 끌어올려진다는 겁니다.이제 함수 호이스팅에 대해 알아봅시다."
}, 

{
"id": "-javascript-2020-05-05-javascript123",
"title": "7.7 즉시 호출하는 함수 표현식",
"author": null,
"tags": [],
"url": "/javascript/2020/05/05/javascript123/",
"date": "2020-05-05",
"content": "6장에서 함수 표현식에 대해 설명했습니다.함수 표현식을 사용하면 즉시 호출하는 함수 표현식(IIFE) 이란 것을 만들 수 있습니다.IIFE는 함수를 선언하고 즉시 실행합니다.스코프와 클로저에 대해 충분히 이해했으니 왜 IIFE를 사용해야 하는지 이해할 수 있을 겁니다.IIFE는 다음과 같은 형태를 취합니다.(function () {\t// IIFE 바디})();함수 표현식으로 익명 함수를 만들고 그 함수를 즉시 호출합니다.IIFE의 장점은 내부에 있는 것들이 모두 자신만의 스코프를 가지지만, IIFE 자체는 함수이므로 그 스코프 밖으로 무언가를 내보낼 수 있다는 겁니다.const message = (function() {\tconst secret = \"I'm secret!\";\treturn `The secret is ${secret.length} characters long.`;})();console.log(message);변수 secret은 IIFE의 스코프 안에서 안전하게 보호되며 외부에서 접근할 수 없습니다.IIFE는 함수이므로 무엇이든 반환할 수 있습니다.IIFE에서 배열이나 객체, 함수를 반환하는 경우도 무척 많습니다.자신이 몇 번 호출됐는지 보고하는 함수를 생각해 봅시다.이 함수가 몇 번 호출됐는지 저장한 값을 외부에서는 절대 손댈 수 없습니다.const f = (function () {\tlet count = 0;\treturn function () {\t\treturn `I have been called ${++count} time(s).`;\t}})();f(); // \"I have been called 1 time(s).\"f(); // \"I have been called 2 time(s).\"// ...변수 count는 IIFE 안에 안전하게 보관되어 있으므로 손댈 방법이 없습니다.f는 자신이 몇 번 호출됐는지 항상 정확히 알고 있습니다.ES6에서 블록 스코프 변수를 도입하면서 IIFE가 필요한 경우가 줄어들긴 했지만 여전히 매우 널리 쓰입니다.클로저를 만들고 클로저에서 무언가 반환받을 때에는 유용하게 쓸 수 있습니다."
}, 

{
"id": "-javascript-2020-05-05-javascript122",
"title": "7.6 함수, 클로저, 정적 스코프",
"author": null,
"tags": [],
"url": "/javascript/2020/05/05/javascript122/",
"date": "2020-05-05",
"content": "지금까지는 블록으로만 스코프를 설명했으므로 정적 스코프를 파악하기 쉬웠습니다.블록을 들여 쓰면 정적 스코프를 파악하기가 더 쉽습니다.하지만 함수는 여기서 정의하고 저기서 호출하는 식으로 사용하므로 스코프를 제대로 이해하려면 더 고민해야 합니다.모든 함수를 전역에서 정의하고 함수 안에서 전역 스코프를 참조하지 않도록 신경 쓰는 전통적 프로그램에서는(필자는 이런 스타일을 권합니다) 함수가 어떤 스코프에 접근할 수 있는지 생각할 필요도 없습니다.하지만 최신 자바스크립트에서는 함수가 필요한 곳에서 즉석으로 정의할 때가 많습니다.함수를 변수나 객체 프로퍼티에 할당하고, 배열에 추가하고, 다른 함수에 전달하고, 함수가 함수를 반환하고, 심지어 이름조차 없을 때도 잦습니다.함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 경우가 많습니다.이런 것을 보통 클로저(closure) 라고 부릅니다.스코프를 함수 주변으로 좁히는(closure) 것이라고 생각해도 됩니다.클로저 예제를 하나 살펴봅시다.let globalFunc; // 정의되지 않은 전역 함수{\tlet blockVar = 'a'; // 블록 스코프에 있는 변수\t// 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 경우\tglobalFunc = function () {\t\tconsole.log(blockVar);\t}}globalFunc(); // \"a\"globalFunc는 블록 안에서 값을 할당받았습니다.이 블록 스코프와 그 부모인 전역 스코프가 클로저를 형성합니다.globalFunc를 어디서 호출하든, 이 함수는 클로저에 들어있는 식별자에 접근할 수 있습니다.이 예제를 잘 이해해야 합니다.globalFunc을 호출하면, 이 함수는 스코프에서 빠져나왔음에도 불구하고 blockVar에 접근할 수 있습니다.일반적으로 스코프에서 빠져나가면 해당 스코프에서 선언한 변수는 메모리에서 제거해도 안전합니다.하지만 여기서는 스코프 안에서 함수를 정의했고, 해당 함수는 스코프 밖에서도 참조할 수 있으므로 자바스크립트는 스코프를 계속 유지합니다.즉, 스코프 안에서 함수를 정의하면 해당 스코프는 더 오래 유지됩니다.또한 일반적으로는 접근할 수 없는 것에 접근할 수 있는 효과도 있습니다.다음 예제를 보십시오.let f; // 정의되지 않은 함수{\tlet o = { note: 'Safe' };\tf = function() {\t\treturn o;\t}}let oRef = f();oRef.note = \"Not so safe after all!\";일반적으로는 자신의 스코프에 없는 것들에는 접근할 수 없습니다.함수를 정의해 클로저를 만들면 접근할 수 없었던 것들에 접근할 방법이 생깁니다.이건 매우 중요한 측면입니다.이후 장에서 다시 설명하겠습니다."
}, 

{
"id": "-javascript-2020-05-05-javascript121",
"title": "7.5 변수 숨기기",
"author": null,
"tags": [],
"url": "/javascript/2020/05/05/javascript121/",
"date": "2020-05-05",
"content": "다른 스코프에 있으면서 이름이 같은 변수나 상수는 혼란을 초래할 때가 많습니다.스코프 하나가 끝난 다음에 다른 스코프가 있는 식이라면 비교적 단순합니다.{\t// block 1\tconst x = 'blue';\tconsole.log(x); // \"blue\"}console.log(typeof x); // \"undefined\"; x는 스코프 밖에 있습니다.{\t// block 2\tconst x = 3;\tconsole.log(x); // \"3\"}console.log(typeof x); // \"undefined\"; x는 스코프 밖에 있습니다.앞 예제의 x는 다른 스코프에 있는, 이름만 같은 두 개의 변수임을 이해하기 쉽습니다.이제 스코프가 중첩되는 경우를 살펴봅시다.{\t// 외부 블록\tlet x = 'blue';\tconsole.log(x); // \"blue\"\t{\t\t// 내부 블록\t\tlet x = 3;\t\tconsole.log(x); // \"3\"\t}\tconsole.log(x); // \"blue\"}console.log(typeof x); // \"undefined\"; x는 스코프에 있지 않습니다.이 예제는 변수 숨김(variable masking) 을 잘 보여줍니다.내부 블록의 x는 외부 블록에서 정의한 x와는 이름만 같을 뿐 다른 변수이므로 외부 스코프의 x를 숨기는(가리는) 효과가 있습니다.여기서 이해해야 할 중요한 점은, 실행 흐름이 내부 블록에 들어가 새 변수 x를 정의하는 순간, 두 변수가 모두 스코프 안에 있다는 겁니다.변수의 이름이 같으므로 외부 스코프에 있는 변수에 접근할 방법이 없습니다.x 하나가 스코프에 들어갔다가 나오고, 다른 x가 같은 행동을 반복한 이전 예제와 비교해 보십시오.다음 예제를 보면 더 자세히 알 수 있습니다.{\t// 외부 블록\tlet x = { color: \"blue\" };\tlet y = x;  // y와 x는 같은 객체를 가리킵니다.\tlet z = 3;\t{\t\t// 내부 블록\t\tlet x = 5; // 이제 바깥의 x는 가려졌습니다.\t\tconsole.log(x); // 5\t\tconsole.log(y.color); // \"blue\"; y가 가리키는 외부 스코프의 x가 가리키는 객체는 스코프 안에 있습니다.\t\ty.color = \"red\";\t\tconsole.log(z); // 3; z는 숨겨지지 않았습니다.\t}\tconsole.log(x.color); // \"red\"; 객체는 내부 스코프에서 수정됐습니다.\tconsole.log(y.color); // \"red\"; x와 y는 같은 객체를 가리킵니다.\tconsole.log(z); // 3}  NOTE_외부 스코프에 있는 같은 이름의 변수에 그늘이 진 듯 만든다는 의미에서 변수 숨김을 변수 섀도우(shadowing) 라 부르기도 합니다.하지만 그늘이 진다 해도 완벽히 가려지는 것이 아니라 어두워질 뿐이므로 필자는 이 용어를 사용하지 않습니다.변수를 숨기면 그 변수는 해당 이름으로는 절대 접근할 수 없습니다.이제 스코프가 계층적임을 이해했을 겁니다.이전 스코프를 떠나지 않아도 새 스코프에 진입할 수 있습니다.스코프의 계층적인 성격 때문에 어떤 변수가 스코프에 있는지 확인하는 스코프 체인(scope chain) 이란 개념이 생겼습니다.현재 스코프 체인에 있는 모든 변수는 스코프에 있는 것이며, 숨겨지지 않았다면 접근할 수 있습니다."
}, 

{
"id": "-javascript-2020-05-05-javascript120",
"title": "7.4 블록 스코프",
"author": null,
"tags": [],
"url": "/javascript/2020/05/05/javascript120/",
"date": "2020-05-05",
"content": "let 과 const는 식별자를 블록 스코프에서 선언합니다.5장에서 블록은 문을 중괄호로 묶은 것이라고 설명했습니다.블록 스코프는 그 블록의 스코프에서만 보이는 식별자를 의미합니다.console.log('before block');{\tconsole.log('inside block');\tconst x = 3;\tconsole.log(x); // 3}console.log(`outside block; x=${x}`); // ReferenceError: x는 정의되지 않았습니다.앞의 예제에서는 독립 블록을 사용했습니다.블록은 보통 if나 for 같은 제어문의 일부분으로 쓰이지만, 블록 그 자체로도 유효한 문법입니다.x는 블록 안에서 정의됐고, 블록을 나가는 즉시 x도 스코프 밖으로 사라지므로 정의되지 않은 것으로 간주합니다.  NOTE_4장에서 독립 블록에 현실적인 쓸모는 별로 없다고 언급한 것을 기억할 겁니다.이 장에서 독립 블록을 써서 스코프를 관리하는 방법을 소개하겠지만, 필요한 경우는 드뭅니다.이 장에서 독립 블록을 사용하는 이유는 스코프에 대해 이해하기 쉬워서입니다."
}, 

{
"id": "-issue-2020-05-05-issue07",
"title": "info 레이아웃, slideUp, slideDown",
"author": null,
"tags": [],
"url": "/issue/2020/05/05/issue07/",
"date": "2020-05-05",
"content": "&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;테스트&lt;/title&gt;    &lt;style&gt;        * {            margin: 0;            padding: 0;            border: 0;            box-sizing: border-box        }        ul, li {            list-style: none;        }        .list_ul {            display: flex;            flex-wrap: wrap;        }        .list_box {            flex: 0 0 auto;            width: calc(20% - 20px);            min-width: 0;            margin-right: 25px;        }        .thum {            padding: 10px;            background-color: #ddd;            text-align: center;            cursor: pointer;        }        .info_box {            position: relative;            display: none;            width: calc(500% + 100px);            padding: 10px;            background-color: #aaa;            text-align: center;        }        .list_box:nth-child(5n) {            margin-right: 0;        }        .list_box:nth-child(5n+2) .info_box {            left: calc(-100% - 25px);        }        .list_box:nth-child(5n+3) .info_box {            left: calc(-200% - 50px);        }        .list_box:nth-child(5n+4) .info_box {            left: calc(-300% - 75px);        }        .list_box:nth-child(5n+5) .info_box {            left: calc(-400% - 100px);        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class=\"list_ul\"&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일1&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일1 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일2&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일2 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일3&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일3 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일4&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일4 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일5&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일5 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일6&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일6 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일7&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일7 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일8&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일8 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일9&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일9 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일10&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일10 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일11&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일11 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일12&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일12 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일13&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일13 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일14&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일14 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일15&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일15 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일16&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일16 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일17&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일17 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일18&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일18 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일19&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일19 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일20&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일20 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일21&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일21 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일22&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일22 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일23&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일23 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일24&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일24 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일25&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일25 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일26&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일26 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일27&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일27 설명&lt;/div&gt;    &lt;/li&gt;    &lt;li class=\"list_box\"&gt;        &lt;div class=\"thum\"&gt;썸네일28&lt;/div&gt;        &lt;div class=\"info_box\"&gt;썸네일28 설명&lt;/div&gt;    &lt;/li&gt;&lt;/ul&gt;&lt;script src=\"jquery-1.12.4.min.js\"&gt;&lt;/script&gt;&lt;script&gt;    (function (win, $) {        $('.list_ul').on('click', '.thum', function () {            if (!$(this).next().is(':visible')) {                $(this).next().slideDown();            } else {                $(this).next().slideUp();            }            $(this).parent().siblings().find('.info_box').slideUp();        })    })(window, window.jQuery)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"
}, 

{
"id": "-issue-2020-05-04-issue06",
"title": "gulpfile.babel.js - php, browsersync, spritesmith-multi, 11",
"author": null,
"tags": [],
"url": "/issue/2020/05/04/issue06/",
"date": "2020-05-04",
"content": ".babelrc{  \"presets\": [ \"@babel/preset-env\" ]}config.json{  \"browser\": {    \"root\": \"../\",    \"port\" : 90,    \"livereload\": true,    \"browser\": \"chrome\"  },  \"path\": {    \"html\": {      \"src\": \"../html/*.{html, php}\"    },    \"sass\": {      \"src\": \"../sass/**/*.{scss, sass}\",      \"dest\": \"../css/\"    },    \"sprites\": {      \"src\": \"../img/order_v3/sprites/**/*.png\",      \"dest\": \"../img/order_v3/sprites/*.png\"    }  }}gulpfile.babel.js// 엄격 모드\"use strict\";// 모듈 호출import {src, dest, series, parallel, watch} from 'gulp';import sass from 'gulp-sass';import spritesmith from 'gulp.spritesmith-multi';import postcss from 'gulp-postcss';import autoprefixer from 'autoprefixer';import imagemin from 'gulp-imagemin';import buffer from 'vinyl-buffer';import config from './config.json';import merge from 'merge-stream';import compressCss from 'gulp-clean-css';import del from 'del';// 일반 서버// import connect from 'gulp-connect';// import open from 'gulp-open';// php 서버import phpConnect from 'gulp-connect-php';import browserSync from 'browser-sync';// 이미지 삭제const cleanImg = () =&gt; {    return del(config.path.sprites.dest, { force: true })}const sprites = () =&gt; {    const opts = {        spritesmith: function (options, sprite, icons){            options.imgName = `sp_${sprite}.png`;            options.imgPath =  `../../img/order_v3/sprites/${options.imgName}`;            options.cssName = `_sp_${sprite}.scss`;            options.cssTemplate = './scss-minimal.handlebars';            options.cssSpritesheetName = sprite;            options.padding = 10;            options.retinaSrcFilter = null;            options.retinaImgName = null;            options.retinaImgPath = null;            options.cssVarMap = function(sp) {                sp.name = `sp_${sprite}_${sp.name}`;            };            return options;        }    };    const spriteData = src(config.path.sprites.src)        .pipe(spritesmith(opts))        .on('error', function (err) {            console.log(err)        })    const imgStream = spriteData.img        .pipe(buffer())        .pipe(imagemin())        .pipe(dest(\"../img/order_v3/sprites/\"));    const cssStream = spriteData.css        .pipe(dest('../sass/order/sprites/'));    return merge(imgStream, cssStream);}const sassBuild = () =&gt; {    return src(config.path.sass.src, { sourcemaps: true })        .pipe(sass({            outputStyle: 'compact'        })).on('error', sass.logError)        .pipe(postcss([autoprefixer()]))        .pipe(compressCss({ format: 'keep-breaks' }))        .pipe(dest(config.path.sass.dest, {sourcemaps: true}))}const browserSyncReload = (done) =&gt; {    browserSync.reload();    done();}// const htmlReload = () =&gt; {//     return src(config.path.html.src)//         .pipe(dest(config.path.html.src))//         .pipe(browserSync.reload(//             {stream: true}//         ))//         .pipe(connect.reload())// }// 일반 서버// const server = () =&gt; {//     return connect.server({//         root: config.browser.root,//         port: config.browser.port,//         livereload: config.browser.livereload//     })// }//// const browserOpen = () =&gt; {//     const options = {//         uri : `http://localhost:${config.browser.port}`,//         app: config.browser.browser//     };//     return src(config.browser.root)//         .pipe(open(options));// }//// const fileWatch = () =&gt; {//     watch(config.path.html.src, htmlReload)//     watch(config.path.spriteImg.src, series(cleanImg, sprites))//     watch(config.path.sass.src, series(cleanCss, sassBuild));// }// exports.default = series(parallel(cleanImg, cleanCss), sprites, sassBuild, parallel(server, browserOpen, fileWatch));// php 서버const phpServer = () =&gt; {    phpConnect.server({        // browsersync가 프록시를 통해 연결되는 독립형 PHP 서버        // 웹 서버에 액세스하려는 포트입니다. 포트가 이미 사용 중이면 작업이 실패합니다.        port: 80,        keepalive: true,        base: \"../\"    }, function () {        browserSync({            // php 서버 포트번호와 동일해야됩니다.            proxy: 'localhost:80'        })    })    watch(\"../html/**/*.html\", browserSyncReload)    watch([        config.path.sprites.src,        `!${config.path.sprites.dest}`    ], series(cleanImg, sprites, sassBuild, browserSyncReload))    watch([        \"../sass/**/**/*\",        \"!../sass/**/sprites/*\"    ], series(sassBuild, browserSyncReload))}exports.default = series(cleanImg, sprites, sassBuild, phpServer);exports.build = series(cleanImg, sprites, sassBuild);package.json{  \"name\": \"\",  \"version\": \"0.0.0\",  \"description\": \"\",  \"main\": \"index.js\",  \"scripts\": {    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"  },  \"repository\": {    \"type\": \"git\",    \"url\": \"\"  },  \"author\": \"\",  \"license\": \"MIT\",  \"homepage\": \"\",  \"devDependencies\": {    \"@babel/core\": \"^7.9.0\",    \"@babel/preset-env\": \"^7.9.5\",    \"@babel/register\": \"^7.9.0\",    \"autoprefixer\": \"^9.7.6\",    \"browser-sync\": \"^2.26.7\",    \"del\": \"^5.1.0\",    \"gulp\": \"^4.0.2\",    \"gulp-clean-css\": \"^4.3.0\",    \"gulp-connect\": \"^5.7.0\",    \"gulp-connect-php\": \"^1.0.3\",    \"gulp-imagemin\": \"^7.1.0\",    \"gulp-open\": \"^3.0.1\",    \"gulp-postcss\": \"^8.0.0\",    \"gulp-sass\": \"^4.1.0\",    \"gulp.spritesmith-multi\": \"^3.1.0\",    \"merge-stream\": \"^2.0.0\",    \"node-sass\": \"^4.14.0\",    \"vinyl-buffer\": \"^1.0.1\"  },  \"browserslist\": [    \"last 2 versions\",    \"ie &gt;= 9\",    \"iOS &gt;= 6\",    \"Android &gt;= 4\"  ],  \"dependencies\": {}}scss-minimal.handlebarshandlebars"
}, 

{
"id": "-javascript-2020-05-04-javascript119",
"title": "7.3 전역 스코프",
"author": null,
"tags": [],
"url": "/javascript/2020/05/04/javascript119/",
"date": "2020-05-04",
"content": "스코프는 계층적이며 트리의 맨 아래에는 바탕이 되는 무언가가 있어야 합니다.즉, 프로그램을 시작할 때 암시적으로 주어지는 스코프가 필요합니다.이 스코프를 전역 스코프라고 합니다.자바스크립트 프로그램을 시작할 때, 즉 어떤 함수도 호출하지 않았을 때 실행 흐름은 전역 스코프에 있습니다.바꿔 말해, 전역 스코프에서 선언한 것은 무엇이든 프로그램의 모든 스코프에서 볼 수 있습니다.전역 스코프에서 선언된 것들을 전역 변수라고 합니다.  역주_ 전역변수원문에서는 globals 라고 표현했습니다.변수와 함수, 객체를 포함해 전역에 있는 모든 것이라는 의미지만, 선언한다는 것은 식별자를 부여한다는 것이고 따라서 변수라 해도 큰 무리는 없을 것 같아 이 책에서는 익숙한 표현인 전역 변수라고 옮깁니다.전역 변수는 아주 안 좋은 평가를 받고 있습니다.프로그래밍 책을 읽다 보면, 전역 변수를 쓰기만 하면 도저히 피할 수 없는 대재앙이 일어날 것처럼 말하고 ㄴ합니다.그러면 전역 변수는 왜 그렇게 나쁜 걸까요?전역 변수가 나쁜 것은 아닙니다.사실 전역 변수는 반드시 써야 합니다.나쁜 것은 전역 스코프를 남용하는 것입니다.전역 스코프에 있는 것이 모든 스코프에서 보인다는 사실은 이미 언급했습니다.따라서 전역 변수는 충분히 생각하고 써야 합니다.현명한 독자라면 이렇게 생각할 겁니다.“아, 그러면 전역 스코프에 함수 하나만 만들면 되겠군. 그러면 전역 변수를 하나로 줄일 수 있을 거야!”애석하지만, 문제가 발생하는 위치를 한 단계 내렸을 뿐입니다.특정 함수의 스코프에서 선언한 것은 그 함수에서 호출한 어디에서든 다 보입니다.전역 스코프보다 상황이 좋아졌다고 말하기는 어렵습니다.핵심은 이겁니다.전역 스코프에 몇 가지가 존재하는 건 피할 수 없을뿐더러 그 자체가 그렇게 나쁜 것도 아닙니다.피해야 하는 건 전역 스코프에 의존하는 겁니다.간단한 예를 하나 들어봅시다.사용자 정보를 보관하는 프로그램이 있습니다.이 프로그램은 사용자의 이름과 나이를 보관하며, 그 정보를 사용하는 몇몇 함수가 있습니다.우선, 전역 변수를 사용하는 방법이 있습니다.let name = \"Irena\"; // 전역let age = 25; // 전역function greet() {\tconsole.log(`Hello, ${name}!`);}function getBirthYear() {\treturn new Date().getFullYear() - age;}이 방법의 문제는 함수가 호출하는 컨텍스트(스코프)에 대단히 의존적이라는 겁니다.어떤 함수든, 프로그램 어디에서든 상관없이 name 값을 (의도적으로든, 실수로든) 바꿀 수 있습니다.또한 name과 age는 흔한 이름이므로 다른 곳에서 다른 이유로 사용할 가능성도 큽니다.great와 getBirthYear는 전역 변수에 의존하므로, 프로그램의 다른 부분에서 name과 age를 정확히 사용한다고 가정하고 있는 겁니다.그보다는 사용자 정보를 단일 객체에 보관하는 방법이 더 낫습니다.let user = {\tname = \"Irena\",\tage = 25,}function greet() {\tconsole.log(`Hello, ${user.name}!`);}function getBirthYear() {\treturn new Date().getFullYear() - user.age;}이 예제에서는 name과 age를 없애고 대신 user를 써서 전역 스코프의 식별자 숫자를 겨우 하나 줄였을 뿐이지만, 사용자에 관한 정보를 10가지나 100가지 보관한다고 상상해 보십시오.하지만 개선의 여지는 더 남아있습니다.함수 greet과 getBirthYear는 여전히 전역 user에 의존하며, 이 객체는 어디서든 수정할 수 있습니다.이 함수들을 고쳐서 전역 스코프에 의존하지 않게 만들어 봅시다.function greet(user) {\tconsole.log(`Hello, ${user.name}!`);}function getBirthYear(user) {\treturn new Date().getFullYear() - user.age;}이제 이 함수들은 모든 스코프에서 호출할 수 있고, 명시적으로 user를 전달받습니다(모듈과 객체지향 프로그래밍을 배우면 더 나은 방법이 있습니다).사실 프로그램이 이렇게 단순하다면, 전역 변수를 쓰더라도 문제가 생길 소지는 전혀 없습니다.하지만 프로그램이 수천, 수만 행이 되어 모든 스코프를 기억하고 관리할 수 없게 된다면 전역 스코프에 의존하지 않는 것이 정말 중요해집니다."
}, 

{
"id": "-javascript-2020-05-03-javascript118",
"title": "7.2 정적 스코프와 동적 스코프",
"author": null,
"tags": [],
"url": "/javascript/2020/05/03/javascript118/",
"date": "2020-05-03",
"content": "프로그램의 소스 코드를 살펴보는 건 프로그램의 정적(어휘적, lexical) 구조를 살펴보는 겁니다.하지만 프로그램을 실제 실행하면 실행 흐름은 이곳 저곳으로 움직입니다.함수 두 개를 쓰는 프로그램이 있다고 합시다.function f1() {\tconsole.log('one');}function f2() {\tconsole.log('two');}f2();f1();f2();정적으로 보면 이 프로그램은 단순히 위에서 아래로 읽어내리는 문의 연속입니다.하지만 이 프로그램을 실행하면 실행 흐름은 읽는 순서와 다릅니다.f1이 f2보다 먼저 정의됐지만, f2의 함수 바디가 실행된 다음 f1으로, 다시 f2로 넘어갑니다.자바스크립트의 스코프는 정적입니다.소스 코드만 봐도 변수가 스코프에 있는지 판단할 수 있다는 뜻입니다.다만, 소스 코드만 봐도 즉시 스코프를 분명히 알 수 있다는 뜻은 아닙니다.이 장에서 꼼꼼히 살피다 보면 스코프를 판단할 수 있는 몇몇 예제를 찾아볼 수 있을 겁니다.정적 스코프는 어떤 변수가 함수 스코프 안에 있는지 함수를 정의할 때 알 수 있다는 뜻입니다.호출할 때 알 수 있는 것은 아닙니다.다음 예제를 보십시오.const x = 3;function f() {\tconsole.log(x);\tconsole.log(y);}{\t// 새 스코프\tconst y = 5;\tf();}변수 x는 함수 f를 정의할 때 존재하지만, y는 그렇지 않습니다.y는 다른 스코프에 존재합니다.다른 스코프에서 y를 선언하고 그 스코프에서 f를 호출하더라도, f를 호출하면 x는 그 바디 안의 스코프에 있지만 y는 그렇지 않습니다.이것이 정적 스코프입니다.함수 f는 자신이 정의될 때 접근할 수 있었던 식별자에는 여전히 접근할 수 있지만, 호출할 때 스코프에 있는 식별자에 접근할 수는 없습니다.자바스크립트의 정적 스코프는 전역 스코프(global scope)와 블록 스코프(block scope), 함수 스코프(function scope)에 적용됩니다."
}, 

{
"id": "-javascript-2020-05-03-javascript117",
"title": "7.1 스코프와 존재",
"author": null,
"tags": [],
"url": "/javascript/2020/05/03/javascript117/",
"date": "2020-05-03",
"content": "변수가 존재하지 않으면 그 변수는 스코프 안에 ‘있지 않음’을 직관적으로 알 수 있습니다.즉, 아직 선언하지 않은 변수나 함수가 종료되면서 존재하지 않게 된 변수는 분명 스코프 안에 ‘있지 않습니다.’그건 무슨 뜻일까요?변수가 스코프 안에 있지 않다면, 그 변수는 존재하지 않는다는 말일까요?꼭 그런 건 아닙니다.그리고 여기서 스코프와 존재를 반드시 구별해야 합니다.가시성(visibility) 이라고도 불리는 스코프는 프로그램의 현재 실행 중인 부분, 즉 실행 컨텍스트(execution context) 에서 현재 보이고 접근할 수 있는 식별자들을 말합니다.반면 존재한다는 말은 그 식별자가 메모리가 할당된(예약된) 무언가를 가리키고 있다는 뜻입니다.‘존재하지만 스코프 안에는 없는’ 변수의 예를 곧 살펴보겠습니다.무언가가 더는 존재하지 않는다고 해도 자바스크립트는 메모리를 바로 회수하지는 않습니다.그것을 계속 유지할 필요가 없다고 표시해 두면, 주기적으로 일어나는 가비지 콜렉션(garbage collection) 프로세스에서 메모리를 회수합니다.자바스크립트의 가비지 콜렉션은 자동으로 일어나며, CPU나 메모리를 심하게 혹사하는 애플리케이션이 아니라면 프로그래머가 신경 쓸 필요는 없습니다."
}, 

{
"id": "-javascript-2020-05-03-javascript116",
"title": "7. 스코프",
"author": null,
"tags": [],
"url": "/javascript/2020/05/03/javascript116/",
"date": "2020-05-03",
"content": "스코프(scope)는 변수와 상수, 매개변수가 언제 어디서 정의되는지 결정합니다.우리는 이미 스코프의 개념을 조금 접했습니다.함수 매개변수가 함수 바디 안에서만 존재하는 것도 스코프의 한 예입니다.다음 예제를 보십시오.function f(x) {\treturn x + 3;}f(5); // 8x; // ReferenceError: x is not definedx가 아주 잠시나마 존재했었으니 x + 3을 계산할 수 있었습니다.하지만 함수 바디를 벗어나면 x는 존재하지 않는 것처럼 보입니다.따라서 우리는 x의 스코프가 함수 f라고 말합니다.변수의 스코프가 어떤 함수라고 말할 때는, 함수를 실제 호출할 때까지는 함수 바디의 정해진 매개변수(formal argument) 가 존재하지 않음을 반드시 상기해야 합니다.함수는 여러 번 호출할 수 있습니다.그리고 함수를 호출할 때마다 매개변수가 나타나고, 함수가 제어권을 반환하면 스코프 밖으로 사라집니다.변수와 상수는 만들기 전에는 존재하지 않는다는 것도 확실합니다.즉, let이나 const로 선언하기 전에는 스코프 안에 존재하지 않습니다(var는 특수한 경우로 7장 후반에 설명합니다).  NOTE_일부 언어는 선언(declaration)과 정의(definition) 을 명확히 구분합니다.일반적으로 변수를 선언한다는 것은 식별자를 주어서 그 존재를 알리는 겁니다.반면 정의는 선언과 함께 값도 부여하는 것을 말합니다.자바스크립트에서는 모든 변수를 선언하는 동시에 값이 주어지므로(명시적으로 정하지 않으면 undefined가 암시적으로 주어지므로) 두 용어를 구분하지 않습니다."
}, 

{
"id": "-javascript-2020-05-03-javascript115",
"title": "6.9 요약",
"author": null,
"tags": [],
"url": "/javascript/2020/05/03/javascript115/",
"date": "2020-05-03",
"content": "함수는 자바스크립트에서 핵심적인 부분입니다.함수는 단지 코드를 모듈화하는 역할만 있는 건 아닙니다.함수는 아주 강력한 논리적 단위가 될 수 있습니다.이 장에서는 함수가 어떻게 동작하는지에 치중했습니다.좀 무미건조하지만 중요한 내용입니다.이 장에서 배운 내용을 기초로, 함수가 얼마나 다재다능한지 하나씩 살펴볼 겁니다."
}, 

{
"id": "-javascript-2020-05-03-javascript114",
"title": "6.8 call 과 apply, bind",
"author": null,
"tags": [],
"url": "/javascript/2020/05/03/javascript114/",
"date": "2020-05-03",
"content": "this를 사용하는 일반적인 방법은 이미 살펴봤습니다.다른 객체지향 언어에서도 this를 이런 식으로 사용합니다.자바스크립트에서는 일반적인 방법 외에도, 함수를 어디서, 어떻게 호출했느냐와 관계없이 this가 무엇인지 지정할 수 있습니다.먼저 call 메서드부터 시작합시다.callcall 메서드는 모든 함수에서 사용할 수 있으며, this를 특정 값으로 지정할 수 있습니다.const bruce = { name: \"Bruce\" };const madeline = { name: \"Madeline\" };// 이 함수는 어떤 객체에도 연결되지 않았지만 this를 사용합니다.function greet() {\treturn `Hello, I'm ${this.name}!`;}greet(); // \"Hello, I'm undefined!\" - this는 어디에도 묶이지 않았습니다.greet.call(bruce); // \"Hello, I'm Bruce!\" - this는 bruce입니다.greet.call(madeline); // \"Hello, I'm Madeline!\" - this는 madeline입니다.함수를 호출하면서 call을 사용하고 this로 사용할 객체를 넘기면 해당 함수가 주어진 객체의 메서드인 것처럼 사용할 수 있습니다.call의 첫 번째 매개변수는 this로 사용할 값이고, 매개변수가 더 있으면 그 매개변수는 호출하는 함수로 전달됩니다.function update(birthYear, occupation) {\tthis.birthYear = birthYear;\tthis.occupation = occupation;}update.call(bruce, 1949, 'singer');\t// bruce는 이제 { name: \"Bruce\", birthYear: 1949, occupation: \"singer\" } 입니다.update.call(madeline, 1942, 'actress');\t// madeline은 이제 { name: 'Madeline', birthYear: 1942, occupation: \"actress\" } 입니다.applyapply는 함수 매개변수를 처리하는 방법을 제외하면 call과 완전히 같습니다.call은 일반적인 함수와 마찬가지로 매개변수를 직접 받지만, apply는 매개변수를 배열로 받습니다.update.apply(bruce, [1955, \"actor\"]);\t// bruce는 이제 { name: \"Bruce\", birthYear: 1955, occupation: \"actor\" } 입니다.update.apply(madeline, [1918, \"writer\"]);\t// madeline은 이제 { name: \"Madeline\", birthYear: 1918, occupation: \"writer\" } 입니다.apply는 배열 요소를 함수 매개변수로 사용해야 할 때 유용합니다.apply를 설명할 때 흔히 사용하는 예제는 배열의 최솟값과 최댓값을 구하는 겁니다.자바스크립트의 내장 함수인 Math.min과 Math.max는 매개변수를 받아 그중 최솟값과 최댓값을 각각 반환합니다.apply를 사용하면 기존 배열을 이들 함수에 바로 넘길 수 있습니다.const arr = [2, 3, -5, 15, 7];Math.min.apply(null, arr); // -5Math.max.apply(null, arr); // 15this의 값에 null을 쓴 이유는 Math.min과 Math.max가 this와 관계없이 동작하기 때문입니다.즉, 무엇을 넘기든 관계없습니다.ES6의 확산 연산자(…) 를 사용해도 apply와 같은 결과를 얻을 수 있습니다.update 메서드는 this 값이 중요하므로 call을 사용해야 하지만, Math.min과 Math.max는 this값이 무엇이든 관계없으므로 확산 연산자를 그대로 사용할 수 있습니다.const newBruce = [1940, \"martial artist\"];update.call(bruce, ...newBruce); // apply(bruce, newBruce)와 같습니다.Math.min(...arr);  // -5Math.max(...arr);  // 15bindthis 의 값을 바꿀 수 있는 마지막 함수는 bind입니다.bind를 사용하면 함수의 this 값을 영구히 바꿀 수 있습니다.update 메서드를 이리저리 옮기면서도 호출할 때 this 값은 항상 bruce가 되게끔, call이나 apply, 다른 bind와 함께 호출하더라도 this값이 bruce가 되도록 하려면 bind를 사용합니다.const updateBruce = update.bind(bruce);updateBruce(1904, \"actor\");\t// bruce는 이제 { name: \"Bruce\", birthYear: 1904, occupation: \"actor\" } 입니다.updateBruce.call(madeline, 1274, \"king\");\t// bruce는 이제 { name: \"Bruce\", birthYear: 1274, occupation: \"king\" } 입니다.\t// madeline은 변하지 않았습니다.bind는 함수의 동작을 영구적으로 바꾸므로 찾기 어려운 버그의 원인이 될 수 있습니다.bind를 사용한 함수는 call이나 apply, 다른 bind와 함께 사용할 수 없는 거나 마찬가지입니다.함수를 여기저기서 call이나 apply로 호출해야 하는데, this 값이 그에 맞춰 바뀌어야 하는 경우를 상상해 보십시오.이럴 때는 bind를 사용하면 문제가 생깁니다.bind를 쓰지 말라고 권하는 것은 아닙니다.bind는 매우 유용하지만, 함수의 this가 어디에 묶이는지 정확히 파악하고 사용해야 합니다.bind에 매개변수를 넘기면 항상 그 매개변수를 받으면서 호출되는 새 함수를 만드는 효과가 있습니다.예를 들어 bruce가 태어난 해를 항상 1949로 고정하지만, 직업은 자유롭게 바꿀 수 있는 업데이트 함수를 만들고 싶다면 다음과 같이 하면 됩니다.const updateBruce1949 = update.bind(bruce, 1949);updateBruce1949(\"singer, songwriter\");\t// bruce는 이제 { name: \"Bruce\", birthYear: 1949, occupation: \"singer, songwriter\" } 입니다."
}, 

{
"id": "-javascript-2020-05-03-javascript113",
"title": "6.7 화살표 표기법",
"author": null,
"tags": [],
"url": "/javascript/2020/05/03/javascript113/",
"date": "2020-05-03",
"content": "ES6에서 새로 만든 화살표 표기법(arrow notation) 도 환영받는 문법입니다.화살표 표기법은 간단히 말해 function이라는 단어와 중괄호 숫자를 줄이려고 고안된 단축 문법입니다.중요한 차이가 하나 있는데, 곧 설명하겠습니다.화살표 함수에는 세 가지 단축 문법이 있습니다.  역주_화살표 함수는 이 책 전반에 걸쳐 자주 사용되므로, ES6 문법을 처음 접하는 독자분이라면 읽고만 넘어가지 말고 충분히 연습해서 익숙해져야 이후 내용을 이해하기 편리합니다.화살표 함수는 단순히 function 키워드와 괄호 등을 생략하는 단축 문법에 그치지 않으며, 최근 주목받고 있는 함수형 프로그래밍을 자바스크립트에 도입하는 중요한 열쇠이기도 합니다.  function을 생략해도 됩니다.  함수에 매개변수가 단 하나뿐이라면 (())도 생략할 수 있습니다.  함수 바디가 표현식 하나라면 중괄호와 return문도 생략할 수 있습니다.화살표 함수는 항상 익명입니다.화살표 함수도 변수에 할당할 수는 있지만, function 키워드 처럼 이름 붙은 함수를 만들 수는 없습니다.다음 예제를 보십시오.이들 표현식은 모두 동등한 한 쌍입니다.const f1 = function() { return \"hello!\"; }// 또는const f1 = () =&gt; \"hello!\";const f2 = function(name) { return `Hello, ${name}!`; }// 또는const f2 = name =&gt; `Hello, ${name}!`;const f3 = function(a, b) { return a + b; }// 또는const f3 = (a, b) =&gt; a + b;이들 예제는 다분히 인위적입니다.이름 붙은 함수가 필요하다면 그냥 일반적인 함수 선언을 사용하면 됩니다.화살표 함수는 익명 함수를 만들어 다른 곳에 전달하려 할 때 가장 유용하며, 이에 대해서는 8장에서 살펴보겠습니다.화살표 함수에는 일반적인 함수와 중요한 차이가 있습니다.this 가 다른 변수와 마찬가지로, 정적으로(lexically) 묶인다는 겁니다.이 장에서 만들었던 greetBackwards 예제를 고쳐 써 봅시다.화살표 함수를 사용하면 내부 함수 안에서 this를 사용할 수 있습니다.const o = {\tname: 'Julie',\tgreetBackwards: function() {\t\tconst getReverseName = () =&gt; {\t\t\tlet nameBackwards = '';\t\t\tfor(let i=this.name.length-1; i&gt;=0; i--){\t\t\t\tnameBackwards += this.name[i];\t\t\t}\t\t\treturn nameBackwards;\t\t};\t\treturn `${getReverseName()} si eman ym, olleH`;\t},};o.greetBackwards();화살표 함수에는 일반적인 함수와 다른 점이 두 가지 더 있습니다.화살표 함수는 (9장에서 설명할) 객체 생성자로 사용할 수 없고, arguemnts 변수도 사용할 수 없습니다.하지만 ES6에서 확산 연산자가 생겼으니 arguments 변수는 필요가 없긴 합니다."
}, 

{
"id": "-javascript-2020-05-03-javascript112",
"title": "6.6 함수 표현식과 익명 함수",
"author": null,
"tags": [],
"url": "/javascript/2020/05/03/javascript112/",
"date": "2020-05-03",
"content": "지금까지는 함수 선언만 봤습니다.함수를 선언하면 함수에 바디와 식별자가 모두 주어집니다.자바스크립트는 익명 함수(anonymous function) 도 지원합니다.익명 함수에서는 함수에 식별자가 주어지지 않습니다.함수에 식별자가 없다는 말을 보고 어리둥절했을 수도 있습니다.식별자가 없다면, 도대체 어떻게 호출해야 할까요?답은 함수 표현식(function expression) 에 있습니다.우리는 표현식이 값이 되고, 함수 역시 값이 된다는 것을 알고 있습니다.함수 표현식은 함수를 선언하는 한 가지 방법일 뿐이며, 그 함수가 익명이 될 수도 있을 뿐입니다.함수 표현식은 식별자에 할당할 수도 있고 즉시 호출할 수도 있습니다.  즉시 호출하는 함수 표현식(IIFE, immediately invoked function expression)이라고 부릅니다.7장에서 설명합니다.함수 표현식은 함수 이름을 생략할 수 있다는 점을 제외하면 함수 선언과 문법적으로 완전히 같습니다.함수 표현식을 쓰고 그 결과를 변수에 할당하는 예제를 봅시다.이 예제는 결과적으로 함수 선언과 동등합니다.const f = function() {\t// ...};결과는 여태까지 했던 대로 함수를 선언한 것과 마찬가지입니다.식별자 f가 이 함수를 가리킵니다.일반적인 함수 선언과 마찬가지로 f()로 이 함수를 호출할 수 있습니다.차이점은 먼저 함수 표현식으로 익명 함수를 만들고 그 함수를 변수에 할당했다는 겁니다.익명 함수는 어디든지 쓸 수 있습니다.다른 함수나 메서드의 매개변수로 넘길 수도 있고, 객체의 함수 프로퍼티가 될 수도 있습니다.책 전체에 걸쳐 이런 방법을 사용할 겁니다.앞에서 함수 표현식에서는 함수 이름을 생략할 수 있다고 했습니다.그러면 함수에 이름을 정하고 다시 변수에 할당하면 어떻게 될까요?그리고 그렇게 한다면 이유는 무엇일까요?다음 예제를 보십시오.const g = function() {\t// ...}이런 식으로 함수를 만들면 이름 g에 우선순위가 있습니다.그리고 함수 바깥에서 함수에 접근할 때는 g를 써야 하며, f로 접근하려 하면 변수가 정의되지 않았다는 에러가 생깁니다.그렇다면 왜 이런 방법을 사용하는 걸까요?함수 안에서 자신을 호출할 때 (재귀(recursion) 라고 합니다) 이런 방식이 필요할 수 있습니다.다음 예제를 보십시오.const g = function f (stop) {\tif(stop) console.log('f stopped');\tf(true);};g(false);함수 안에서는 f를 써서 자기 자신을 참조하고, 함수 바깥에서는 g를 써서 함수를 호출합니다.함수에 두 가지 이름을 붙이는 것이 좋을 이유는 없지만, 여기서 그렇게 한 이유는 이름 붙은 함수 표현식이 어떻게 동작하는지 명확하게 설명하기 위해서입니다.함수 선언과 함수 표현식이 완전히 똑같이 보인다면, 자바스크립트는 둘을 어떻게 구분할까요?차이가 있기는 한 걸까요?답은 컨텍스트입니다.함수 선언이 표현식으로 사용됐다면 그건 함수 표현식입니다.표현식으로 사용되지 않았다면 함수 선언입니다.이 차이는 다분히 이론적이며, 일반적으로는 이 차이에 대해 생각할 필요가 없습니다.나중에 호출할 생각으로 함수를 만든다면 함수 선언을 사용하면 되고, 다른 곳에 할당하거나 다른 함수에 넘길 목적으로 함수를 만든다면 함수 표현식을 사용하면 됩니다.복잡하게 생각할 필요는 없습니다."
}, 

{
"id": "-javascript-2020-05-03-javascript111",
"title": "6.5 this 키워드",
"author": null,
"tags": [],
"url": "/javascript/2020/05/03/javascript111/",
"date": "2020-05-03",
"content": "함수 바디 안에는 특별한 읽기 전용 값인 this가 있습니다.this는 일반적으로 객체지향 프로그래밍 개념에 밀접한 연관이 있습니다.객체지향 프로그래밍에 대해서는 9장에서 더 설명합니다.자바스크립트에서는 객체지향 프로그래밍 말고도 this를 사용하는 여러 가지 방법이 있습니다.일반적으로 this는 객체의 프로퍼티인 함수에서 의미가 있습니다.메서드를 호출하면 this는 호출한 메서드를 소유하는 객체가 됩니다.const o = {\tname: \"Wallace\",\tspeak() { return `My name is ${this.name}!`; },}o.speak() 를 호출하면 this는 o에 묶입니다.o.speak(); // \"My name is Wallace!\"this는 함수를 어떻게 선언했느냐가 아니라 어떻게 호출했느냐에 따라 달라진다는 것을 이해해야 합니다.즉, this가 o에 묶인 이유는 speak가 o의 프로퍼티여서가 아니라, o에서 speak를 호출했기 때문입니다.같은 함수를 변수에 할당하면 어떻게 되는지 봅시다.const speak = o.speak;speak === o.speak; // true; 두 변수는 같은 함수를 가리킵니다.speak(); // \"My name is undefined!\"함수를 이렇게 호출하면 자바스크립트는 이 함수가 어디에 속하는지 알 수 없으므로 this는 undefined에 묶입니다.  NOTE_앞의 예제에서 한 것처럼 함수의 this가 어디에 묶이는지 명확히 알 수 없도록 호출했을 때 this를 결정하는 방법은 매우 복잡합니다.스트릭트 모드인지 아닌지에 따라 다르고,함수를 어디에서 호출했느냐에 따라서도 다릅니다.이런 상황은 피하는 것이 최선이므로 자세한 내용은 의도적으로 생략했습니다.더 알고 싶다면 코드 포메팅에 관한 MDN 문서를 보십시오메서드라는 용어는 원래 객체지향 프로그래밍의 개념이지만, 이 책에서는 객체의 프로퍼티이며 o.speak() 처럼 객체 인스턴스에서 호출할 의도로 만든 함수라는 뜻으로 사용합니다.함수에서 this를 사용하지 않으면 어디에서 선언했든 관계없이 함수라고 부르겠습니다.중첩된 함수 안에서 this를 사용하려다 보면 혼란스러울 때가 많습니다.다음 예제를 보십시오.이 예제에는 메서드 안에 보조 함수가 있습니다.const o = {\tname: 'Julie',\tgreetBackwards: function(){\t\tfunction getReverseName() {\t\t\tlet nameBackwards = '';\t\t\tfor(let i = this.name.length-1; i&gt;=0; i--){\t\t\t\tnameBackwards += this.name[i];\t\t\t}\t\t\treturn nameBackwards;\t\t}\t\treturn `${getReverseName()} si eman ym ,olleH`;\t},};o.greetBackwards();앞의 예제에서는 이름을 거꾸로 쓰고자 중첩된 함수 getReverseName 를 사용했습니다.하지만 getReverseName은 의도한 대로 동작하지 않습니다.o.greetBackwards() 를 호출하는 시점에서 자바스크립트는 this를 의도한 대로 o에 연결하지만, greetBackwards 안에서 getReverseName 을 호출하면 this는 o가 아닌 다른 것에 묶입니다.  스트릭트 모드인지 아닌지에 따라 this는 undefined가 되기도 하고 전역 객체에 묶이기도 합니다.앞서 말했듯, 이런 상황은 피하는 것이 최선이므로 자세한 내용은 설명하지 않습니다.이런 문제를 해결하기 위해 널리 사용하는 방법은 다른 변수에 this를 할당하는 겁니다.const o = {\tname: 'Julie',\tgreetBackwards: function() {\t\tconst self = this;\t\tfunction getReverseName() {\t\t\tlet nameBackwards = '';\t\t\tfor(let i = self.name.length-1; i&gt;=0; i--) {\t\t\t\tnameBackwards += self.name[i];\t\t\t}\t\t\treturn nameBackwards;\t\t}\t\treturn `${getReverseName()} si eman ym, olleH`;\t},};o.greetBackwards();이 방법은 널리 쓰이는 방법이며, this를 self나 that에 할당하는 코드를 많이 보게 될겁니다.이 장 후반에서 설명할 화살표 함수를 써도 이 문제를 해결할 수 있습니다."
}, 

{
"id": "-javascript-2020-05-03-javascript110",
"title": "6.4 객체의 프로퍼티인 함수",
"author": null,
"tags": [],
"url": "/javascript/2020/05/03/javascript110/",
"date": "2020-05-03",
"content": "객체의 프로퍼티인 함수를 메서드(method) 라고 불러서 일반적인 함수와 구별합니다.함수와 메서드 사이에는 다른 차이도 있는데 그건 나중에 다시 설명합니다.함수를 다른 객체에 추가할 수 있다는 것은 3장에서 이미 봤습니다.객체 리터럴에서도 메서드를 추가할 수 있습니다.const o = {\tname: \"Wallace\",  // 원시 값 프로퍼티\tbark: function () { return \"Woof!\"; }, // 함수 프로퍼티(메서드)}ES6에서는 간편하게 메서드를 추가할 수 있는 문법이 새로 생겼습니다.다음 예제는 이전 예제와 동일합니다.const o = {\tname: \"Wallace\",  // 원시 값 프로퍼티\tbark() { return \"Woof!\"; }, // 함수 프로퍼티(메서드)}"
}, 

{
"id": "-javascript-2020-05-03-javascript109",
"title": "6.3.3 매개변수 기본값",
"author": null,
"tags": [],
"url": "/javascript/2020/05/03/javascript109/",
"date": "2020-05-03",
"content": "ES6에서는 매개변수에 기본값(default value) 을 지정하는 기능도 추가됐습니다.일반적으로 매개변수에 값을 제공하지 않으면 undefined가 값으로 할당됩니다.ES6에서는 기본값을 지정할 수 있습니다.다음 예제를 보십시오.function f(a, b=\"default\", c=3) {\treturn `${a} - ${b} - ${c}`;}f(5, 6, 7); // \"5 - 6 - 7\"f(5, 6); // \"5 - 6 - 3\"f(5); // \"5 - default - 3\"f(); // \"undefined - default - 3\""
}, 

{
"id": "-javascript-2020-05-03-javascript108",
"title": "6.3.2 매개변수 해체",
"author": null,
"tags": [],
"url": "/javascript/2020/05/03/javascript108/",
"date": "2020-05-03",
"content": "5장에서 해체 할당에 관해 배웠듯, 매개변수도 해체할 수 있습니다(매개변수는 여러 면에서 변수와 거의 비슷합니다).객체를 변수로 해체하는 예제를 봅시다.function getSentence({ subject, verb, object }) {\treturn `${subject} ${verb} ${object}`;}const o = {\tsubject: \"I\",\tverb: \"love\",\tobject: \"JavaScript\",};getSentence(o); // \"I love JavaScript\"해체 할당과 마찬가지로 프로퍼티 이름은 반드시 유효한 식별자여야 하고, 들어오는 객체에 해당 프로퍼티가 없는 변수는 undefined를 할당받습니다.배열 역시 해체할 수 있습니다.function getSentence([ subject, verb, object ]) {\treturn `${subject} ${verb} ${object}`;}const arr = [ \"I\", \"love\", \"JavaScript\" ];getSentence(arr); // \"I love JavaScript\"확산(스프레드) 연산자(…)를 써서 남는 매개변수를 이용할 수 있습니다.function addPrefix(prefix, ...words) {\t// 나중에 더 좋은 방법을 배웁니다.\tconst prefixedWords = [];\tfor(let i=0; i&lt;words.length; i++) {\t\tprefixedWords[i] = prefix + words[i];\t}\treturn prefixedWords;}addPrefix(\"con\",  \"verse\", \"vex\"); // [\"converse\", \"convex\"]함수를 선언할 때 확산 연산자는 반드시 마지막 매개변수여야 합니다.확산 연산자 뒤에 다른 매개변수가 있으면 자바스크립트는 전달된 값 중 어디까지를 확산 매개변수에 할당해야 하는지 판단할 수 없어서 에러를 일으킵니다.  NOTE_ES5에서는 함수 바디 안에서만 존재하는 특별한 변수 arguments 를 사용해서 확산과 비슷한 일을 할 수 있습니다.arguments는 실제 배열이 아니라 배열 비슷한 객체이므로 특별 취급하거나 일반적인 객체로 변환해야 했습니다.ES6에서는 확산 매개변수를 사용해 이런 약점을 해결했으므로 arguments보다 확산 매개변수를 쓰는 것이 좋습니다."
}, 

{
"id": "-javascript-2020-05-01-javascript107",
"title": "6.3.1 매개변수가 함수를 결정하는가?",
"author": null,
"tags": [],
"url": "/javascript/2020/05/01/javascript107/",
"date": "2020-05-01",
"content": "여러 언어에서 함수의 시그니처(signature) 에는 매개변수가 포함됩니다.예를 들어 C 언어에서 매개변수 없는 함수 f()는 매개변수가 하나인 f(x)와 다르고, f(x)는 매개변수가 두 개인 함수 f(x, y)와 다릅니다.자바스크립트에는 그런 차이가 없습니다.함수 f가 있다면 호출할 때 매개변수를 한 개 전달하든 열 개 전달하든 같은 함수를 호출하는 겁니다.다시 말해, 어떤 함수를 호출하든 그 함수에서 정해진 매개변수 숫자와 관계없이 몇 개의 매개변수를 전달해도 됩니다.정해진 매개변수에 값을 제공하지 않으면 암시적으로 undefined가 할당됩니다.function f(x) {\treturn `in f: x = ${x}`;}f(); // \"in f: x = undefined\"함수에 정해진 매개변수보다 더 많은 매개변수를 전달하는 경우는 이 장 후반에서 살펴볼 겁니다."
}, 

{
"id": "-issue-2020-04-29-issue05",
"title": "https://dive.hyundaicard.com/web/culture/culture.hdc 페이지 코드분석",
"author": null,
"tags": [],
"url": "/issue/2020/04/29/issue05/",
"date": "2020-04-29",
"content": "현대카드 페이지 특징  hdc 확장자 파일  nodejs 상에서 쓰이는 문법들이 쓰임ex) done(), ejs templatedone() 이 nodejs 에 내재되어있는 메소드같은데, commonJS 안에 정의된건지 아니면 그냥 nodejs에 내장되어있는건지는 모르겠음  ajax로 달력데이터를 불러옴아래는 일반 브라우저(로컬)에서 ejs 템플릿이 작동하는지에 대한 테스트.vue나 react 처럼 ejs도 ejs 템플릿을 컴파일 할 수 있는 js와 같이 배포하면 일반 로컬 서버에서도 작동한다는 것을 알 수 있었습니다.아래 예시들에 사용된 스크립트  js/ejs.min.js  js/commonCult.js  js/commonDive.js  js/common.js  js/swiper.min.js  js/jquery.selectbox-0.2.js  js/jquery.keyframes.js  js/jquery-1.12.4.min.js  js/jquery.outback.js  js/jquery.cookie.js아래 예제는 commonCult.js의 150번째 줄( formSubmit: $.outback.formSubmit,)을 주석처리하고 봐야됩니다.&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=\"js/jquery-1.12.4.min.js\"&gt;&lt;/script&gt;    &lt;script src=\"js/ejs.min.js\"&gt;&lt;/script&gt;    &lt;script src=\"js/commonCult.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"ejs\"&gt;&lt;/div&gt;&lt;button class=\"btn-search\" onclick=\"clickBtnSearch();\"&gt;&lt;i class=\"ico-search\"&gt;검색 열기&lt;/i&gt;&lt;/button&gt;&lt;script&gt;    function clickBtnSearch(){        var objHTML = $('#tplHotSearchEjs').html();        var objemplate = cult.ejsCompile(objHTML);        $('#ejs').html(objemplate);    }&lt;/script&gt;&lt;script id=\"tplHotSearchEjs\" type=\"ejs/template\"&gt;    &lt;@ if ( 3 &gt; 0 ) { @&gt;    &lt;ul class=\"search-popula-list\"&gt;        &lt;@ for ( var i = 0; i &lt; 13; i++ ) { @&gt;        &lt;li&gt;&lt;a href=\"#\"&gt;&lt;@-'dd'@&gt;&lt;/a&gt;&lt;/li&gt;        &lt;@ } @&gt;    &lt;/ul&gt;    &lt;@ } @&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;두번째 예시&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/swiper/css/swiper.css\"&gt;    &lt;link rel=\"stylesheet\" href=\"css/common.css\"&gt;    &lt;link rel=\"stylesheet\" href=\"css/content.css\"&gt;    &lt;link rel=\"stylesheet\" href=\"css/style.css\"&gt;    &lt;script src=\"js/jquery-1.12.4.min.js\"&gt;&lt;/script&gt;    &lt;script src=\"js/jquery.keyframes.js\"&gt;&lt;/script&gt;    &lt;script src=\"js/jquery.selectbox-0.2.js\"&gt;&lt;/script&gt;    &lt;script src=\"js/swiper.min.js\"&gt;&lt;/script&gt;    &lt;script src=\"js/common.js\"&gt;&lt;/script&gt;    &lt;script src=\"js/jquery.outback.js\"&gt;&lt;/script&gt;    &lt;script src=\"js/ejs.min.js\"&gt;&lt;/script&gt;    &lt;script src=\"js/jquery.cookie.js\"&gt;&lt;/script&gt;    &lt;script src=\"js/commonDive.js\"&gt;&lt;/script&gt;    &lt;script src=\"js/commonCult.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"wrap\" class=\"wWhatson\"&gt;  &lt;!-- what's on 페이지 : wWhatson --&gt;    &lt;!-- #wContainer --&gt;    &lt;div id=\"wContainer\" class=\"whatson-wrap ob-page ob-page-theme-a\" data-role=\"page\" tabindex=\"0\"&gt;        &lt;section class=\"calendar-wrap\"&gt;            &lt;div class=\"inner-wrap tab-wrap\"&gt;                &lt;!-- 캘린더 뷰 --&gt;                &lt;div id=\"calenderView\" class=\"tab-cont active\"&gt; &lt;!-- 초기 활성화 active --&gt;                    &lt;h3 class=\"sr-only\"&gt;캘린더 리스트&lt;/h3&gt;                    &lt;section class=\"box-section\"&gt;                        &lt;div id=\"monthlyTable\" class=\"monthly-table\"&gt;                            &lt;div class=\"table-type-calendar\" id=\"cultureCalendar_View\"&gt;                            &lt;/div&gt;                            &lt;button class=\"btn-today\" id=\"calendar_today\"&gt;Reset&lt;/button&gt;                        &lt;/div&gt;                        &lt;div class=\"monthly-whatson\" id=\"cultureCalendar_NowWrap\"&gt;                            &lt;!-- now --&gt;                            &lt;section class=\"now-wrap\" id=\"cultureCalendar_Now\"&gt;                            &lt;/section&gt;                            &lt;!-- now// --&gt;                            &lt;!-- Upcoming --&gt;                            &lt;section class=\"invisual upcoming-wrap\" id=\"cultureCalendar_UpcomingWrap\" style=\"display: none\"&gt;                            &lt;/section&gt;                            &lt;!-- Upcoming// --&gt;                            &lt;!-- past --&gt;                            &lt;section class=\"invisual past-wrap\" id=\"cultureCalendar_PastWrap\" style=\"display: none\"&gt;                            &lt;/section&gt;                            &lt;!-- past// --&gt;                        &lt;/div&gt;                    &lt;/section&gt;                &lt;/div&gt;                &lt;!-- 캘린더 뷰// --&gt;                &lt;!-- 필터 뷰 --&gt;                &lt;div id=\"filterView\" class=\"tab-cont\"&gt;                    &lt;h3 class=\"sr-only\"&gt;캘린더 필터링&lt;/h3&gt;                    &lt;div class=\"calendar-filter\"&gt;                        &lt;div class=\"select-space\"&gt;                            &lt;button class=\"btn-sel-space all\" onclick=\"spaceOpen();\"&gt;&lt;span&gt;전체&lt;/span&gt;&lt;/button&gt;                            &lt;!-- 지역공간 선택 팝업 --&gt;                            &lt;div id=\"spacePopup\" class=\"space-popup\"&gt;                                &lt;h3 class=\"sr-only\"&gt;공간 선택&lt;/h3&gt;                                &lt;ul class=\"select-list\"&gt;                                    &lt;li class=\"list-all\"&gt;                                        &lt;span class=\"radioTy-ty1\"&gt;&lt;input type=\"radio\" id=\"filter-all\" name=\"filterPlaceSpace\" value=\"\" checked=\"checked\" /&gt;&lt;label for=\"filter-all\"&gt;전체&lt;/label&gt;&lt;/span&gt;                                    &lt;/li&gt;                                    &lt;li class=\"list-space\"&gt;                                        &lt;span class=\"radioTy-ty1\"&gt;&lt;input type=\"radio\" id=\"filter-place-1\" name=\"filterPlaceSpace\" value=\"A\" /&gt;&lt;label for=\"filter-place-1\"&gt;이태원&lt;/label&gt;&lt;/span&gt;                                        &lt;span class=\"radioTy-ty1\"&gt;&lt;input type=\"radio\" id=\"filter-place-2\" name=\"filterPlaceSpace\" value=\"B\" /&gt;&lt;label for=\"filter-place-2\"&gt;청담&lt;/label&gt;&lt;/span&gt;                                        &lt;span class=\"radioTy-ty1\"&gt;&lt;input type=\"radio\" id=\"filter-place-3\" name=\"filterPlaceSpace\" value=\"C\" /&gt;&lt;label for=\"filter-place-3\"&gt;가회&lt;/label&gt;&lt;/span&gt;                                    &lt;/li&gt;                                    &lt;li class=\"list-culture\"&gt;                                        &lt;span class=\"radioTy-ty1\"&gt;&lt;input type=\"radio\" id=\"filter-space-1\" name=\"filterPlaceSpace\" value=\"1\" /&gt;&lt;label for=\"filter-space-1\"&gt;디자인 라이브러리&lt;/label&gt;&lt;/span&gt;                                        &lt;span class=\"radioTy-ty1\"&gt;&lt;input type=\"radio\" id=\"filter-space-2\" name=\"filterPlaceSpace\" value=\"2\" /&gt;&lt;label for=\"filter-space-2\"&gt;트래블 라이브러리 &lt;/label&gt;&lt;/span&gt;                                        &lt;span class=\"radioTy-ty1\"&gt;&lt;input type=\"radio\" id=\"filter-space-3\" name=\"filterPlaceSpace\" value=\"3\" /&gt;&lt;label for=\"filter-space-3\"&gt;뮤직 라이브러리&lt;/label&gt;&lt;/span&gt;                                        &lt;span class=\"radioTy-ty1\"&gt;&lt;input type=\"radio\" id=\"filter-space-4\" name=\"filterPlaceSpace\" value=\"4\" /&gt;&lt;label for=\"filter-space-4\"&gt;쿠킹 라이브러리&lt;/label&gt;&lt;/span&gt;                                        &lt;span class=\"radioTy-ty1\"&gt;&lt;input type=\"radio\" id=\"filter-space-5\" name=\"filterPlaceSpace\" value=\"7\" /&gt;&lt;label for=\"filter-space-5\"&gt;언더스테이지&lt;/label&gt;&lt;/span&gt;                                        &lt;span class=\"radioTy-ty1\"&gt;&lt;input type=\"radio\" id=\"filter-space-6\" name=\"filterPlaceSpace\" value=\"6\" /&gt;&lt;label for=\"filter-space-6\"&gt;바이닐앤플라스틱&lt;/label&gt;&lt;/span&gt;                                        &lt;span class=\"radioTy-ty1\"&gt;&lt;input type=\"radio\" id=\"filter-space-7\" name=\"filterPlaceSpace\" value=\"5\" /&gt;&lt;label for=\"filter-space-7\"&gt;스토리지&lt;/label&gt;&lt;/span&gt;                                        &lt;span class=\"radioTy-ty1\"&gt;&lt;input type=\"radio\" id=\"filter-space-8\" name=\"filterPlaceSpace\" value=\"8\" /&gt;&lt;label for=\"filter-space-8\"&gt;슈퍼콘서트&lt;/label&gt;&lt;/span&gt;                                        &lt;span class=\"radioTy-ty1\"&gt;&lt;input type=\"radio\" id=\"filter-space-11\" name=\"filterPlaceSpace\" value=\"11\" /&gt;&lt;label for=\"filter-space-11\"&gt;다빈치모텔&lt;/label&gt;&lt;/span&gt;                                        &lt;span class=\"radioTy-ty1\"&gt;&lt;input type=\"radio\" id=\"filter-space-9\" name=\"filterPlaceSpace\" value=\"9\" /&gt;&lt;label for=\"filter-space-9\"&gt;컬처프로젝트&lt;/label&gt;&lt;/span&gt;                                    &lt;/li&gt;                                &lt;/ul&gt;                            &lt;/div&gt;                            &lt;!-- 지역공간 선택 팝업// --&gt;                            &lt;!-- 큐레이터 셀렉트 박스 --&gt;                            &lt;div class=\"select-curator\" style=\"display:none;\"&gt;                                &lt;select id=\"curatorList\"&gt;                                    &lt;option value=\"\"&gt;전체&lt;/option&gt;                                &lt;/select&gt;                            &lt;/div&gt;                            &lt;!-- 큐레이터 셀렉트 박스 //--&gt;                        &lt;/div&gt;                        &lt;div class=\"select-ticket\"&gt;                            &lt;span class=\"checkboxTy\"&gt;                                &lt;input type=\"checkbox\" id=\"ticket\" name=\"reservationYN\" value=\"Y\" /&gt;&lt;label for=\"ticket\"&gt;&lt;span&gt;예매/예약 필요&lt;/span&gt;&lt;/label&gt;                            &lt;/span&gt;                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;!-- 전체 --&gt;                    &lt;section class=\"box-section now-wrap\" id=\"cultureList_one\" style=\"display: none;\"&gt;                        &lt;div class=\"invisual\" id=\"cultureList_ViewList\"&gt;                        &lt;/div&gt;                    &lt;/section&gt;                    &lt;!-- 전체// --&gt;                    &lt;section class=\"box-section now-wrap\" id=\"cultureList_many\" style=\"display: none;\"&gt;                        &lt;div class=\"invisual space1\" id=\"cultureList_ViewList_A\"&gt;                        &lt;/div&gt;                        &lt;div class=\"invisual space2\" id=\"cultureList_ViewList_B\"&gt;                        &lt;/div&gt;                        &lt;div class=\"invisual space3\" id=\"cultureList_ViewList_C\"&gt;                        &lt;/div&gt;                    &lt;/section&gt;                &lt;/div&gt;                &lt;!-- 필터 뷰// --&gt;            &lt;/div&gt;            &lt;script&gt;                //테이블 행사,이벤트 날짜 선택 시                var calendarClickEvent = [                    '.calendar-table .showday a',                    '.calendar-table .eventday a'                ];                $(document).on('click', calendarClickEvent.join(','), function(e) {                    //e.preventDefault();                    //선택일 표시                    $('.calendar-wrap td').removeClass('selected');                    $(this).parent().addClass('selected');                });                //$(calendarClickEvent.join(',')).calendarClickOn();                //달력 today 초기화 버튼                //*공간 선택 시                function spaceOpen(){                    var $target = $('#spacePopup');                    if($('.btn-sel-space').hasClass('all')){                        $('.select-ticket input').prop('checked',false); //check 해제                        $('#spacePopup .radioTy-ty1').eq(0).find('input').prop('checked',true);//선택값 체크                        $('.btn-sel-space').removeClass('all');                    }                    if($target.hasClass('show')){                        $target.removeClass('show').attr('tabindex','0');//공간 팝업 Open                    }else{                        $target.addClass('show').attr('tabindex','-1').focus();//공간 팝업 Open                    }                }                function spaceClose(){                    $('#spacePopup').removeClass('show'); //팝업 Close                }                $('#spacePopup .radioTy-ty1').on('click', function () {                    spaceClose(); //팝업 Close                    $('.btn-sel-space span').text($(this).find('label').text());//선택 텍스트 변경                    $('#spacePopup input').prop('checked',false); //check 해제                    $(this).find('input').prop('checked',true); //선택 체크                    //언더스테이지 선택 시 큐레이터 리스트 노출                    $('.select-curator').hide();                    if( $(this).find('input').val() === '7' ){                        $('.select-curator').show();                    }                });                //*/                //*view mode 클릭 시                //*/            &lt;/script&gt;        &lt;/section&gt;    &lt;/div&gt;    &lt;!-- #wContainer// --&gt;&lt;/div&gt;&lt;!-- #wrap// --&gt;&lt;script id=\"calendarTemplate\" type=\"ejs/template\"&gt;    &lt;h3 class=\"sr-only\"&gt;캘린더 테이블&lt;/h3&gt;    &lt;div class=\"getSeat-area\"&gt;        &lt;span class=\"date\"&gt;&lt;@=yearFormat@&gt;. &lt;@=monthFormat@&gt;&lt;/span&gt;        &lt;@        var view_prevMonth = isEmpty_nvl(prevMonth);        var view_nextMonth = isEmpty_nvl(nextMonth);        if(view_prevMonth != ''){        @&gt;        &lt;a href=\"javascript:fnCultureCalendarClick('&lt;@=view_prevMonth@&gt;');\" class=\"btn-prev\"&gt;&lt;span class=\"sr-only\"&gt;이전 달&lt;/span&gt;&lt;/a&gt;        &lt;@        }else{        @&gt;        &lt;a href=\"javascript:;\" class=\"btn-prev off\"&gt;&lt;span class=\"sr-only\"&gt;이전 달&lt;/span&gt;&lt;/a&gt;        &lt;@        }        @&gt;        &lt;@        if(view_nextMonth != ''){        @&gt;        &lt;a href=\"javascript:fnCultureCalendarClick('&lt;@=view_nextMonth@&gt;');\" class=\"btn-next\"&gt;&lt;span class=\"sr-only\"&gt;다음 달&lt;/span&gt;&lt;/a&gt;        &lt;@        }else{        @&gt;        &lt;a href=\"javascript:;\" class=\"btn-next off\"&gt;&lt;span class=\"sr-only\"&gt;다음 달&lt;/span&gt;&lt;/a&gt;        &lt;@        }        @&gt;    &lt;/div&gt;    &lt;div class=\"program-calendar\"&gt;        &lt;div class=\"calendar-table\"&gt;            &lt;table summary=\"이 표는 월일로 구성된 달력표입니다.\"&gt;                &lt;colgroup&gt;                    &lt;col width=\"56px\"&gt;                    &lt;col width=\"56px\"&gt;                    &lt;col width=\"56px\"&gt;                    &lt;col width=\"56px\"&gt;                    &lt;col width=\"56px\"&gt;                    &lt;col width=\"56px\"&gt;                    &lt;col width=\"56px\"&gt;                &lt;/colgroup&gt;                &lt;thead class=\"calendar-head\"&gt;                &lt;tr&gt;                    &lt;th&gt;Mon&lt;/th&gt;                    &lt;th&gt;Tue&lt;/th&gt;                    &lt;th&gt;Wed&lt;/th&gt;                    &lt;th&gt;Thu&lt;/th&gt;                    &lt;th&gt;Fri&lt;/th&gt;                    &lt;th&gt;Sat&lt;/th&gt;                    &lt;th class=\"sun\"&gt;Sun&lt;/th&gt;                &lt;/tr&gt;                &lt;/thead&gt;                &lt;tbody class=\"calendar-body\"&gt;                &lt;tr&gt;                    &lt;@                    var first_check;                    var last_check;                    if(list.length &gt; 0){                    first_check = list[0].chkCnt;                    last_check = list[list.length-1].chkCnt;                    }                    @&gt;                    &lt;@                    if(first_check &gt; 1){                    for ( var i = 1; i &lt;= (Number(first_check) - 1); i++ ) {                    @&gt;                    &lt;td&gt;&amp;nbsp;&lt;/td&gt;                    &lt;@                    }                    }                    @&gt;                    &lt;@                    var class_today;                    var class_showday;                    var class_eventday;                    var curCalDt;                    for ( var i = 0; i &lt; list.length; i++ ) {                    var item = list[i];                    // 초기화                    class_today = \"\";                    class_showday = \"\";                    class_eventday = \"\";                    if(item.calDt == today){                    class_today = \" today\";                    }                    if(item.calDt == item.targetDt ){                    class_eventday = \" eventday\";       //개별 이벤트                    }                    if(item.calDt == item.targetDtTerm ){                    class_showday = \" showday\";         //기간 행사일                    }                    var calDay_format = fnStringDateFormat(item.calDt, \"-\");                    if(curCalDt != item.calDt ){                    @&gt;                    &lt;td class=\"&lt;@-class_today@&gt;&lt;@-class_showday@&gt;&lt;@-class_eventday@&gt;\"&gt;                        &lt;@                        if(item.calDt == item.targetDt || item.calDt == item.targetDtTerm){                        @&gt;                        &lt;a href=\"javascript:fnCultureCalendarDayClick('&lt;@-item.calDt@&gt;');\" data-checkday=\"&lt;@-calDay_format@&gt;\"&gt;&lt;span&gt;&lt;@-item.calDay@&gt;&lt;/span&gt;&lt;/a&gt;                        &lt;@                        }else{                        @&gt;                        &lt;a href=\"#none\" data-checkday=\"&lt;@-calDay_format@&gt;\"&gt;&lt;span&gt;&lt;@-item.calDay@&gt;&lt;/span&gt;&lt;/a&gt;                        &lt;@                        }                        @&gt;                        &lt;@                        if(item.chkCnt == \"7\" &amp;&amp; i + 1 &lt; list.length){                        @&gt;                &lt;/tr&gt;&lt;tr&gt;                    &lt;@                    }                    curCalDt = item.calDt;                    }                    }                    if(last_check &lt; 7){                    for ( var i = (Number(last_check) + 1); i &lt;= 7; i++ ) {                    @&gt;                    &lt;td&gt;&amp;nbsp;&lt;/td&gt;                    &lt;@                    }                    }                    @&gt;                &lt;/tr&gt;                &lt;/tbody&gt;            &lt;/table&gt;        &lt;/div&gt;&lt;/script&gt;&lt;script id=\"calendarDayTemplate\" type=\"ejs/template\"&gt;    &lt;h2 class=\"section-title\"&gt;        Now    &lt;/h2&gt;    &lt;@ if ( list != null &amp;&amp; list.length &gt; 0 ) {@&gt;    &lt;ul class=\"view-type-list\"&gt;        &lt;@        for ( var i = 0; i &lt; list.length; i++ ) {        var item = list[i];        var title = cult.brTagToSpace(item.contentTitle);        var titleSub = isEmpty_nvl(item.contentSubTitle);        if(titleSub != ''){        titleSub = titleSub.replace(/&lt;br\\s*[\\/]?&gt;/gi, ' ');        }        var libraryName_kr = setSpaceValueName(item.libraryId);        var libraryPlace = setSpaceValuePlace(item.libraryId);        var reservationTypeView = \"\";        var reservationType = item.reservationType;        if(reservationType == 'A1' ){        reservationTypeView = \"예약\";        }else if(reservationType == 'A2' ){        reservationTypeView = \"예매\";        }        @&gt;        &lt;li class=\"view-item\"&gt;            &lt;a href=\"javascript:;\" class=\"item\" data-content-id=\"&lt;@-item.contentId@&gt;\" data-content-type=\"&lt;@-item.contentType@&gt;\"&gt;                &lt;div class=\"cnt\"&gt;                    &lt;p class=\"timeline\"&gt;                        &lt;span class=\"day\"&gt;                            &lt;@                            if(item.contentEventStartDate != '' &amp;&amp; item.contentEventEndDate != ''){                                if(item.contentEventStartDate == item.contentEventEndDate){                            @&gt;                                &lt;@-item.contentEventStartDateFormat@&gt;(&lt;@-item.contentEventStartDateFormatDayOfTheWeek@&gt;)                            &lt;@                                }else{                            @&gt;                                &lt;@-item.contentEventStartDateFormat@&gt;(&lt;@-item.contentEventStartDateFormatDayOfTheWeek@&gt;) ~ &lt;@-item.contentEventEndDateFormat@&gt;(&lt;@-item.contentEventEndDateFormatDayOfTheWeek@&gt;)                            &lt;@                                }                            }else{                            @&gt;                                &lt;@-item.startDateFormat@&gt;(&lt;@-item.startDateFormatDayOfTheWeek@&gt;)                            &lt;@                            }                            @&gt;                        &lt;/span&gt;                    &lt;/p&gt;                    &lt;p class=\"tit\"&gt;&lt;@-title@&gt;&lt;/p&gt;                    &lt;p class=\"summary\"&gt;&lt;@-titleSub@&gt;&lt;/p&gt;                    &lt;p class=\"badge\"&gt;                        &lt;span class=\"category\"&gt;                            &lt;@-libraryName_kr@&gt;                        &lt;/span&gt;                        &lt;@                        if(reservationTypeView != ''){                        @&gt;                        &lt;span class=\"status\"&gt;                            &lt;@-reservationTypeView@&gt;                        &lt;/span&gt;                        &lt;@                        }                        @&gt;                    &lt;/p&gt;                &lt;/div&gt;                &lt;@                if(libraryPlace != ''){                @&gt;                &lt;span class=\"place\"&gt;                    &lt;@-libraryPlace@&gt;                &lt;/span&gt;                &lt;@                }                @&gt;                &lt;div class=\"thum\"&gt;                    &lt;img src=\"&lt;@-item.thumbnailImageUrl@&gt;\" alt=\"\" onerror=\"this.src=window.projectPath + '/resources/diveWeb/images/default/img_thnl_default.jpg'\" /&gt;                &lt;/div&gt;            &lt;/a&gt;        &lt;/li&gt;        &lt;@ } @&gt;    &lt;/ul&gt;    &lt;@ }else{ @&gt;    &lt;div class=\"list-empty\"&gt;        선택하신 날짜에는 프로그램이 없습니다.    &lt;/div&gt;    &lt;@ } @&gt;&lt;/script&gt;&lt;script id=\"cultureCalendarUpcomingTemplate\" type=\"ejs/template\"&gt;    &lt;@ if ( list != null &amp;&amp; list.length &gt; 0 ) {@&gt;    &lt;h2 class=\"section-title\"&gt;        Upcoming    &lt;/h2&gt;    &lt;ul class=\"view-type-list\" id=\"cultureCalendar_Upcoming_area\"&gt;    &lt;/ul&gt;    &lt;div class=\"btn-area\" id=\"cultureCalendar_Upcoming_more\"&gt;        &lt;button class=\"btn-more\" id=\"cultureCalendar_Upcoming_moreButton\"&gt;&lt;span&gt;더 보기&lt;/span&gt;&lt;/button&gt;    &lt;/div&gt;    &lt;@ } @&gt;&lt;/script&gt;&lt;script id=\"cultureCalendarPagingUpcomingTemplate\" type=\"ejs/template\"&gt;    &lt;@    for ( var i = 0; i &lt; list.length; i++ ) {    var item = list[i];    var title = cult.brTagToSpace(item.contentTitle);    var titleSub = isEmpty_nvl(item.contentSubTitle);    if(titleSub != ''){    titleSub = titleSub.replace(/&lt;br\\s*[\\/]?&gt;/gi, ' ');    }    var libraryName_kr = setSpaceValueName(item.libraryId);    var libraryPlace = setSpaceValuePlace(item.libraryId);    var reservationTypeView = \"\";    var reservationType = item.reservationType;    if(reservationType == 'A1' ){    reservationTypeView = \"예약\";    }else if(reservationType == 'A2' ){    reservationTypeView = \"예매\";    }    @&gt;    &lt;li class=\"view-item\"&gt;        &lt;a href=\"javascript:;\" class=\"item\" data-content-id=\"&lt;@-item.contentId@&gt;\" data-content-type=\"&lt;@-item.contentType@&gt;\"&gt;            &lt;div class=\"cnt\"&gt;                &lt;p class=\"timeline\"&gt;                    &lt;span class=\"day\"&gt;                        &lt;@                        if(item.contentEventStartDate != '' &amp;&amp; item.contentEventEndDate != ''){                            if(item.contentEventStartDate == item.contentEventEndDate){                        @&gt;                            &lt;@-item.contentEventStartDateFormat@&gt;(&lt;@-item.contentEventStartDateFormatDayOfTheWeek@&gt;)                        &lt;@                            }else{                        @&gt;                            &lt;@-item.contentEventStartDateFormat@&gt;(&lt;@-item.contentEventStartDateFormatDayOfTheWeek@&gt;) ~ &lt;@-item.contentEventEndDateFormat@&gt;(&lt;@-item.contentEventEndDateFormatDayOfTheWeek@&gt;)                        &lt;@                            }                        }else{                        @&gt;                            &lt;@-item.startDateFormat@&gt;(&lt;@-item.startDateFormatDayOfTheWeek@&gt;)                        &lt;@                        }                        @&gt;                    &lt;/span&gt;                &lt;/p&gt;                &lt;p class=\"tit\"&gt;&lt;@-title@&gt;&lt;/p&gt;                &lt;p class=\"summary\"&gt;&lt;@-titleSub@&gt;&lt;/p&gt;                &lt;p class=\"badge\"&gt;                    &lt;span class=\"category\"&gt;                        &lt;@-libraryName_kr@&gt;                    &lt;/span&gt;                    &lt;@                    if(reservationTypeView != ''){                    @&gt;                    &lt;span class=\"status\"&gt;                        &lt;@-reservationTypeView@&gt;                    &lt;/span&gt;                    &lt;@                    }                    @&gt;                &lt;/p&gt;            &lt;/div&gt;            &lt;@            if(libraryPlace != ''){            @&gt;            &lt;span class=\"place\"&gt;                &lt;@-libraryPlace@&gt;            &lt;/span&gt;            &lt;@            }            @&gt;            &lt;div class=\"thum\"&gt;                &lt;img src=\"&lt;@-item.thumbnailImageUrl@&gt;\" alt=\"\" onerror=\"this.src=window.projectPath + '/resources/diveWeb/images/default/img_thnl_default.jpg'\" /&gt;            &lt;/div&gt;        &lt;/a&gt;    &lt;/li&gt;    &lt;@ } @&gt;&lt;/script&gt;&lt;script id=\"cultureCalendarPastTemplate\" type=\"ejs/template\"&gt;    &lt;@ if ( list != null &amp;&amp; list.length &gt; 0 ) {@&gt;    &lt;h2 class=\"section-title\"&gt;        Past    &lt;/h2&gt;    &lt;ul class=\"view-type-list\" id=\"cultureCalendar_Past_area\"&gt;    &lt;/ul&gt;    &lt;div class=\"btn-area\" id=\"cultureCalendar_Past_more\"&gt;        &lt;button class=\"btn-more\" id=\"cultureCalendar_Past_moreButton\"&gt;&lt;span&gt;더 보기&lt;/span&gt;&lt;/button&gt;    &lt;/div&gt;    &lt;@ } @&gt;&lt;/script&gt;&lt;script id=\"cultureCalendarPagingPastTemplate\" type=\"ejs/template\"&gt;    &lt;@    for ( var i = 0; i &lt; list.length; i++ ) {    var item = list[i];    var title = cult.brTagToSpace(item.contentTitle);    var titleSub = isEmpty_nvl(item.contentSubTitle);    if(titleSub != ''){    titleSub = titleSub.replace(/&lt;br\\s*[\\/]?&gt;/gi, ' ');    }    var libraryName_kr = setSpaceValueName(item.libraryId);    var libraryPlace = setSpaceValuePlace(item.libraryId);    @&gt;    &lt;li class=\"view-item\"&gt;        &lt;a href=\"javascript:;\" class=\"item\" data-content-id=\"&lt;@-item.contentId@&gt;\" data-content-type=\"&lt;@-item.contentType@&gt;\"&gt;            &lt;div class=\"cnt\"&gt;                &lt;p class=\"timeline\"&gt;                    &lt;span class=\"day\"&gt;                        &lt;@                        if(item.contentEventStartDate != '' &amp;&amp; item.contentEventEndDate != ''){                            if(item.contentEventStartDate == item.contentEventEndDate){                        @&gt;                            &lt;@-item.contentEventStartDateFormat@&gt;(&lt;@-item.contentEventStartDateFormatDayOfTheWeek@&gt;)                        &lt;@                            }else{                        @&gt;                            &lt;@-item.contentEventStartDateFormat@&gt;(&lt;@-item.contentEventStartDateFormatDayOfTheWeek@&gt;) ~ &lt;@-item.contentEventEndDateFormat@&gt;(&lt;@-item.contentEventEndDateFormatDayOfTheWeek@&gt;)                        &lt;@                            }                        }else{                        @&gt;                            &lt;@-item.startDateFormat@&gt;(&lt;@-item.startDateFormatDayOfTheWeek@&gt;)                        &lt;@                        }                        @&gt;                    &lt;/span&gt;                &lt;/p&gt;                &lt;p class=\"tit\"&gt;&lt;@-title@&gt;&lt;/p&gt;                &lt;p class=\"summary\"&gt;&lt;@-titleSub@&gt;&lt;/p&gt;                &lt;p class=\"badge\"&gt;                    &lt;span class=\"category\"&gt;                        &lt;@-libraryName_kr@&gt;                    &lt;/span&gt;                &lt;/p&gt;            &lt;/div&gt;            &lt;@            if(libraryPlace != ''){            @&gt;            &lt;span class=\"place\"&gt;                &lt;@-libraryPlace@&gt;            &lt;/span&gt;            &lt;@            }            @&gt;            &lt;div class=\"thum\"&gt;                &lt;img src=\"&lt;@-item.thumbnailImageUrl@&gt;\" alt=\"\" onerror=\"this.src=window.projectPath + '/resources/diveWeb/images/default/img_thnl_default.jpg'\" /&gt;            &lt;/div&gt;        &lt;/a&gt;    &lt;/li&gt;    &lt;@ } @&gt;&lt;/script&gt;&lt;script id=\"cultureListViewTemplate\" type=\"ejs/template\"&gt;    &lt;@ if ( list != null &amp;&amp; list.length &gt; 0 ) {@&gt;    &lt;ul class=\"view-type-thumb\" id=\"cultureList_ViewList_area\"&gt;    &lt;/ul&gt;    &lt;div class=\"btn-area\" id=\"cultureList_ViewList_more\"&gt;        &lt;button class=\"btn-more\" id=\"cultureList_ViewList_moreButton\"&gt;&lt;span&gt;더 보기&lt;/span&gt;&lt;/button&gt;    &lt;/div&gt;    &lt;@ } @&gt;&lt;/script&gt;&lt;script id=\"cultureListViewTemplate_A\" type=\"ejs/template\"&gt;    &lt;@ if ( list != null &amp;&amp; list.length &gt; 0 ) {@&gt;    &lt;h4 class=\"section-title\"&gt;이태원&lt;/h4&gt;    &lt;ul class=\"view-type-thumb\" id=\"cultureList_ViewList_area_A\"&gt;    &lt;/ul&gt;    &lt;div class=\"btn-area\" id=\"cultureList_ViewList_more_A\"&gt;        &lt;button class=\"btn-more\" id=\"cultureList_ViewList_moreButton_A\"&gt;&lt;span&gt;더 보기&lt;/span&gt;&lt;/button&gt;    &lt;/div&gt;    &lt;@ } @&gt;&lt;/script&gt;&lt;script id=\"cultureListViewTemplate_B\" type=\"ejs/template\"&gt;    &lt;@ if ( list != null &amp;&amp; list.length &gt; 0 ) {@&gt;    &lt;h4 class=\"section-title\"&gt;청담&lt;/h4&gt;    &lt;ul class=\"view-type-thumb\" id=\"cultureList_ViewList_area_B\"&gt;    &lt;/ul&gt;    &lt;div class=\"btn-area\" id=\"cultureList_ViewList_more_B\"&gt;        &lt;button class=\"btn-more\" id=\"cultureList_ViewList_moreButton_B\"&gt;&lt;span&gt;더 보기&lt;/span&gt;&lt;/button&gt;    &lt;/div&gt;    &lt;@ } @&gt;&lt;/script&gt;&lt;script id=\"cultureListViewTemplate_C\" type=\"ejs/template\"&gt;    &lt;@ if ( list != null &amp;&amp; list.length &gt; 0 ) {@&gt;    &lt;h4 class=\"section-title\"&gt;가회&lt;/h4&gt;    &lt;ul class=\"view-type-thumb\" id=\"cultureList_ViewList_area_C\"&gt;    &lt;/ul&gt;    &lt;div class=\"btn-area\" id=\"cultureList_ViewList_more_C\"&gt;        &lt;button class=\"btn-more\" id=\"cultureList_ViewList_moreButton_C\"&gt;&lt;span&gt;더 보기&lt;/span&gt;&lt;/button&gt;    &lt;/div&gt;    &lt;@ } @&gt;&lt;/script&gt;&lt;script id=\"cultureListPagingViewTemplate\" type=\"ejs/template\"&gt;    &lt;@    for ( var i = 0; i &lt; list.length; i++ ) {    var item = list[i];    var title = cult.brTagToSpace(item.contentTitle);    var titleSub = isEmpty_nvl(item.contentSubTitle);    if(titleSub != ''){    titleSub = titleSub.replace(/&lt;br\\s*[\\/]?&gt;/gi, ' ');    }    var libraryName_kr = setSpaceValueName(item.libraryId);    var reservationTypeView = \"\";    var reservationType = item.reservationType;    if(reservationType == 'A1' ){    reservationTypeView = \"예약\";    }else if(reservationType == 'A2' ){    reservationTypeView = \"예매\";    }    //과거 정보일 경우 해당 내용 삭제    var class_type = \"\";    if(item.typeOrder == 'PAST'){    reservationTypeView = \"종료\";    class_type = \"past\";    }    @&gt;    &lt;li class=\"view-item &lt;@-class_type@&gt;\"&gt;        &lt;a href=\"javascript:;\" class=\"item\" data-content-id=\"&lt;@-item.contentId@&gt;\" data-content-type=\"&lt;@-item.contentType@&gt;\"&gt;            &lt;div class=\"cnt\"&gt;                &lt;p class=\"timeline\"&gt;                        &lt;span class=\"day\"&gt;                            &lt;@                            if(item.contentEventStartDate != '' &amp;&amp; item.contentEventEndDate != ''){                                if(item.contentEventStartDate == item.contentEventEndDate){                            @&gt;                                &lt;@-item.contentEventStartDateFormat@&gt;(&lt;@-item.contentEventStartDateFormatDayOfTheWeek@&gt;)                            &lt;@                                }else{                            @&gt;                                &lt;@-item.contentEventStartDateFormat@&gt;(&lt;@-item.contentEventStartDateFormatDayOfTheWeek@&gt;) ~ &lt;@-item.contentEventEndDateFormat@&gt;(&lt;@-item.contentEventEndDateFormatDayOfTheWeek@&gt;)                            &lt;@                                }                            }else{                            @&gt;                                &lt;@-item.startDateFormat@&gt;(&lt;@-item.startDateFormatDayOfTheWeek@&gt;)                            &lt;@                            }                            @&gt;                        &lt;/span&gt;                &lt;/p&gt;                &lt;p class=\"tit\"&gt;&lt;@-title@&gt;&lt;/p&gt;                &lt;p class=\"summary\"&gt;&lt;@-titleSub@&gt;&lt;/p&gt;                &lt;p class=\"badge\"&gt;                        &lt;span class=\"category\"&gt;                            &lt;@-libraryName_kr@&gt;                        &lt;/span&gt;                    &lt;@                    if(reservationTypeView != ''){                    @&gt;                    &lt;span class=\"status\"&gt;                            &lt;@-reservationTypeView@&gt;                        &lt;/span&gt;                    &lt;@                    }                    @&gt;                &lt;/p&gt;            &lt;/div&gt;            &lt;div class=\"thum\"&gt;                &lt;img src=\"&lt;@-item.thumbnailImageUrl@&gt;\" alt=\"\" onerror=\"this.src=window.projectPath + '/resources/diveWeb/images/default/img_thnl_default.jpg'\" /&gt;            &lt;/div&gt;        &lt;/a&gt;    &lt;/li&gt;    &lt;@ } @&gt;&lt;/script&gt;&lt;script type=\"text/javaScript\" language=\"javascript\"&gt;    (function( $ ) {        $.widget('outback.page', $.outback.basePage, {            options: {                pageCode: '',                showType: \"calendar\",                filterPlaceSpace: \"\",                curatorId: \"\",                curatorList: JSON.parse('[{\"curatorEngName\":\"\",\"curatorImageUrl\":\"\",\"curatorName\":\"타블로\",\"curatorSequenceNo\":\"8\",\"description\":\"\",\"displayOrder\":\"\",\"insertDate\":\"\",\"insertUser\":\"\",\"rnum\":\"\",\"updateDate\":\"\",\"updateUser\":\"\",\"useYN\":\"\"},{\"curatorEngName\":\"\",\"curatorImageUrl\":\"\",\"curatorName\":\"장기하\",\"curatorSequenceNo\":\"7\",\"description\":\"\",\"displayOrder\":\"\",\"insertDate\":\"\",\"insertUser\":\"\",\"rnum\":\"\",\"updateDate\":\"\",\"updateUser\":\"\",\"useYN\":\"\"},{\"curatorEngName\":\"\",\"curatorImageUrl\":\"\",\"curatorName\":\"박정현\",\"curatorSequenceNo\":\"10\",\"description\":\"\",\"displayOrder\":\"\",\"insertDate\":\"\",\"insertUser\":\"\",\"rnum\":\"\",\"updateDate\":\"\",\"updateUser\":\"\",\"useYN\":\"\"},{\"curatorEngName\":\"\",\"curatorImageUrl\":\"\",\"curatorName\":\"윤상\",\"curatorSequenceNo\":\"5\",\"description\":\"\",\"displayOrder\":\"\",\"insertDate\":\"\",\"insertUser\":\"\",\"rnum\":\"\",\"updateDate\":\"\",\"updateUser\":\"\",\"useYN\":\"\"},{\"curatorEngName\":\"\",\"curatorImageUrl\":\"\",\"curatorName\":\"DJ Soulscape\",\"curatorSequenceNo\":\"3\",\"description\":\"\",\"displayOrder\":\"\",\"insertDate\":\"\",\"insertUser\":\"\",\"rnum\":\"\",\"updateDate\":\"\",\"updateUser\":\"\",\"useYN\":\"\"},{\"curatorEngName\":\"\",\"curatorImageUrl\":\"\",\"curatorName\":\"윤종신\",\"curatorSequenceNo\":\"2\",\"description\":\"\",\"displayOrder\":\"\",\"insertDate\":\"\",\"insertUser\":\"\",\"rnum\":\"\",\"updateDate\":\"\",\"updateUser\":\"\",\"useYN\":\"\"},{\"curatorEngName\":\"\",\"curatorImageUrl\":\"\",\"curatorName\":\"현대카드\",\"curatorSequenceNo\":\"11\",\"description\":\"\",\"displayOrder\":\"\",\"insertDate\":\"\",\"insertUser\":\"\",\"rnum\":\"\",\"updateDate\":\"\",\"updateUser\":\"\",\"useYN\":\"\"},{\"curatorEngName\":\"\",\"curatorImageUrl\":\"\",\"curatorName\":\" 크러쉬\",\"curatorSequenceNo\":\"12\",\"description\":\"\",\"displayOrder\":\"\",\"insertDate\":\"\",\"insertUser\":\"\",\"rnum\":\"\",\"updateDate\":\"\",\"updateUser\":\"\",\"useYN\":\"\"},{\"curatorEngName\":\"\",\"curatorImageUrl\":\"\",\"curatorName\":\"유희열\",\"curatorSequenceNo\":\"1\",\"description\":\"\",\"displayOrder\":\"\",\"insertDate\":\"\",\"insertUser\":\"\",\"rnum\":\"\",\"updateDate\":\"\",\"updateUser\":\"\",\"useYN\":\"\"},{\"curatorEngName\":\"\",\"curatorImageUrl\":\"\",\"curatorName\":\"타이거JK &amp; 윤미래\",\"curatorSequenceNo\":\"6\",\"description\":\"\",\"displayOrder\":\"\",\"insertDate\":\"\",\"insertUser\":\"\",\"rnum\":\"\",\"updateDate\":\"\",\"updateUser\":\"\",\"useYN\":\"\"},{\"curatorEngName\":\"\",\"curatorImageUrl\":\"\",\"curatorName\":\"이적\",\"curatorSequenceNo\":\"9\",\"description\":\"\",\"displayOrder\":\"\",\"insertDate\":\"\",\"insertUser\":\"\",\"rnum\":\"\",\"updateDate\":\"\",\"updateUser\":\"\",\"useYN\":\"\"},{\"curatorEngName\":\"\",\"curatorImageUrl\":\"\",\"curatorName\":\" 김수로\",\"curatorSequenceNo\":\"4\",\"description\":\"\",\"displayOrder\":\"\",\"insertDate\":\"\",\"insertUser\":\"\",\"rnum\":\"\",\"updateDate\":\"\",\"updateUser\":\"\",\"useYN\":\"\"}]'),                reservationYN: \"\",                cultureListViewListPage: {pageNo: 1, pageCount: 4},                cultureListViewListPageA: {pageNo: 1, pageCount: 4},                cultureListViewListPageB: {pageNo: 1, pageCount: 4},                cultureListViewListPageC: {pageNo: 1, pageCount: 4},                cultureCalendarUpcomingPage: {pageNo: 1, pageCount: 4},                cultureCalendarPastPage: {pageNo: 1, pageCount: 4},                today: \"20200428\",                today_yearMon : \"202004\",                calendarTodayYn: \"Y\",                moreBtnDoubleClickPrevention: false            },            _create: function() {                this._super();            },            /** init */            _init: function() {                this._super();                this.setEvent();                this.setInitView();           //초기 화면 세팅                this.options.cultureListViewListPage.pageCount = 4;                this.options.cultureListViewListPageA.pageCount = 4;                this.options.cultureListViewListPageB.pageCount = 4;                this.options.cultureListViewListPageC.pageCount = 4;                this.options.cultureCalendarUpcomingPage.pageCount = 4;                this.options.cultureCalendarPastPage.pageCount = 4;            },            setEvent: function() {                this._on({                    'click #showTypeList': 'fnShowTypeList',                    'click #showTypeCalendar': 'fnShowTypeCalendar',                    'click input[name=\"filterPlaceSpace\"]': 'fnSearchCulture',                    'change #curatorList': 'fnSearchCulture',                    'click input[name=\"reservationYN\"]': 'fnSearchCulture',                    'click #cultureList_ViewList_moreButton': 'getCultureListViewList_more',              // (리스트 형식) 더보기                    'click #cultureList_ViewList_moreButton_A': 'getCultureListViewList_moreA',              // (리스트 형식) 더보기                    'click #cultureList_ViewList_moreButton_B': 'getCultureListViewList_moreB',              // (리스트 형식) 더보기                    'click #cultureList_ViewList_moreButton_C': 'getCultureListViewList_moreC',              // (리스트 형식) 더보기                    'click #cultureCalendar_Upcoming_moreButton': 'getCultureCalendarUpcoming_more',        // (캘린더 형식) Upcoming 더보기                    'click #cultureCalendar_Past_moreButton': 'getCultureCalendarPast_more',                           // (캘린더 형식) Past 더보기                    'click #calendar_today': 'getCultureCalendarToday',                    'click .view-item &gt; .item ': 'getContentDetil'                });            },            setInitView: function() {                //큐레이터 리스트 셋팅                var curatorList = this.options.curatorList;                if( curatorList.length &gt; 0 ){                    $.each(curatorList, function(i){                        $('.select-curator select').append('&lt;option value=\"'+ curatorList[i].curatorSequenceNo +'\"&gt;'+ curatorList[i].curatorName +'&lt;/option&gt;');                    });                }                /* 초기화면 설정 */                //조회 조건 초기 설정                var filterPlaceSpace = this.options.filterPlaceSpace;                var reservationYN = this.options.reservationYN;                var curatorId = this.options.curatorId;                $(\"input[name='filterPlaceSpace'][value='\"+filterPlaceSpace+\"']\").prop('checked', true);                $(\"input[name='reservationYN'][value='\"+reservationYN+\"']\").prop('checked', true);                //큐레이터 클릭 처리                if( filterPlaceSpace === '7' ) { this.options.showType = \"list\"; }                //화면 처리 방식                var showType = this.options.showType;                if(showType == \"list\"){                    this.options.showType = \"init\";           //최초 조회시 세팅                    //화면 UI 설정                    $('#calenderView').removeClass('active');                    $('#filterView').addClass('active');                    $('#showTypeCalendar').closest(\"li\").removeClass('current');                    $('#showTypeList').closest(\"li\").addClass('current');                    var check_label = isEmpty_nvl($(\"input[name='filterPlaceSpace']:checked\").attr(\"id\"));                    $('.btn-sel-space span').text($(\"label[for='\"+check_label+\"']\").text());                    //큐레이터 UI및 값 세팅                    if( filterPlaceSpace === '7' ){                        this.options.curator = curatorId;                        if( curatorId !== '' ){                            $(\"#curatorList\").val(curatorId);                        }                        $(\".select-curator\").show();                    }                    //Culture Calendar [리스트 형식]                    $('#showTypeList').trigger('click');                }else{                    this.options.showType = \"init\";           //최초 조회시 세팅                    //Culture Calendar [캘린더 형식]                    $('#showTypeCalendar').trigger('click');                }            },            fnShowTypeList: function() {                /* 화면 설정 (리스트 형식) */                if(this.options.showType != \"list\"){  // 동일한 영역 여러번 클릭 방지                    if(this.options.showType == \"init\"){                    }else{                        //초기화                        var temp_filterPlaceSpace = \"\";                        var temp_reservationYN = \"\";                        $(\"input[name='filterPlaceSpace'][value='\"+temp_filterPlaceSpace+\"']\").prop('checked', true);                        var check_label = isEmpty_nvl($(\"input[name='filterPlaceSpace']:checked\").attr(\"id\"));                        $('.btn-sel-space span').text($(\"label[for='\"+check_label+\"']\").text());                        $('.select-ticket input').prop('checked',false); //check 해제                        //초기화 데이터 설정                        this.options.filterPlaceSpace = temp_filterPlaceSpace;                        this.options.reservationYN = temp_reservationYN;                    }                    var filterPlaceSpace = isEmpty_nvl($(\"input[name='filterPlaceSpace']:checked\").val());                    var reservationYN = isEmpty_nvl($(\"input[name='reservationYN']:checked\").val());                    //Culture Calendar [리스트 형식]                    this.getCultureListViewList_init();                    this.options.showType = \"list\";                }            },            fnShowTypeCalendar: function() {                /* 화면 설정 (캘린더 형식) */                if(this.options.showType != \"calendar\"){  // 동일한 영역 여러번 클릭 방지                    //Culture Calendar [캘린더 형식]                    this.option.calendarTodayYn = \"Y\";        //오늘일자로 처리                    this.getCultureCalendar();                    this.options.showType = \"calendar\";                }            },            fnSearchCulture: function(e) {                /* 검색 조건 */                var filterPlaceSpace = isEmpty_nvl($(\"input[name='filterPlaceSpace']:checked\").val());                var reservationYN = isEmpty_nvl($(\"input[name='reservationYN']:checked\").val());                var curator = \"\";                this.options.filterPlaceSpace = filterPlaceSpace;                this.options.reservationYN = reservationYN;                if( e.currentTarget.id === 'curatorList' ){                    curator = $('select[id=curatorList]').val();                }else{                    $('select[id=curatorList]').val('');                }                this.options.curator = curator;                //Culture Calendar [리스트형식]                this.getCultureListViewList_init();            },            getCultureListViewList_init: function() {                /* 리스트 형식 : 초기 조회 */                var temp_isNotPast = \"\";                // 예약/예매 Y 일 경우 과거 정보 X                if(this.options.reservationYN == \"Y\"){                    temp_isNotPast = \"Y\";                }                var param = {                    isNotPast : temp_isNotPast,                    filterPlaceSpace : this.options.filterPlaceSpace,                    curator: this.options.curator,                    reservationYN : this.options.reservationYN,                    pageCount : this.options.cultureListViewListPage.pageCount                };                var temp_filterPlaceSpace = this.options.filterPlaceSpace;                $(\"#cultureList_one\").hide();                $(\"#cultureList_many\").hide();                if(isEmpty_nvl(temp_filterPlaceSpace) != \"\"){                    $(\"#cultureList_one\").show();                    cult.ajax({                        url: '/web/culture/getCultureOnePaging.hdc',                        type: 'POST',                        data: param                    }).done($.proxy(function(res) {                        var templateHtml = $('#cultureListViewTemplate').html();                        var templateListHtml = $('#cultureListPagingViewTemplate').html();                        var objTemplate = cult.ejsCompile(templateHtml);                        var objListTemplate = cult.ejsCompile(templateListHtml);                        var viewHtml = objTemplate(res.body);                        var viewListHtml = objListTemplate(res.body);                        $('#cultureList_ViewList').html(viewHtml);                        if ( res.body.list != null &amp;&amp; res.body.list.length &gt; 0 ) {                            $('#cultureList_ViewList_area').html(viewListHtml);                            if ( res.body.pagingEndYN == 'Y' ) {                                $('#cultureList_ViewList_more').remove();                            }else{                                $('#cultureList_ViewList_moreButton').html(\"&lt;span&gt;더 보기&lt;/span&gt;\");                            }                        }else{                            var listNotHtml = '';                            listNotHtml += '&lt;div class=\"list-empty\"&gt;';                            listNotHtml += '선택하신 조건에 해당하는 행사가 없습니다.';                            listNotHtml += '&lt;/div&gt;';                            $('#cultureList_ViewList').html(listNotHtml);                        }                        this.options.cultureListViewListPage.pageNo = parseInt(res.body.pageNo) + 1;                    }, this));                }else{                    $(\"#cultureList_many\").show();                    cult.ajax({                        url: '/web/culture/getCultureManyPaging.hdc',                        type: 'POST',                        data: param                    }).done($.proxy(function(res) {                        //이태원                        var templateHtml_A = $('#cultureListViewTemplate_A').html();                        var templateListHtml_A = $('#cultureListPagingViewTemplate').html();                        var objTemplate_A = cult.ejsCompile(templateHtml_A);                        var objListTemplate_A = cult.ejsCompile(templateListHtml_A);                        var viewHtml_A = objTemplate_A({list : res.body.voA.list});                        var viewListHtml_A = objListTemplate_A({list : res.body.voA.list});                        $('#cultureList_ViewList_A').html(viewHtml_A);                        if ( res.body.voA.list != null &amp;&amp; res.body.voA.list.length &gt; 0 ) {                            $('#cultureList_ViewList_area_A').html(viewListHtml_A);                            if ( res.body.voA.pagingEndYN == 'Y' ) {                                $('#cultureList_ViewList_more_A').remove();                            }else{                                $('#cultureList_ViewList_moreButton_A').html(\"&lt;span&gt;더 보기&lt;/span&gt;\");                            }                        }else{                            var listNotHtml = '';                            listNotHtml += '&lt;h4 class=\"section-title\"&gt;이태원&lt;/h4&gt;';                            listNotHtml += '&lt;div class=\"list-empty\"&gt;';                            listNotHtml += '선택하신 조건에 해당하는 행사가 없습니다.';                            listNotHtml += '&lt;/div&gt;';                            $('#cultureList_ViewList_A').html(listNotHtml);                        }                        this.options.cultureListViewListPageA.pageNo = parseInt(res.body.voA.pageNo) + 1;                        //청담. 압구정                        var templateHtml_B = $('#cultureListViewTemplate_B').html();                        var templateListHtml_B = $('#cultureListPagingViewTemplate').html();                        var objTemplate_B = cult.ejsCompile(templateHtml_B);                        var objListTemplate_B = cult.ejsCompile(templateListHtml_B);                        var viewHtml_B = objTemplate_B({list : res.body.voB.list});                        var viewListHtml_B = objListTemplate_B({list : res.body.voB.list});                        $('#cultureList_ViewList_B').html(viewHtml_B);                        if ( res.body.voB.list != null &amp;&amp; res.body.voB.list.length &gt; 0 ) {                            $('#cultureList_ViewList_area_B').html(viewListHtml_B);                            if ( res.body.voB.pagingEndYN == 'Y' ) {                                $('#cultureList_ViewList_more_B').remove();                            }else{                                $('#cultureList_ViewList_moreButton_B').html(\"&lt;span&gt;더 보기&lt;/span&gt;\");                            }                        }else{                            var listNotHtml = '';                            listNotHtml += '&lt;h4 class=\"section-title\"&gt;청담&lt;/h4&gt;';                            listNotHtml += '&lt;div class=\"list-empty\"&gt;';                            listNotHtml += '선택하신 조건에 해당하는 행사가 없습니다.';                            listNotHtml += '&lt;/div&gt;';                            $('#cultureList_ViewList_B').html(listNotHtml);                        }                        this.options.cultureListViewListPageB.pageNo = parseInt(res.body.voB.pageNo) + 1;                        //가회                        var templateHtml_C = $('#cultureListViewTemplate_C').html();                        var templateListHtml_C = $('#cultureListPagingViewTemplate').html();                        var objTemplate_C = cult.ejsCompile(templateHtml_C);                        var objListTemplate_C = cult.ejsCompile(templateListHtml_C);                        var viewHtml_C = objTemplate_C({list : res.body.voC.list});                        var viewListHtml_C = objListTemplate_C({list : res.body.voC.list});                        $('#cultureList_ViewList_C').html(viewHtml_C);                        if ( res.body.voC.list != null &amp;&amp; res.body.voC.list.length &gt; 0 ) {                            $('#cultureList_ViewList_area_C').html(viewListHtml_C);                            if ( res.body.voC.pagingEndYN == 'Y' ) {                                $('#cultureList_ViewList_more_C').remove();                            }else{                                $('#cultureList_ViewList_moreButton_C').html(\"&lt;span&gt;더 보기&lt;/span&gt;\");                            }                        }else{                            var listNotHtml = '';                            listNotHtml += '&lt;h4 class=\"section-title\"&gt;가회&lt;/h4&gt;';                            listNotHtml += '&lt;div class=\"list-empty\"&gt;';                            listNotHtml += '선택하신 조건에 해당하는 행사가 없습니다.';                            listNotHtml += '&lt;/div&gt;';                            $('#cultureList_ViewList_C').html(listNotHtml);                        }                        this.options.cultureListViewListPageC.pageNo = parseInt(res.body.voC.pageNo) + 1;                    }, this));                }            },            getCultureListViewList_more: function() {                /* 리스트 형식 : Now &amp; Upcoming 더보기 */                // double click 방지                if ( this.options.moreBtnDoubleClickPrevention ) return false;                var temp_isNotPast = \"\";                // 예약/예매 Y 일 경우 과거 정보 X                if(this.options.reservationYN == \"Y\"){                    temp_isNotPast = \"Y\";                }                var param = {                    isNotPast : temp_isNotPast,                    filterPlaceSpace : this.options.filterPlaceSpace,                    curator: this.options.curator,                    reservationYN : this.options.reservationYN,                    pageNo: this.options.cultureListViewListPage.pageNo,                    pageCount : this.options.cultureListViewListPage.pageCount                };                this.options.moreBtnDoubleClickPrevention = true;                cult.ajax({                    url: '/web/culture/getCultureOnePaging.hdc',                    type: 'POST',                    data: param                }).done($.proxy(function(res) {                    this.options.moreBtnDoubleClickPrevention = false;                    var templateListHtml = $('#cultureListPagingViewTemplate').html();                    var objListTemplate = cult.ejsCompile(templateListHtml);                    var viewListHtml = objListTemplate(res.body);                    $('#cultureList_ViewList_area').append(viewListHtml);                    if ( res.body.pagingEndYN == 'Y' ) {                        $('#cultureList_ViewList_more').remove();                    }else{                        $('#cultureList_ViewList_moreButton').html(\"&lt;span&gt;더 보기&lt;/span&gt;\");                    }                    this.options.cultureListViewListPage.pageNo = parseInt(res.body.pageNo) + 1;                }, this));            },            getCultureListViewList_moreA: function() {                /* 리스트 형식 : 더보기 */                // double click 방지                if ( this.options.moreBtnDoubleClickPrevention ) return false;                var temp_isNotPast = \"\";                // 예약/예매 Y 일 경우 과거 정보 X                if(this.options.reservationYN == \"Y\"){                    temp_isNotPast = \"Y\";                }                var param = {                    isNotPast : temp_isNotPast,                    filterPlaceSpace : \"A\",                    reservationYN : this.options.reservationYN,                    pageNo: this.options.cultureListViewListPageA.pageNo,                    pageCount : this.options.cultureListViewListPageA.pageCount                };                this.options.moreBtnDoubleClickPrevention = true;                cult.ajax({                    url: '/web/culture/getCultureOnePaging.hdc',                    type: 'POST',                    data: param                }).done($.proxy(function(res) {                    this.options.moreBtnDoubleClickPrevention = false;                    var templateListHtml = $('#cultureListPagingViewTemplate').html();                    var objListTemplate = cult.ejsCompile(templateListHtml);                    var viewListHtml = objListTemplate(res.body);                    $('#cultureList_ViewList_area_A').append(viewListHtml);                    if ( res.body.pagingEndYN == 'Y' ) {                        $('#cultureList_ViewList_more_A').remove();                    }else{                        $('#cultureList_ViewList_moreButton_A').html(\"&lt;span&gt;더 보기&lt;/span&gt;\");                    }                    this.options.cultureListViewListPageA.pageNo = parseInt(res.body.pageNo) + 1;                }, this));            },            getCultureListViewList_moreB: function() {                /* 리스트 형식 : 더보기 */                // double click 방지                if ( this.options.moreBtnDoubleClickPrevention ) return false;                var temp_isNotPast = \"\";                // 예약/예매 Y 일 경우 과거 정보 X                if(this.options.reservationYN == \"Y\"){                    temp_isNotPast = \"Y\";                }                var param = {                    isNotPast : temp_isNotPast,                    filterPlaceSpace : \"B\",                    reservationYN : this.options.reservationYN,                    pageNo: this.options.cultureListViewListPageB.pageNo,                    pageCount : this.options.cultureListViewListPageB.pageCount                };                this.options.moreBtnDoubleClickPrevention = true;                cult.ajax({                    url: '/web/culture/getCultureOnePaging.hdc',                    type: 'POST',                    data: param                }).done($.proxy(function(res) {                    this.options.moreBtnDoubleClickPrevention = false;                    var templateListHtml = $('#cultureListPagingViewTemplate').html();                    var objListTemplate = cult.ejsCompile(templateListHtml);                    var viewListHtml = objListTemplate(res.body);                    $('#cultureList_ViewList_area_B').append(viewListHtml);                    if ( res.body.pagingEndYN == 'Y' ) {                        $('#cultureList_ViewList_more_B').remove();                    }else{                        $('#cultureList_ViewList_moreButton_B').html(\"&lt;span&gt;더 보기&lt;/span&gt;\");                    }                    this.options.cultureListViewListPageB.pageNo = parseInt(res.body.pageNo) + 1;                }, this));            },            getCultureListViewList_moreC: function() {                /* 리스트 형식 : 더보기 */                // double click 방지                if ( this.options.moreBtnDoubleClickPrevention ) return false;                var temp_isNotPast = \"\";                // 예약/예매 Y 일 경우 과거 정보 X                if(this.options.reservationYN == \"Y\"){                    temp_isNotPast = \"Y\";                }                var param = {                    isNotPast : temp_isNotPast,                    filterPlaceSpace : \"C\",                    reservationYN : this.options.reservationYN,                    pageNo: this.options.cultureListViewListPageC.pageNo,                    pageCount : this.options.cultureListViewListPageC.pageCount                };                this.options.moreBtnDoubleClickPrevention = true;                cult.ajax({                    url: '/web/culture/getCultureOnePaging.hdc',                    type: 'POST',                    data: param                }).done($.proxy(function(res) {                    this.options.moreBtnDoubleClickPrevention = false;                    var templateListHtml = $('#cultureListPagingViewTemplate').html();                    var objListTemplate = cult.ejsCompile(templateListHtml);                    var viewListHtml = objListTemplate(res.body);                    $('#cultureList_ViewList_area_C').append(viewListHtml);                    if ( res.body.pagingEndYN == 'Y' ) {                        $('#cultureList_ViewList_more_C').remove();                    }else{                        $('#cultureList_ViewList_moreButton_C').html(\"&lt;span&gt;더 보기&lt;/span&gt;\");                    }                    this.options.cultureListViewListPageC.pageNo = parseInt(res.body.pageNo) + 1;                }, this));            },            getCultureCalendar: function() {                /* 캘린더 형식 : 달력 */                var yearMon = \"\";                if(this.option.calendarTodayYn == \"Y\"){                    yearMon = this.options.today_yearMon;                }else{                    yearMon = $(\"input[name='hid_yearMon']\").val();                }                fnCultureCalendarAll(yearMon, this.options.today);                this.getCultureCalendarAll();            },            getCultureCalendarToday: function() {                /* 캘린더 형식 : 달력 */                $(\"input[name='hid_checkDay']\").val(\"\");//today 선택시 선택일자 초기화                fnCultureCalendarAll(this.options.today_yearMon, this.options.today);                this.getCultureCalendarAll();            },            getCultureCalendarAll: function() {                /* 캘린더 형식 : Now / Upcoming / PAST 초기 조회 */                var param = {                    pageCountUpcoming : this.options.cultureCalendarUpcomingPage.pageCount,                    pageCountPast : this.options.cultureCalendarPastPage.pageCount                };                cult.ajax({                    url: '/web/culture/getCultureCalendarAll.hdc',                    type: 'POST',                    data: param                }).done($.proxy(function(res) {                    //NOW                    var now_templateHtml = $('#calendarDayTemplate').html();                    var now_objTemplate = cult.ejsCompile(now_templateHtml);                    var now_viewHtml = now_objTemplate(res.body.voNow);                    $(\"#cultureCalendar_NowWrap\").show();                    $('#cultureCalendar_Now').html(now_viewHtml);                    $('#cultureCalendar_Now').find(\".section-title\").show();                    //UPCOMING                    $(\"#cultureCalendar_UpcomingWrap\").hide();       //Default 숨김                    var upcoming_templateHtml = $('#cultureCalendarUpcomingTemplate').html();                    var upcoming_templateListHtml = $('#cultureCalendarPagingUpcomingTemplate').html();                    var upcoming_objTemplate = cult.ejsCompile(upcoming_templateHtml);                    var upcoming_objListTemplate = cult.ejsCompile(upcoming_templateListHtml);                    var upcoming_viewHtml = upcoming_objTemplate(res.body.voUpcoming);                    var upcoming_viewListHtml = upcoming_objListTemplate(res.body.voUpcoming);                    $('#cultureCalendar_UpcomingWrap').html(upcoming_viewHtml);                    if ( res.body.voUpcoming.list != null &amp;&amp; res.body.voUpcoming.list.length &gt; 0 ) {                        $(\"#cultureCalendar_UpcomingWrap\").show();       //정보가 존재할 경우 활성화                        $('#cultureCalendar_Upcoming_area').html(upcoming_viewListHtml);                        if ( res.body.voUpcoming.pagingEndYN == 'Y' ) {                            $('#cultureCalendar_Upcoming_more').remove();                        }else{                            $('#cultureCalendar_Upcoming_moreButton').html(\"&lt;span&gt;더 보기&lt;/span&gt;\");                        }                    }else{                        $(\"#cultureCalendar_UpcomingWrap\").show();       //정보가 존재하지 않을 경우 활성화                        var listNotHtml = '';                        listNotHtml += '&lt;h2 class=\"section-title\"&gt;Upcoming&lt;/h2&gt;';                        listNotHtml += '&lt;div class=\"list-empty\"&gt;';                        listNotHtml += '풍덩! 빠질만한 다음 행사를 준비 중입니다 :)';                        listNotHtml += '&lt;/div&gt;';                        $('#cultureCalendar_UpcomingWrap').html(listNotHtml);                    }                    this.options.cultureCalendarUpcomingPage.pageNo = parseInt(res.body.voUpcoming.pageNo) + 1;                    //PAST                    $(\"#cultureCalendar_PastWrap\").hide();            //Default 숨김                    var past_templateHtml = $('#cultureCalendarPastTemplate').html();                    var past_templateListHtml = $('#cultureCalendarPagingPastTemplate').html();                    var past_objTemplate = cult.ejsCompile(past_templateHtml);                    var past_objListTemplate = cult.ejsCompile(past_templateListHtml);                    var past_viewHtml = past_objTemplate(res.body.voPast);                    var past_viewListHtml = past_objListTemplate(res.body.voPast);                    $('#cultureCalendar_PastWrap').html(past_viewHtml);                    if ( res.body.voPast.list != null &amp;&amp; res.body.voPast.list.length &gt; 0 ) {                        $(\"#cultureCalendar_PastWrap\").show();       //정보가 존재할 경우 활성화                        $('#cultureCalendar_Past_area').html(past_viewListHtml);                        if ( res.body.voPast.pagingEndYN == 'Y' ) {                            $('#cultureCalendar_Past_more').remove();                        }else{                            $('#cultureCalendar_Past_moreButton').html(\"&lt;span&gt;더 보기&lt;/span&gt;\");                        }                    }else{                        $(\"#cultureCalendar_PastWrap\").show();       //정보가 존재하지 않을 경우 활성화                        var listNotHtml = '';                        listNotHtml += '&lt;h2 class=\"section-title\"&gt;Past&lt;/h2&gt;';                        listNotHtml += '&lt;div class=\"list-empty\"&gt;';                        listNotHtml += '종료된 행사가 없습니다.';                        listNotHtml += '&lt;/div&gt;';                        $('#cultureCalendar_PastWrap').html(listNotHtml);                    }                    this.options.cultureCalendarPastPage.pageNo = parseInt(res.body.voPast.pageNo) + 1;                }, this));            },            getCultureCalendarUpcoming_more: function() {                /* 리스트 형식 : Past 더보기 */                // double click 방지                if ( this.options.moreBtnDoubleClickPrevention ) return false;                var param = {                    divisionType : \"UPCOMING\",                    pageNo: this.options.cultureCalendarUpcomingPage.pageNo,                    pageCount : this.options.cultureCalendarUpcomingPage.pageCount                };                this.options.moreBtnDoubleClickPrevention = true;                cult.ajax({                    url: '/web/culture/getCultureListPaging.hdc',                    type: 'POST',                    data: param                }).done($.proxy(function(res) {                    this.options.moreBtnDoubleClickPrevention = false;                    var templateListHtml = $('#cultureCalendarPagingUpcomingTemplate').html();                    var objListTemplate = cult.ejsCompile(templateListHtml);                    var viewListHtml = objListTemplate(res.body);                    $('#cultureCalendar_Upcoming_area').append(viewListHtml);                    if ( res.body.pagingEndYN == 'Y' ) {                        $('#cultureCalendar_Upcoming_more').remove();                    }else{                        $('#cultureCalendar_Upcoming_moreButton').html(\"&lt;span&gt;더 보기&lt;/span&gt;\");                    }                    this.options.cultureCalendarUpcomingPage.pageNo = parseInt(res.body.pageNo) + 1;                }, this));            },            getCultureCalendarPast_more: function() {                /* 리스트 형식 : Past 더보기 */                // double click 방지                if ( this.options.moreBtnDoubleClickPrevention ) return false;                var param = {                    divisionType : \"PAST\",                    pageNo: this.options.cultureCalendarPastPage.pageNo,                    pageCount : this.options.cultureCalendarPastPage.pageCount                };                this.options.moreBtnDoubleClickPrevention = true;                cult.ajax({                    url: '/web/culture/getCultureListPaging.hdc',                    type: 'POST',                    data: param                }).done($.proxy(function(res) {                    this.options.moreBtnDoubleClickPrevention = false;                    var templateListHtml = $('#cultureCalendarPagingPastTemplate').html();                    var objListTemplate = cult.ejsCompile(templateListHtml);                    var viewListHtml = objListTemplate(res.body);                    $('#cultureCalendar_Past_area').append(viewListHtml);                    if ( res.body.pagingEndYN == 'Y' ) {                        $('#cultureCalendar_Past_more').remove();                    }else{                        $('#cultureCalendar_Past_moreButton').html(\"&lt;span&gt;더 보기&lt;/span&gt;\");                    }                    this.options.cultureCalendarPastPage.pageNo = parseInt(res.body.pageNo) + 1;                }, this));            },            getContentDetil: function(e) {                var tmp_target = $(e.target).closest(\".view-item\").find(\".item\");                var contentId = tmp_target.data('contentId');                var contentType = tmp_target.data('contentType');                if(contentType == \"3\"){   //콘텐츠 : 외부                    fnExternalLinkUrl(contentId);                }else{                    var param = {                        filterPlaceSpace : this.options.filterPlaceSpace,                        curator: this.options.curator,                        reservationYN : this.options.reservationYN                    }                    $.cookie('diveWebParam', JSON.stringify(param), { expires:1, path : '/' });                    cult.movePageCookie('/web/content/contentView.hdc?contentId=' + contentId);                }            }        });    })( jQuery );    var moreBtnDoubleClickCheck = false;    //CultureCalendar (캘린더형) 달력정보 호출    function fnCultureCalendarAll(checkMonth, today){        // double click 방지        if ( moreBtnDoubleClickCheck ) return false;        var param = {            yearMon : checkMonth        }        moreBtnDoubleClickCheck = true;        cult.ajax({            url: '/web/culture/getCultureCalendar.hdc',            type: 'POST',            data: param        }).done($.proxy(function(res) {            moreBtnDoubleClickCheck = false;            var templateHtml = $('#calendarTemplate').html();            var objTemplate = cult.ejsCompile(templateHtml);            var viewHtml = objTemplate(res.body);            $('#cultureCalendar_View').html(viewHtml);            //선택 날짜 표시            /**             if(today.length == 8){            var temp_checkDay = fnStringDateFormat(today, \"-\");            $(\"input[name='hid_checkDay']\").val(temp_checkDay);            //선택 초기화            $('.calendar-wrap td').removeClass('selected');            //선택 날짜            $(\"#calenderView .table-type-calendar td\").each(function(e){                var temp = $(this).find(\"a\").data('checkday');                if(temp_checkDay == temp){                    $(this).addClass('selected');                    return;                }            })        }             */        }, this));    }    //CultureCalendar (캘린더형) 달력정보 호출    function fnCultureCalendarClick(checkMonth){        // double click 방지        if ( moreBtnDoubleClickCheck ) return false;        var param = {            yearMon : checkMonth        }        moreBtnDoubleClickCheck = true;        cult.ajax({            url: '/web/culture/getCultureCalendar.hdc',            type: 'POST',            data: param        }).done($.proxy(function(res) {            moreBtnDoubleClickCheck = false;            var templateHtml = $('#calendarTemplate').html();            var objTemplate = cult.ejsCompile(templateHtml);            var viewHtml = objTemplate(res.body);            $('#cultureCalendar_View').html(viewHtml);            //기존에 선택된 날짜 표시            var temp_checkDay = $(\"input[name='hid_checkDay']\").val();            if(isEmpty_nvl(temp_checkDay) != \"\"){                //선택 초기화                $('.calendar-wrap td').removeClass('selected');                //선택 날짜                $(\"#calenderView .table-type-calendar td\").each(function(e){                    var temp = $(this).find(\"a\").data('checkday');                    if(temp_checkDay == temp){                        $(this).addClass('selected');                        return;                    }                })            }        }, this));    }    //CultureCalendar (캘린더형) 년월일 리스트 정보 호출 : 달력 선택 시    function fnCultureCalendarDayClick(checkDay){        // double click 방지        if ( moreBtnDoubleClickCheck ) return false;        //일정 선택시 Upcoming, Past 숨김        $(\"#cultureCalendar_UpcomingWrap\").hide();        $(\"#cultureCalendar_PastWrap\").hide();        var checkMonth = checkDay.substring(0, 6);        var param = {            checkDay : checkDay,            yearMon : checkMonth        }        moreBtnDoubleClickCheck = true;        cult.ajax({            url: '/web/culture/getCultureCalendarDay.hdc',            type: 'POST',            data: param        }).done($.proxy(function(res) {            moreBtnDoubleClickCheck = false;            var templateHtml = $('#calendarDayTemplate').html();            var objTemplate = cult.ejsCompile(templateHtml);            var viewHtml = objTemplate(res.body);            $(\"#cultureCalendar_NowWrap\").show();            $('#cultureCalendar_Now').html(viewHtml);            $('#cultureCalendar_Now').find(\".section-title\").hide();            //현재일자 기준으로 예매/예약 문구 노출 여부 체크            if(res.body.reservationTypeViewCheck == \"Y\"){                $(document).find(\"#cultureCalendar_Now\").find(\".badge\").find(\".status\").show();            }else{                $(document).find(\"#cultureCalendar_Now\").find(\".badge\").find(\".status\").hide();            }            //선택한 일자 hidden 등록            if(checkDay.length == 8){                var temp_checkDay = fnStringDateFormat(checkDay, \"-\");                $(\"input[name='hid_checkDay']\").val(temp_checkDay);            }        }, this));    }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;로컬에서 테스트해보니 위와 같이 해당 파일들을 불러올 수 없다고 뜹니다.해당 파일들은 ajax로 데이터값을 읽어오는 파일들입니다.이런식으로 ajax로 읽어오는데 문제는 해당 파일의 내용을 확인할 수가 없습니다.현대카드의 해당 경로로 들어가면 페이지가 없다고 나옵니다.다만 아래 사진처럼 달력 데이터를 해당 페이지에서 파라미터 데이터를 post 방식으로 불러와 뿌려준다는 것만 어렴풋이 알 수 있었습니다."
}, 

{
"id": "-issue-2020-04-28-issue04",
"title": "jquery $.proxy",
"author": null,
"tags": [],
"url": "/issue/2020/04/28/issue04/",
"date": "2020-04-28",
"content": "jquery $.proxy는 원하는 객체를 넘길 수 있습니다.다음과 같이 textAreaOnFunc 함수 객체를 넘길 수도 있고,proxy를 사용 안하면 이벤트를 발생시킨 객체를 넘길 수도 있습니다.&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt;&lt;textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt;&lt;script src=\"https://code.jquery.com/jquery-1.12.4.min.js\"&gt;&lt;/script&gt;&lt;script&gt;    (function (win, $) {        var coordGenerator = {            init: function () {                this.setElements();                this.bindEvents();            },            setElements: function () {                this.textArea = $('textarea');            },            bindEvents: function () {                this.textArea.on('focus',$.proxy(this.textAreaOnFunc, this))            },            textAreaOnFunc : function (e) {                console.log('test');                // console.log($(this));            }        };        coordGenerator.init();    })(window, window.jQuery);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt;&lt;textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt;&lt;script src=\"https://code.jquery.com/jquery-1.12.4.min.js\"&gt;&lt;/script&gt;&lt;script&gt;    (function (win, $) {        var coordGenerator = {            init: function () {                this.setElements();                this.bindEvents();            },            setElements: function () {                this.textArea = $('textarea');            },            bindEvents: function () {                this.textArea.on('focus',this.textAreaOnFunc)            },            textAreaOnFunc : function (e) {                console.log('test');                // console.log($(this));                $(this).toggleClass('on');            }        };        coordGenerator.init();    })(window, window.jQuery);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"
}, 

{
"id": "-javascript-2020-04-28-javascript106",
"title": "6.3 함수와 매개변수",
"author": null,
"tags": [],
"url": "/javascript/2020/04/28/javascript106/",
"date": "2020-04-28",
"content": "함수를 호출해서 값을 얻는 방법을 배웠습니다.그렇다면 함수에 정보를 전달하려면 어떻게 해야 할까요?함수를 호출하면서 정보를 전달할 때는 함수 매개변수(argument, parameter) 를 이용합니다.매개변수는 함수가 호출되기 전에는 존재하지 않는다는 점을 제외하면 일반적인 변수나 마찬가지입니다.숫자형 매개변수 두 개를 받고 그 평균을 반환하는 함수를 생각해 봅시다.function avg(a, b) {\treturn (a + b)/2;}이 함수 선언에서 a와 b를 정해진 매개변수(formal argument) 라고 합니다.함수가 호출되면 정해진 매개변수는 값을 받아 실제 매개변수(actual argument) 가 됩니다.avg(5, 10); // 7.5이 예제에서 정해진 매개변수 a와 b는 각각 5와 10을 받아 실제 매개변수가 됩니다.실제 매개변수는 변수와 매우 비슷하지만, 함수 바디 안에서만 존재합니다.초보자들은 같은 이름의 변수가 함수 바깥에 존재하는데도 매개변수가 함수 안에서만 존재한다는 말에 어리둥절해하곤 합니다. 다음 예제를 보십시오.const a = 5, b = 10;avg(a, b);첫 행의 변수 a, b는 함수 avg의 매개변수인 a, b와 같은 이름이지만, 엄연히 다른 변수입니다.함수를 호출하면 함수 매개변수는 변수 자체가 아니라 그 값을 전달받습니다.다음 코드를 보십시오.function f(x) {\tconsole.log(`f 내부 : x = ${x}`);\tx = 5;\tconsole.log(`f 내부 : x = ${x} (할당 후)`);}let x = 3;console.log(`f를 호출하기 전 : x = ${x}`);f(x);console.log(`f를 호출한 다음 : x = ${x}`);이 예제를 실행한 결과는 다음과 같습니다.f를 호출하기 전 : x = 3f 내부 : x = 3f 내부 : x = 5 (할당 후)f를 호출한 다음 : x = 3여기서 중요한 것은 함수 안에서 x에 값을 할당하더라도 함수 바깥의 변수 x에는 아무 영향도 없다는 겁니다.이름은 같지만, 둘은 다른 개체입니다.함수 안에서 매개변수에 값을 할당해도 함수 바깥에 있는 어떤 변수에도 아무런 영향이 없습니다.하지만 함수 안에서 객체 자체를 변경하면, 그 객체는 함수 바깥에서도 바뀐 점이 반영됩니다.다음 예제를 보십시오.function f (o) {\to.message = `f 안에서 수정함 (이전 값 : '${o.message}')`;}let o = {\tmessage: \"초기 값\"}console.log(`f를 호출하기 전 : o.message = \"${o.message}\"`);f(o);console.log(`f를 호출한 다음 : o.message = \"${o.message}\"`);앞의 코드를 실행한 결과는 다음과 같습니다.이 예제를 보면 함수 f 안에서 객체 o를 수정했고, 이렇게 바꾼 내용은 함수 바깥에서도 o에 그대로 반영되어 있음을 알 수 있습니다.이것이 원시 값과 객체의 핵심적인 차이입니다.원시 값은 불변이므로 수정할 수 없습니다.원시 값을 담은 변수는 수정할 수 있지만(다른 값으로 바꿀 수 있지만) 원시 값 자체는 바뀌지 않습니다.반면 객체는 바뀔 수 있습니다.좀 더 명확하게 말해봅시다.함수 안의 o와 함수 바깥의 o는 서로 다른 개체입니다.하지만 그 둘은 같은 객체를 가리키고 있습니다.할당을 이용해서 차이점을 다시 알아봅시다.function f(o) {\to.message = \"f에서 수정함\";\to = {\t\tmessage: \"새로운 객체!\"\t};\tconsole.log(`f 내부: o.message = \"${o.message}\" (할당 후)`);}let o = {\tmessage: '초기 값'};console.log(`f를 호출하기 전 : o.message=\"${o.message}\"`);f(o);console.log(`f를 호출한 다음 : o.message=\"${o.message}\" `);이 예제를 실행한 결과는 다음과 같습니다.이 예제를 이해하는 핵심은 함수 내부의 매개변수 o와 함수 바깥의 변수 o가 다르다는 겁니다.f를 호출하면 둘은 같은 객체를 가리키지만, f 내부에서 o에 할당한 객체는 새로운, 전혀 다른 객체입니다.함수 바깥의 o는 여전히 원래 객체를 가리키고 있습니다.  NOTE_컴퓨터 과학에서는 자바스크립트의 원시 값을 값 타입(value type) 이라고 말합니다.원시 값을 전달할 때 값이 복사되기 때문입니다.객체는 참조 타입(reference type) 이라 부릅니다.객체를 전달할 때 두 변수는 같은 객체를 가리키기 때문입니다."
}, 

{
"id": "-javascript-2020-04-27-javascript105",
"title": "6.2 호출과 참조",
"author": null,
"tags": [],
"url": "/javascript/2020/04/27/javascript105/",
"date": "2020-04-27",
"content": "자바스크립트에서는 함수도 객체입니다.따라서 다른 객체와 마찬가지로 넘기거나 할당할 수 있습니다.함수 호출과 참조의 차이를 이해하는 것이 중요합니다.함수 식별자 뒤에 괄호를 쓰면 자바스크립트는 함수를 호출하려 한다고 이해하고, 함수 바디를 실행합니다.그리고 함수를 호출한 표현식은 반환 값이 됩니다.괄호를 쓰지 않으면 다른 값과 마찬가지로 함수를 참조하는 것이며, 그 함수는 실행되지 않습니다.자바스크립트 콘솔에서 다음을 직접 실행해 보십시오.function getGreeting () {\tconsole.log(\"Hello world!\");}getGreeting(); // \"Hello world!\"getGreeting; // function getGreeting()함수를 호출하지 않고 다른 값과 마찬가지로 참조하기만 할 수 있다는 특징은 자바스크립트를 매우 유연한 언어로 만듭니다.예를 들어 함수를 변수에 할당하면 다른 이름으로 함수를 호출할 수 있습니다.const f = getGreeting;f(); // \"Hello world!\"함수를 객체 프로퍼티에 할당할 수도 있습니다.const o = {};o.f = getGreeting;o.f(); // \"Hello world!\"배열 요소로 할당할 수도 있습니다.const arr = [1, 2, 3];arr[1] = getGreeting; // arr은 이제 [1, function getGreeting(), 2] 입니다.arr[1](); // \"Hello world!\"마지막 예제를 보면 자바스크립트에서 괄호가 하는 일을 명확히 알 수 있을 겁니다.값 뒤에 괄호를 붙이면 자바스크립트는 그 값을 함수로 간주하고 호출합니다.이전 예제에서 arr[1]은 값이 되는 표현식입니다.값 뒤에 괄호를 썼으므로 자바스크립트는 이 값이 함수라고 간주하고 호출합니다.  NOTE_함수가 아닌 값 뒤에 괄호를 붙이면 에러가 일어납니다.예를 들어 “whoops”() 는 TypeError: “whoops” is not a function 에러를 일으킵니다."
}, 

{
"id": "-javascript-2020-04-27-javascript104",
"title": "6.1 반환 값",
"author": null,
"tags": [],
"url": "/javascript/2020/04/27/javascript104/",
"date": "2020-04-27",
"content": "함수 호출도 표현식이고, 우리가 이미 알고 있듯 표현식은 값이 됩니다.그러면 함수 호출의 값은 무엇일까요?그것이 반환 값입니다.함수 바디 안에 return 키워드를 사용하면 함수를 즉시 종료하고 값을 반환합니다.그 값이 바로 함수 호출의 값입니다.예제를 수정해서 환영 인사를 출력하지 않고 반환하도록 만들어 봅시다.function getGreeting() {\treturn \"Hello world!\";}이제 이 함수를 호출하면 함수 호출은 반환 값이 됩니다.getGreeting(); // \"Hello world!\"return 을 명시적으로 호출하지 않으면 반환 값은 undefined 가 됩니다.함수는 어떤 타입의 값이라도 반환할 수 있습니다.연습문제 삼아 getGreetings 함수를 만들어 보십시오.이 함수는 여러 나라의 언어로 된 “Hello, World” 메시지를 배열에 담아 반환해야 합니다.function getGreeting() {\treturn [\t\t\"Hello world!\",\t\t\"안녕\"\t]}"
}, 

{
"id": "-javascript-2020-04-27-javascript103",
"title": "6. 함수",
"author": null,
"tags": [],
"url": "/javascript/2020/04/27/javascript103/",
"date": "2020-04-27",
"content": "함수는 하나의 단위로 실행되는 문의 집합입니다.함수를 일종의 부속 프로그램으로 생각해도 좋습니다.함수는 자바스크립트의 강력함과 표현성의 근간입니다.  역주_표현성 - 원문은 expressiveness입니다.프로그래밍 언어가 표현적이라는 말은 코드만 봐도 어떤 의도인지 쉽게 알 수 있다는 뜻에서 주로 사용합니다.이 장에서는 함수의 기본적인 사용법과 동작 방식을 소개합니다.모든 함수에는 바디가 있습니다.함수 바디는 함수를 구성하는 문의 모음입니다.function sayHello () {\t// 함수 바디는 여는 중괄호로 시작하고\t\tconsole.log(\"Hello world!\");\tconsole.log(\"! Hola mundo!\");\tconsole.log(\"hallo wereld!\");\tconsole.log(\"안녕\");\t\t// 닫는 중괄호로 끝납니다.}앞의 예제는 함수 선언(function declaration) 의 한 예입니다.우리는 sayHello라는 함수를 선언했습니다.함수를 선언하기만 해서는 바디가 실행되지 않습니다.이 예제만으로 콘솔에 세계 여러 나라의 언어로 된 “Hello, World” 메시지가 출력되지 않습니다.함수를 호출(call) 할 때는 함수 이름 다음에 괄호를 씁니다.sayHello();   NOTE_호출한다(call, invoke)와 실행한다(execute, run) 는 섞어서 써도 됩니다.이 책에서는 문맥에 맞게 단어를 선택해서 쓸 겁니다.컨텍스트와 언어에 따라 이들 용어 사이에 미묘한 차이가 있을 수도 있지만, 일반적으로는 같다고 봐도 됩니다."
}, 

{
"id": "-javascript-2020-04-27-javascript102",
"title": "5.14 요약",
"author": null,
"tags": [],
"url": "/javascript/2020/04/27/javascript102/",
"date": "2020-04-27",
"content": "다른 최신 언어와 마찬가지로 자바스크립트에도 다양하고 유용한 연산자들이 있습니다.이들 연산자는 데이터를 조작하는 가장 기본적인 방법입니다.비트 연산자처럼 거의 사용하지 않는 연산자도 있고,점 연산자처럼 연산자라는 생각이 들지 않는 연산자도 있습니다(점 연산자를 연산자라고 생각하면 복잡하게 꼬인 연산자 우선순위 문제를 해결할 때 도움이 됩니다).할당, 산술, 비교, 불리언 연산자는 가장 널리 쓰이는 연산자이므로 다음 장으로 넘어가기 전에 이들을 잘 이해하고 있어야 합니다."
}, 

{
"id": "-javascript-2020-04-27-javascript101",
"title": "5.13 표현식과 흐름 제어 패턴",
"author": null,
"tags": [],
"url": "/javascript/2020/04/27/javascript101/",
"date": "2020-04-27",
"content": "4장에서 널리 쓰이는 제어문 패턴 몇 가지를 알아봤습니다.이제 제어문에 영향을 끼칠 수 있는 표현식인 3항 연산자와 단축 평가에 대해 배웠으니 제어문 패턴을 더 알아볼 수 있습니다.5.13.1 if … else 문을 3항 연산자로 바꾸기if … else 문의 목적이 변수의 값을 얻는 것이라면(할당이든, 표현식의 일부분이든, 함수의 반환값이든) 일반적으로 if … else 대신 3항 연산자를 쓰는 편이 좋습니다.3항 연산자를 쓰면 코드가 간단해지고 읽기 쉽습니다.다음 예제를 보십시오.if (isPrime(n)) {\tlabel = 'prime';} else {\tlabel = 'non-prime';}앞의 코드는 다음과 같이 바꾸는 게 좋습니다.label = isPrime(n) ? 'prime' : 'non-prime';5.13.2 if 문을 단축 평가하는 OR 표현식으로 바꾸기할당이 주 목적인 if 문은 단축 평가를 사용하는 OR 표현식을 써서 간결하게 줄일 수 있습니다.3항 연산자는 if … else 문보다 거의 항상 더 좋지만, 단축 평가는 뚜렷하게 무엇이 좋다고 말하기는 어렵습니다.하지만 매우 자주 사용하는 패턴이니 알아두는 편이 좋습니다.다음 코드를 보십시오.if (!options) options = {};앞의 코드는 다음과 같이 쓸 수 있습니다.options = options || {};"
}, 

{
"id": "-javascript-2020-04-27-javascript100",
"title": "5.12 템플릿 문자열과 표현식",
"author": null,
"tags": [],
"url": "/javascript/2020/04/27/javascript100/",
"date": "2020-04-27",
"content": "3장에서 템플릿 문자열을 설명하면서 어떤 표현식이든 그 값을 문자열에 넣을 수 있다고 언급했습니다.3장에서 예제로 사용한 템플릿 문자열은 현재 온도를 표시하는 문자열이었습니다.온도가 얼마나 변했는지 표시하거나, 섭씨 대신 화씨 온도를 표시하고 싶다면 어떻게 해야 할까요?템플릿 문자열 안에 표현식을 사용하면 됩니다.const roomTempC = 21.5;let currentTempC = 19.5;const message = `The current temperature is ` +\t`${currentTempC - roomTempC}\\u00b0C different than room temperature.`;const fahrenheit = \t`The current temperature is ${currentTempC * 9/5 + 32}\\u00b0F`;표현식은 값이므로 값이 들어갈 수 있는 곳에는 어디든 표현식을 쓸 수 있습니다."
}, 

{
"id": "-javascript-2020-04-27-javascript99",
"title": "5.11 객체와 배열 연산자",
"author": null,
"tags": [],
"url": "/javascript/2020/04/27/javascript99/",
"date": "2020-04-27",
"content": "객체와 배열, 함수에는 특별한 연산자가 있습니다.점 연산자(.)와 대괄호 연산자([])는 이미 봤고, 나머지 연산자들은 6장과 8장, 9장에서 설명합니다.하지만 이 장은 연산자에 관한 장이니 간단히 요약하고 넘어가겠습니다.[표 5-10]을 보십시오.표 5-10 객체와 배열 연산자            연산자      설명      설명하는 장                  .      점 연산자      3장              []      대괄호 연산자      3장              in      프로퍼티 존재 연산자      9장              new      객체 인스턴스화 연산자      9장              instanceof      프로토타입 체인 테스트 연산자      9장              …      스프레드(확산) 연산자      6, 8장              delete      삭제 연산자      3장      "
}, 

{
"id": "-javascript-2020-04-27-javascript98",
"title": "5.10 해체 할당",
"author": null,
"tags": [],
"url": "/javascript/2020/04/27/javascript98/",
"date": "2020-04-27",
"content": "ES6에서 새로 도입한 해체 할당(destructuring assignment) 은 매우 환영 받는 기능입니다.이 기능은 객체나 배열을 변수로 ‘해체’할 수 있습니다.객체 해체부터 시작합시다.객체 해체// 객체 선언const obj = { b: 2, c: 3, d: 4 };// 해체 할당const {a, b, c} = obj;a; // undefined: obj에는 \"a\" 프로퍼티가 없습니다.b; // 2c; // 3d; // ReferenceError: \"d\"는 정의되지 않았습니다.객체를 해체할 때는 반드시 변수 이름과 객체의 프로퍼티 이름이 일치해야 합니다.프로퍼티 이름이 유효한 식별자인 프로퍼티만 해체 후 할당됩니다.이 예제에서는 obj에 a 프로퍼티가 없으므로 a는 undefined를 할당받습니다.해체 할당에 d라는 프로퍼티가 없으므로 d는 선언조차 되지 않았습니다.이 예제에서는 선언과 할당을 같은 문에서 실행했습니다.객체 해체는 할당만으로 이뤄질 수도 있지만, 그렇게 하려면 반드시 괄호를 써야 합니다.괄호를 쓰지 않으면 자바스크립트는 표현식 좌변을 블록으로 해석합니다.const obj = { b: 2, c: 3, d: 4 };let a, b, c;// 에러가 일어납니다.{ a, b, c } = obj;// 동작합니다.({a, b, c} = obj);배열 해체배열을 해체할 때는 배열 요소에 대응할 변수 이름을 마음대로 쓸 수 있으며 이들은 배열 순서대로 대응합니다.// 배열 선언const arr = [1, 2, 3];// 배열 해체 할당let [x, y] = arr;x; // 1y; // 2z; // ReferenceError: \"z\"는 정의되지 않았습니다.이 예제에서 x는 배열의 첫 번째 요소 값을, y는 두 번째 요소 값을 할당받습니다.그 뒤의 배열 요소는 모두 버려집니다.6장에서 배울 확산 연산자(spread operator(…)를 사용하면 남은 요소를 새 배열에 할당할 수 있습니다.spread 연산자const arr = [1, 2, 3, 4, 5];let [x, y, ...rest] = arr;x; // 1y; // 2rest; // [3, 4, 5]이 예제에서 x와 y는 배열의 처음 두 요소를 받고, 변수 rest에는 나머지가 저장됩니다.배열 해체를 활용하면 변수의 값을 서로 바꿀 수 있습니다.해체를 사용하지 않으면 임시 변수가 필수적인 작업입니다.let a = 5, b = 10;[a, b] = [b, a];a; // 10b; // 5  NOTE_배열 해체는 꼭 배열에만 사용할 수 있는 것은 아닙니다.9장에서 배울 이터러블 객체에는 모두 사용할 수 있습니다.여기서 살펴본 간단한 예제 정도라면 굳이 해체를 사용하지 않고 그냥 변수에 값을 직접 할당하는 게 더 편했을 겁니다.해체의 진가는 다른 곳에서 가져온 객체나 배열에서 원하는 요소를 뽑아내야 할 때 드러납니다.6장에서 그런 예제를 살펴보겠습니다."
}, 

{
"id": "-javascript-2020-04-27-javascript97",
"title": "5.9.4 할당 연산자",
"author": null,
"tags": [],
"url": "/javascript/2020/04/27/javascript97/",
"date": "2020-04-27",
"content": "할당 연산자는 변수에 값을 할당합니다.등호의 왼쪽에 있는 것은(1-value라 부르기도 합니다) 반드시 변수나 프로퍼티며, 배열 요소 중 하나여야 합니다(상수에 값을 할당하는 것은 엄밀히 말해 선언의 일부이며 할당 연산자가 아닙니다).즉, 표현식의 좌변에 있는 것은 반드시 값을 저장할 수 있는 것이어야 합니다.이 장 초반에서 할당 자체도 표현식이며 값을 반환하므로 다시 할당할 수 있다고 설명했습니다.이런 성질을 이용해 할당을 체인으로 연결할 수 있습니다.let v, v0;v = v0 = 9.8;    // 먼저 v0가 9.8이 되고, 그 다음 v가 9.8이 됩니다.// while 문의 조건에 있는 할당을 보십시오. 먼저 n이 nums[i]의 값을 받고,// 다음에는 표현식 전체가 그 값으로 평가되므로 숫자로 비교할 수 있습니다.const nums = [3, 5, 15, 7, 5];let n, i =0;while((n = nums[i]) &lt; 10 &amp;&amp; i++ &lt; nums.length) {\tconsole.log(`Number less than 10: ${n}.`);}console.log(`Number greater than 10 found: ${n}.`);console.log(`${nums.length - i - 1} numbers remain.`);두 번째 예제에서는 할당 연산자의 우선순위가 비교 연산자보다 낮으므로 괄호를 사용했습니다.간편한 할당 연산자일반적인 할당 연산자 외에 연산과 할당을 한꺼번에 수행하는 간편한 할당 연산자도 있습니다.이들 간편 연산자도 일반적인 할당 연산자와 마찬가지로 전체 표현식의 값은 마지막에 이루어진 할당의 값으로 평가됩니다.[표 5-9]에 이들 간편 할당 연산자를 요약했습니다.표 5-9 할당과 연산            연산자      동등한 표현                  x += y      x = x + y              x -= y      x = x - y              x *= y      x = x * y              x /= y      x = x / y              x %= y      x = x % y                  x &lt;&lt;= y      x = x &lt;&lt; y              x &gt;&gt;= y      x = x &gt;&gt; y              x &gt;&gt;&gt;= y      x = x &gt;&gt;&gt; y              x &amp;= y      x = x &amp; y              x |= y      x = x | y              x ^= y      x = x ^ y      "
}, 

{
"id": "-javascript-2020-04-27-javascript96",
"title": "5.9.3 void 연산자",
"author": null,
"tags": [],
"url": "/javascript/2020/04/27/javascript96/",
"date": "2020-04-27",
"content": "void 연산자가 하는 일은 하나뿐입니다.이 연산자는 피연산자를 평가한 후 undefined를 반환합니다.쓸모없는 것 같다고요?네 쓸모없습니다.표현식을 평가해야 하긴 하지만 반환값이 undefined여야 하는 상황이 있다면 void 연산자를 쓸 수도 있겠지만, 필자는 실무에서 그런 경험을 한 적이 한번도 없습니다.필자가 void 연산자를 책에 포함한 이유는 가끔 HTML에서 &lt;a&gt; 태그의 URI에 사용하기 때문입니다.이렇게 하면 브라우저에서 다른 페이지로 이동하는 일을 막을 수 있습니다.&lt;a href=\"javascript:void 0\"&gt;Do nothing&lt;/a&gt;권장하는 방법은 아니지만 가끔 보이기는 할 겁니다."
}, 

{
"id": "-issue-2020-04-27-issue03",
"title": "해쉬링크 오프셋 조정하기",
"author": null,
"tags": [],
"url": "/issue/2020/04/27/issue03/",
"date": "2020-04-27",
"content": "https://mulder21c.github.io/2018/06/11/how-to-adjust-offset-anchor/https://www.w3schools.com/cssref/sel_target.aspHTML 문서 내의 특정 위치로 이동하기 위해 해쉬 링크(hash link)(#link)를 사용하는 것은 아마 웹 퍼블리셔라면 모르는 이가 없을 거다. 그런데 이 해쉬 링크로 이동하는 것은 기본적으로 해당 위치로 스크롤을 이동시키기 때문에 가시적으로 보이는 영역의 최 상단에 걸치게 된다.이것이 본래 기본 기능이기 때문에 크게 문제가 될 것은 없지만, 최근 많이 사용되고 있는 fixed header를 사용하는 경우라면 해당 영역에 가리워지는 형태를 쉽게 만나게 된다.하여, 이번 포스트에서는 해당 현상을 fix하는 방법에 대해 소개하고자 한다. 이 방법은 fixed header의 해결에도 사용할 수 있지만, fixed header가 없는 경우에도 해쉬 링크 이동시 브라우저 상단에 딱 붙는 것을 원치않는 — 이동 위치가 상단에서 약간 떨어지게 하는 효과를 가져올 수도 있다.방법은 단순하다. 해쉬에 해당 하는 요소(element) 위로 여백을 주면 된다. 단, padding을 주게 되면 요소(element)자체의 높이에 영향이 발생하게 되고, 그렇다고 margin을 주게 되면 바로 상위에 위치한 요소(element)와 간격에 영향이 가는 문제가 발생한다. 따라서 요소(element) 자체가 아니라 :before 가상선택자를 이용하여 가상 요소에 관련 스타일을 부여하면 된다.따라서,:target:before {\tcontent: '';\tdisplay: block;\theight: 2em;            /* fixed header 높이 만큼 부여 or 브라우저 상단에서 띄워놓기 원하는 높이 */\tmargin-top: -2em;        /* 위에서 설정한 높이와 동일한 만큼을 음수로 제공 */\tvisibility: hidden;}이렇게 CSS만 적용하면 된다.:target Selector를 사용할 수 없다면, [id], a[name] Selector 를 사용해 볼 수도 있을 듯 하다.단, 이것은 어디까지나 block-level box에 적용되는 방법이다.어디까지나 기본적인 방법에 대해서만 소개를 한 것이고,상황에 따라 어떻게 변형하여 사용할 것인가는 스스로 고민들을 해보시기를…"
}, 

{
"id": "-issue-2020-04-26-issue02",
"title": "[gulp 세팅] php, browsersync reload - 1차 11",
"author": null,
"tags": [],
"url": "/issue/2020/04/26/issue02/",
"date": "2020-04-26",
"content": "  php 서버와 연결gulp-connect-php 모듈 사용  browsersync reload의 다른 방법    const browserSyncReload = (done) =&gt; { browserSync.reload(); done();}        위 함수로 따로 분기  gulpfile.babel.js// 엄격 모드\"use strict\";// 모듈 호출import {src, dest, series, parallel, watch} from 'gulp';import del from 'del';import sass from 'gulp-sass';import spritesmith from 'gulp.spritesmith-multi';import postcss from 'gulp-postcss';import autoprefixer from 'autoprefixer';import imagemin from 'gulp-imagemin';import buffer from 'vinyl-buffer';import config from './config.json';import merge from 'merge-stream';import compressCss from 'gulp-clean-css';// 일반 서버// import connect from 'gulp-connect';// import open from 'gulp-open';// php 서버import phpConnect from 'gulp-connect-php';import browserSync from 'browser-sync';const cleanCss = () =&gt; {    return del(config.path.sass.dest, { force: true })}const cleanImg = () =&gt; {    return del([        `${config.path.spriteImg.dest + config.path            .spriteImg.filename}`,        `${config.path.retinaImg.dest + config.path            .retinaImg.filename}`    ], { force: true })}const sprites = () =&gt; {    let opts = {        spritesmith: function (options, sprite, icons) {            options.retinaSrcFilter = config.path.retinaImg.src;            options.imgPath = config.path.spriteImg.imgPath;            options.imgName = config.path.spriteImg.filename;            options.retinaImgPath = config.path.retinaImg.retinaImgPath;            options.retinaImgName = config.path.retinaImg.filename;            options.cssName = `_${sprite}-mixins.scss`;            options.cssTemplate = '../sass/vendor/spritesmith-mixins.handlebars';            options.cssSpritesheetName = sprite;            options.padding = 4;            options.algorithm = 'binary-tree';            return options        }    }    let spriteData = src(config.path.spriteImg.src)        .pipe(spritesmith(opts))        .on('error', function (err) {            console.log(err)        })    let imgStream = spriteData.img        .pipe(buffer())        .pipe(imagemin())        .pipe(dest(config.path.spriteImg.dest));    let cssStream = spriteData.css        .pipe(dest('../sass/vendor/'));    return merge(imgStream, cssStream);}const sassBuild = () =&gt; {    return src(config.path.sass.src, { sourcemaps: true })        .pipe(sass({            outputStyle: 'compact'        })).on('error', sass.logError)        .pipe(postcss([autoprefixer()]))        .pipe(compressCss({ format: 'keep-breaks' }))        .pipe(dest(config.path.sass.dest, {sourcemaps: true}))        // .pipe(browserSync.reload(        //     {stream: true}        // ))        // .pipe(connect.reload())}const browserSyncReload = (done) =&gt; {    browserSync.reload();    done();}// const htmlReload = () =&gt; {//     return src(config.path.html.src)//         .pipe(dest(config.path.html.src))//         .pipe(browserSync.reload(//             {stream: true}//         ))//         .pipe(connect.reload())// }// 일반 서버// const server = () =&gt; {//     return connect.server({//         root: config.browser.root,//         port: config.browser.port,//         livereload: config.browser.livereload//     })// }//// const browserOpen = () =&gt; {//     const options = {//         uri : `http://localhost:${config.browser.port}`,//         app: config.browser.browser//     };//     return src(config.browser.root)//         .pipe(open(options));// }//// const fileWatch = () =&gt; {//     watch(config.path.html.src, htmlReload)//     watch(config.path.spriteImg.src, series(cleanImg, sprites))//     watch(config.path.sass.src, series(cleanCss, sassBuild));// }// exports.default = series(parallel(cleanImg, cleanCss), sprites, sassBuild, parallel(server, browserOpen, fileWatch));// php 서버const phpServer = () =&gt; {    phpConnect.server({        // browsersync가 프록시를 통해 연결되는 독립형 PHP 서버        // 웹 서버에 액세스하려는 포트입니다. 포트가 이미 사용 중이면 작업이 실패합니다.        port: 8000,        keepalive: true,        base: \"../\"    }, function () {        browserSync({            // php 서버 포트번호와 동일해야됩니다.            proxy: 'localhost:80'        })    })    watch(\"../html/*\", browserSyncReload)    watch(\"../img/order_v3/sprites/\", series(cleanImg, sprites, sassBuild, browserSyncReload))    watch([        \"../sass/\",        \"../sass/vendor/!(_)*.{sass, scss}\"    ], series(cleanCss, sassBuild, browserSyncReload))}exports.default = series(parallel(cleanImg, cleanCss), sprites, sassBuild, phpServer);exports.build = series(parallel(cleanImg, cleanCss), sprites, sassBuild)config.json{  \"browser\": {    \"root\": \"../\",    \"port\" : 90,    \"livereload\": true,    \"browser\": \"chrome\"  },  \"path\": {    \"html\": {      \"src\": \"../html/*.{html, php}\"    },    \"sass\": {      \"src\": \"../sass/**/*.{scss, sass}\",      \"dest\": \"../css/\"    },    \"spriteImg\": {      \"src\": \"../img/order_v3/sprites/*.png\",      \"dest\": \"../img/order_v3/\",      \"filename\": \"sprite.png\",      \"imgPath\": \"../img/order_v3/sprite.png\"    },    \"retinaImg\": {      \"src\": \"../img/order_v3/sprites/*@2x.png\",      \"dest\": \"../img/order_v3/\",      \"filename\": \"sprite@2x.png\",      \"retinaImgPath\": \"../img/order_v3/sprite@2x.png\"    }  }}"
}, 

{
"id": "-javascript-2020-04-24-javascript95",
"title": "5.9.2 typeof 연산자",
"author": null,
"tags": [],
"url": "/javascript/2020/04/24/javascript95/",
"date": "2020-04-24",
"content": "typeof 연산자는 피연산자의 타입을 나타내는 문자열을 반환합니다.애석한 일이지만, 이 연산자는 자바스크립트의 일곱 가지 데이터 타입(undefined, null, 불리언, 숫자, 문자열, 심볼, 객체)을 정확히 나타내지 못하며 끝없는 혼란을 초래했고 계속 비판을 받았습니다.typeof 연산자는 typeof null을 “object”라고 판단하는데, 이런 행동은 버그라고 해도 할 말이 없습니다.null은 당연히 객체가 아니라 원시 값입니다.typeof null이 “object”를 반환하는 이유가 있긴 하지만, 너무 오래됐고 여기서 설명할 만큼 흥미로운 이유도 아닙니다.이 현상을 수정해야 한다는 주장은 아주 많았지만, 이미 typeof null이 “object”를 반환한다는 사실을 이용하는 코드가 너무 많이 생겨서 이제는 돌이킬 수 없게 됐고, 명세에 수록됐으므로 바꿀 수도 없습니다.typeof는 배열과 배열 아닌 객체도 정확히 구분하지 못합니다.함수(객체의 특별한 타입)는 정확히 식별하지만, typeof []는 “object”를 반환합니다.[표 5-8]은 typeof가 반환할 수 있는 값입니다.표 5-8 typeof의 반환값            표현식      반환값      참고                  typeof undefined      “undefined”                     typeof null      “object”      애석하지만 사실입니다.              typeof {}      “object”                     typeof true      “boolean”                     typeof 1      “number”                     typeof “”      “string”                     typeof Symbol()      “symbol”      ES6에서 새로 생겼습니다.              typeof function() {}      “function”               NOTE_typeof는 연산자이므로 괄호는 필요 없습니다.즉 변수 x의 타입을 알아볼 때는 typeof(x) 가 아니라 typeof x를 사용합니다.typeof(x)도 문법적으로는 유효합니다.다만 괄호 때문에 불필요한 표현식이 끼어들 뿐입니다."
}, 

{
"id": "-issue-2020-04-23-issue01",
"title": "git commit 기록 변경하기",
"author": null,
"tags": [],
"url": "/issue/2020/04/23/issue01/",
"date": "2020-04-23",
"content": "git log --oneline5f76815 ~~ (HEAD -&gt; master, origin/master)e6d6d51 ~~  // 내가 변경하고 싶은 커밋기록68b2987 ~~git rebase -i 68b2987   // 변경 원하는 커밋기록 이전 커밋번호git rebase -i  HEAD~2  // HEAD가 가리키고있는 지점이 숫자 1위 명령어까지 입력하면 vi 편집기가 나타나는데,edit e6d6d51 ~~~pick 5f76815 ~~~변경하기 원하는 커밋기록 부분의 pick을 edit로 변경 후esc 키입력 후 :wq 엔터입력여기서부터 다시 커밋기록을 쌓아나가면 된다.추가할 커밋기록이 있으면 추가하고, 커밋 메시지만 수정하고 싶으면 수정하고..여튼 커밋하려면git commit --amend위 명령어 입력왜냐면 내가 수정하고 싶은 e6d6d51 커밋 기록을 수정해야되므로.. 바로 이전 커밋기록 수정한다는 의미그리고git rebase --continue // 이 명령어로 원래 다음 커밋기록이었던 5f76815 커밋기록 불러옴git status // 충돌안났는지 상태 확인 후 git add * // 다시 추가 후git commit -m '커밋메시지'  // 다시 커밋즉, 수정하고 싶은 내역의 커밋기록을 수정 후 ,그 다음 커밋은 다시 재커밋을 실행하여 새롭게 커밋을 쌓아나가는 것이 rebasegit push origin branch이름 -f다른 사람이 아직 보기 전, 또는 pull 받기 전이라면 얼릉 강제 푸시해서 커밋기록을 변경~!그러면 끝~!"
}, 

{
"id": "-issue-2020-04-23-issue00",
"title": "svg 이미지 잘림현상",
"author": null,
"tags": [],
"url": "/issue/2020/04/23/issue00/",
"date": "2020-04-23",
"content": "SVG 이미지 잘림현상입니다.해당 현상은 처음 화면에선 재현되지 않으나 해당 화면을 확대 및 축소하면 특정 구간에서 나타나는 현상입니다.(100% 화면일 때도 나타날지도 모릅니다.. 하지만 발견하진 못했습니다.)해당 이슈 원인을 알아보기 위해 여러 정보를 찾던 중 아래와 같은 글을 발견했습니다.SVG 관련글 링크해당글에 위와 같은 댓글이 달려있었습니다.내용은 SVG를 sprite 이미지로 background-image로 넣을 시 width와 height의 값,그리고 background-position의 값이 소숫점으로 잡히는 경우가 있는데,그럴 때 브라우저마다 랜더링의 차이로 인해 이미지가 잘려보일 수도 있다는 내용이었습니다.즉, 그렇기 때문에 위와 같이 여유 공간을 두어 적용하자는 내용입니다.사실, 위 이슈의 정확한 원인이 무엇인지는 아직 잘 모르겠습니다.직접 저런 이슈를 본 적은 없기 때문입니다.그렇기에 해결법도 맞는 해결법인지를 잘 모르겠습니다.해당 이슈는 좀 더 알아봐야 될 것 같습니다."
}, 

{
"id": "-javascript-2020-04-21-javascript94",
"title": "5.9.1 비트 연산자",
"author": null,
"tags": [],
"url": "/javascript/2020/04/21/javascript94/",
"date": "2020-04-21",
"content": "비트 연산자는 숫자의 비트를 직접 조작합니다.C 같은 저수준 언어를 다뤄 본 경험이 없거나, 컴퓨터가 내부적으로 숫자를 어떻게 저장하는지 배운 적이 없다면 비트 연산자를 이해하기가 힘들 겁니다.비트 연산자에 대해 알고 싶다면 컴퓨터가 숫자를 저장하는 방법에 대해 먼저 알아둬야 합니다.하지만 비트 연산자가 꼭 필요한 경우는 거의 없으므로, 비트 연산자에 대한 이 섹션은 건너뛰거나 훑어보고 넘어가도 상관없습니다.비트 연산자는 피연산자를 2의 보수(two’s complement) 형식으로 저장된 32 비트 부호 붙은 정수(signed integer) 로 간주합니다.자바스크립트의 숫자는 모두 더블 형식이므로 자바스크립트는 비트 연산자를 실행하기 전에 숫자를 먼저 32 비트 정수로 변환하고, 결과를 반환할 때 다시 더블 형식으로 변환합니다.비트 연산자는 논리 연산자 AND와 OR, NOT, XOR 같은 논리 연산을 하지만 이 연산을 정수의 개별 비트에서 수행합니다.이외에도 비트를 다른 위치로 옮기는 시프트(shift) 연산자도 있습니다.표 5-7 비트 연산자            연산자      설명      예제                  &amp;      비트 AND      0b1010 &amp; 0b1100 // 결과 : 0b1000              |      비트 OR      0b1010 | 0b1100 // 결과 : 0b1110              ^      비트 XOR      0b1010 ^ 0b1100 // 결과 : 0b0110              ~      비트 NOT      ~0b1010 // 결과 : 0b0101      다음은 책 내용과 무관하게 비트연산자를 공부하면서 공부한 내용입니다.            &lt; &lt;      왼쪽 시프트      0b1010 &lt; &lt; 1 // 결과 : 0b10100    0b1010 « 2 // 결과: 0b101000              &gt; &gt;      부호가 따라가는(Sign-propagating) 오른쪽 시프트      아래 코드를 보십시오              &gt; &gt; &gt;      0으로 채우는(Zero-fit) 오른쪽 시프트      아래 코드를 보십시오      왼쪽 시프트는 2를 곱하는 효과가 있고, 오른쪽 시프트는 2로 나눈 다음 소수점 아래를 버리는 효과가 있습니다.2의 보수 형식에서 숫자의 가장 왼쪽에 있는 비트는 음수였다면 1이고, 양수였다면 0입니다.따라서 오른쪽 시프트는 두 가지 방법으로 할 수 있습니다.숫자 -22를 예로 들어 봅시다.바이너리 표현을 얻으려면 먼저 양수 22에서 시작해 1의 보수를 얻은 다음 1을 더해 2의 보수를 얻습니다.let n = 22 // 32 비트 바이너리; 0000 0000 0000 0000 0000 0000 0001 0110(2)n &gt;&gt; 1 // 0000 0000 0000 0000 0000 0000 0000 1011(2)n &gt;&gt;&gt; 1 // 0000 0000 0000 0000 0000 0000 0000 1011(2)n = -n // 1의 보수;  1111 1111 1111 1111 1111 1111 1110 1001(2)n++  // 2의 보수;  1111 1111 1111 1111 1111 1111 1110 1010(2)n &gt;&gt; 1 // 1111 1111 1111 1111 1111 1111 1111 0101(2)n &gt;&gt;&gt; 1 // 0111 1111 1111 1111 1111 1111 1111 0101(2)하드웨어를 직접 다루거나 컴퓨터가 내부적으로 숫자를 다루는 방법에 익숙하지 않다면 비트 연산자를 사용할 일은 별로 없을 겁니다.하드웨어 조작을 제외하고 비트 연산자를 쓰는 것이 효율적인 경우는 플래그(불리언 값)를 다룰 때입니다.유닉스에서는 파일에 읽기, 쓰기, 실행 권한을 각각 지정할 수 있습니다.사용자마다 이들 권한이 각각 주어질 수 있으므로 플래그를 사용하는 것이 어울립니다.플래그가 세 개 있으므로 이 정보를 저장하는 데는 비트 세 개가 필요합니다.const FLAG_EXECUTE = 1 // 0b001const FLAG_WRITE = 2 // 0b010const FLAG_READ = 4 // 0b100비트 연산자를 쓰면 숫자형 값 하나로 이들 플래그를 결합하고, 바꾸고, 읽을 수 있습니다.let p = FLAG_READ | FLAG_WRITE; // 0b110let hasWrite = p &amp; FLAG_WRITE; // 0b010 - 참 같은 값let hasExecute = p &amp; FLAG_EXECUTE; // 0b000 - 거짓 같은 값p = p ^ FLAG_WRITE;  // 0b100 -- 쓰기 플래그로 토글 (이제 쓰기 권한이 없습니다)p = p ^ FLAG_WRITE;  // 0b110 -- 쓰기 플래그 토글 (쓰기 권한이 다시 생겼습니다)// 표현식 하나로 여러 플래그를 동시에 판단할 수도 있습니다.const hasReadOrExecute = p &amp; (FLAG_READ | FLAG_EXECUTE);const hasReadAndExecute = p &amp; (FLAG_READ | FLAG_EXECUTE) === FLAG_READ | FLAG_EXECUTE;  그런데 0b001 이렇게 쓰는데 여기서 b가 뭐지..?일반적으로 이진법의 수를 십진법의 수와 구별하기 위해 다음과 같은 방법을 쓴다.100101b (b를 덧붙입(b는 binary의 약자)) (binary란 이진법이라는 뜻)100101(2) ((2)를 덧붙임, 주로 수학에서 쓰임)0b100101 (앞에 0b를 덧붙입, 주로 프로그래밍 언어에서 쓰임)hasReadOrExecute와 hasReadAndExcute 연산자는 그룹으로 묶어야 합니다.AND는 OR 보다 우선순위가 높으므로,OR 연산이 AND 연산보다 먼저 일어나게 하려면 그룹을 써서 우선순위를 강제해야 합니다."
}, 

{
"id": "-javascript-2020-04-21-javascript93",
"title": "5.9 연산자 그룹",
"author": null,
"tags": [],
"url": "/javascript/2020/04/21/javascript93/",
"date": "2020-04-21",
"content": "이미 언급했듯 그룹 연산자(괄호)에는 아무 효과도 없지만 연산자 우선순위를 높이거나 명확히 표현하는 데 쓸 수 있습니다.따라서 그룹 연산자는 연산 순서만 바꿀 뿐, 다른 부작용은 전혀 없는 안전한 연산자입니다."
}, 

{
"id": "-javascript-2020-04-21-javascript92",
"title": "5.8.4 쉼표 연산자",
"author": null,
"tags": [],
"url": "/javascript/2020/04/21/javascript92/",
"date": "2020-04-21",
"content": "쉼표 연산자는 표현식을 결합하여 두 표현식을 평가한 후, 두 번째 표현식의 결과를 반환합니다.표현식을 하나 이상 실행해야 하지만 값으로 필요한 것은 마지막 표현식의 결과뿐일 때 쉼표 연산자를 유용하게 쓸 수 있습니다.다음 예제를 보십시오.let x = 0, y = 10, z;z = (x++, y++);이 예제에서 x와 y는 모두 1만큼 늘어나지만, z의 값은 10, 즉 y++가 반환하는 값입니다.쉼표 연산자는 우선순위가 가장 낮은 연산자이므로 괄호를 사용했습니다.여기서 괄호를 사용하지 않았다면 z에는 0(x++가 반환하는 값)이 저장되고 그 다음에 y가 1만큼 늘어났을 겁니다.쉼표 연산자는 for 문에서 표현식을 결합할 때 사용하거나(4장을 보십시오), 함수에서 빠져나오기 전에 여러 가지 작업을 한데 묶을 때 사용합니다(6장을 보십시오).아.. for문 표현식 쉼표 연산자 결합이라면…?for (let i=0; i&lt;arr.length; i++) {}이건가??"
}, 

{
"id": "-javascript-2020-04-21-javascript91",
"title": "5.8.3 조건 연산자",
"author": null,
"tags": [],
"url": "/javascript/2020/04/21/javascript91/",
"date": "2020-04-21",
"content": "조건 연산자는 자바스크립트의 유일한 3항(ternary) 연산자입니다.즉, 이 연산자는 피연산자 세개를 받습니다(다른 연산자는 모두 피연산자 한 개 또는 두 개를 받습니다).조건 연산자는 if … else 문과 동등한 표현식입니다.다음 예제를 보십시오.const doIt = false;const result = doIt ? \"Did it!\" : \"Didn't do it.\";물음표 앞에 있는 첫 번째 피연산자(doIt)가 참 같은 값이면, 이 표현식의 값은 두 번째 피연산자(물음표와 콜론 사이)이며, 거짓 같은 값이면 이 표현식의 값은 세 번째 피연산자(콜론 다음)입니다.초보 프로그래머들은 3항 연산자를 if … else 문을 혼란스럽게 바꿔 놓은 것 아니냐는 식으로 생각하지만, 3항 연산자는 문이 아니라 표현식이므로 다른 표현식과 결합하여 매우 유용하게 사용할 수 있습니다."
}, 

{
"id": "-javascript-2020-04-21-javascript90",
"title": "5.8.2 피연산자가 불리언이 아닐 때 논리 연산자가 동작하는 방법",
"author": null,
"tags": [],
"url": "/javascript/2020/04/21/javascript90/",
"date": "2020-04-21",
"content": "불리언 피연산자를 사용하면 논리 연산자는 항상 불리언을 반환합니다.피연산자가 불리언이 아니라면, 결과를 결정한 값이 반환됩니다.[표 5-5]와 [표 5-6]을 보십시오.표 5-5 불리언이 아닌 피연산자에 대한 AND(&amp;&amp;)의 진위표            x      y      x &amp;&amp; y                  거짓 같은 값      거짓 같은 값      x (거짓 같은 값)              거짓 같은 값      참 같은 값      x (거짓 같은 값)              참 같은 값      거짓 같은 값      y (거짓 같은 값)              참 같은 값      참 같은 값      y (참 같은 값)      표 5-6 불리언 아닌 피연산자에 대한 OR(||)의 진위표            x      y      x || y                  거짓 같은 값      거짓 같은 값      y (거짓 같은 값)              거짓 같은 값      참 같은 값      y (참 같은 값)              참 같은 값      거짓 같은 값      x (참 같은 값)              참 같은 값      참 같은 값      x (참 같은 값)      결과를 불리언으로 변환하면 불리언 값을 제공했을 때의 진위표와 같은 결과가 됩니다.논리 연산자의 이런 동작 방식을 활용하는 간편한 팁이 있습니다.다음 패턴은 아주 자주 쓰고, 또 보게 될 겁니다.const options = suppliedOptions || { name: \"Default\" }객체는 항상(빈 객체더라도) 참 같은 값으로 평가됩니다.따라서 suppliedOptions 가 객체이면 options는 suppliedOptions를 가리키게 됩니다.옵션이 제공되지 않으면 즉 suppliedOptions 가 null이나 undefined라면 options는 기본값을 갖게 됩니다.NOT 은 불리언이 아닌 값을 반환할 수 없으므로 ! 연산자는 피연산자의 타입이 무엇이든 항상 불리언을 반환합니다.피연산자가 참 같은 값이면 false를, 거짓 같은 값이면 true를 반환합니다."
}, 

{
"id": "-javascript-2020-04-21-javascript89",
"title": "5.8.1 단축 평가",
"author": null,
"tags": [],
"url": "/javascript/2020/04/21/javascript89/",
"date": "2020-04-21",
"content": "AND 연산에 대한 진위표를 보면 두 값을 모두 평가하지 않아도 될 때가 있음을 알 수 잇ㅆ브니다.x가 거짓 같은 값이면 x &amp;&amp; y는 y의 값을 평가할 필요도 없이 false입니다.마찬가지로 x || y 에서 x가 참 같은 값이면 y를 평가할 필요도 없이 true입니다.자바스크립트는 정확히 이런 방식으로 동작하며, 이런 동작을 단축 평가(short-circuit evaluation) 라고 합니다.단축 평가가 중요한 이유는 뭘까요?두 번째 피연산자에 부수 효과(side effect) 가 있다 하더라도 단축 평가를 거치면 그 효과는 일어나지 않기 때문입니다.부수 효과는 보통 부정적인 의미로 쓰이지만 항상 그런 건 아닙니다.결과가 의도적이고 명확하다면 나쁘게 평가할 이유는 없습니다.표현식에서 부수 효과는 증가, 감소, 할당, 함수 호출에서 일어날 수 있습니다.증가와 감소 연산자는 이미 살펴봤으니 이들에 관한 예제를 봅시다.const skipIt = true;let x = 0;const result = skipIt || x++;예제의 세 번째 행의 결과는 result에 저장됩니다.첫 번째 피연산자가 skipIt이 true이므로 result 도 true입니다.우리가 주목할 점은, 세 번째 행에서 단축 평가가 일어나므로 증가 연산자에 해당 표현식을 실행되지 않고 x의 값은 그대로 0이라는 겁니다.skipIt을 false로 바꾸면 논리 연산자의 두 피연산자를 모두 평가해야 하고, 따라서 x는 증가합니다.여기서는 증가 연산이 부수 효과입니다.AND에서도 같은 일이 일어날 수 있습니다.const doIt = false;let x = 0;const result = doIt &amp;&amp; x++;AND의 첫 번째 피연산자가 false이므로 이번에도 자바스크립트는 두 번째 피연산자를 평가하지 않습니다.따라서 result는 false이고, x는 늘어나지 않습니다.doIt을 true로 바꾸면 어떻게 될까요?자바스크립트는 두 피연산자를 모두 평가해야 하므로 증가 연산이 일어나고, result는 0이 됩니다.잠깐, 뭐라구요?result가 false가 아니라 0이라구요?이 질문에 대한 답이 다음 섹션의 내용입니다."
}, 

{
"id": "-javascript-2020-04-21-javascript88",
"title": "5.8 AND, OR, NOT",
"author": null,
"tags": [],
"url": "/javascript/2020/04/21/javascript88/",
"date": "2020-04-21",
"content": "자바스크립트가 지원하는 논리 연산자는 AND(&amp;&amp;)와, OR(||), NOT(!) 세 가지입니다.수학을 공부했다면 AND는 교집합(conjunction), OR은 합집합(disjunction), NOT은 부정(negation)으로 이해할 수 있을 겁니다.(거의) 무한한 숫자와 달리 불리언은 단 두 가지 밖에 없으므로 논리 연산은 진위표(truth table) 로 나타낼 때가 많습니다.[표 5-2]부터 [표 5-4]까지를 보십시오.표 5-2 AND(&amp;&amp;) 연산의 진위표            x      y      x &amp;&amp; y                  false      false      false              false      true      false              true      false      false              true      true      true      표 5-3 OR(||) 연산의 진위표            x      y      x || y                  false      false      false              false      true      true              true      false      true              true      true      true      표 5-4 NOT(!) 연산의 진위표            x      !x                  false      true              true      false      테이블을 보면 AND 연산은 피연산자가 모두 true일 때만 true이고, OR 연산은 피연산자가 모두 false일 때만 false임을 알 수 있습니다.NOT은 단순히 피연산자를 반대로 바꿉니다.피연산자가 모두 true이면 결과도 true이기 때문에 OR 연산자는 가끔 포괄적(inclusive) OR이라 불리기도 합니다.배타적(exclusive) OR, 또는 XOR이라 불리는 OR도 있습니다.이 연산자는 피연산자가 모두 true이면 false를 반환합니다. 자바스크립트에는 XOR에 해당하는 논리 연산자가 없지만, 나중에 설명할 비트 XOR은 있습니다.  TIP변수 x와 y의 XOR 연산이 필요하다면 동등한 표현식(x || y) &amp;&amp; x !== y를 사용하면 됩니다."
}, 

{
"id": "-javascript-2020-04-21-javascript87",
"title": "5.7.1 참 같은 값과 거짓 같은 값",
"author": null,
"tags": [],
"url": "/javascript/2020/04/21/javascript87/",
"date": "2020-04-21",
"content": "‘참 같은 값’과 ‘거짓 같은 값’이란 개념이 있는 언어도 많고, C 언어처럼 불리언 타입이 아예 존재하지 않는 언어도 있습니다.  C 언어에서 숫자 0은 false이고다른 숫자형 값은 모두 true입니다.자바스크립트는 이들을 적절히 혼합한 방식을 취합니다.자바스크립트에서는 모든 데이터 타입을 참 같은 값과 거짓 같은 값으로 나눌 수 있습니다.자바스크립트에서 거짓 같은 값은 다음과 같습니다.  undefined  null  false  0  NaN  ’’ (빈문자열)이들 외에는 모두 참 같은 값입니다.참 같은 값은 정말 많으므로 전부 나열할 수 없지만 몇 가지는 염두에 두어야 합니다.  모든 객체, valueOf() 메서드를 호출했을 때 false를 반환하는 객체도 참 같은 값에 속합니다. valueOf() 설명  배열, 빈 배열도 참 같은 값에 속합니다.(역주_ 빈 배열은 참 같은 값이지만, [] == false는 true입니다.)  공백만 있는 문자열 (“ “) 등  문자열 “false”문자열 “false”가 true라는 사실에 놀라는 사람들이 있지만, 이를 제외하면 대부분 직관적으로 이해할 수 있고 기억하기도 쉬운 편입니다.한 가지 예외를 더 들자면 빈 배열이 참 같은 값이라는 사실입니다.빈 배열 arr이 거짓 같은 값으로 평가되길 원한다면 arr.length를 쓰십시오.빈 배열에서 이 프로퍼티를 호출하면 0을 반환하며 이는 거짓 같은 값입니다."
}, 

{
"id": "-javascript-2020-04-21-javascript86",
"title": "5.7 논리 연산자",
"author": null,
"tags": [],
"url": "/javascript/2020/04/21/javascript86/",
"date": "2020-04-21",
"content": "우리가 익숙한 산술 연산자는 무한히 많은(컴퓨터의 메모리는 유한하므로 정확히 말한다면 아주 많은) 숫자를 다룰 수 있지만, 논리 연산자는 불리언 값만 다룰 수 있으며 불리언에는 false와 true 두 가지 값밖에 없습니다.수학에서, 그리고 대부분의 프로그래밍 언어에서 논리 연산자는 불리언 값에서만 동작하며 불리언 값만 반환합니다.반면 자바스크립트의 논리 연산자는 불리언이 아닌 값도 다룰 수 있고, 놀랍게도 불리언이 아닌 값을 반환하기도 합니다.자바스크립트의 논리 연산자가 잘못 만들어져 있거나 엉성한 것은 아닙니다.논리 연산자를 불리언 값에 사용하면 결과는 불리언 값뿐입니다.연산자에 대해 설명하기 전에 자바스크립트가 불리언이 아닌 값을 불리언 값으로 바꾸는 방법에 익숙해져야 합니다."
}, 

{
"id": "-javascript-2020-04-21-javascript85",
"title": "5.6 문자열 병합",
"author": null,
"tags": [],
"url": "/javascript/2020/04/21/javascript85/",
"date": "2020-04-21",
"content": "자바스크립트에서 + 연산자는 덧셈과 문자열 병합에 모두 사용됩니다(이렇게 하는 언어가 매우 많습니다. 펄과 PHP는 문자열 병합을 병합할 때 + 연산자를 쓰지 않는 몇 안되는 언어입니다).자바스크립트는 피연산자의 타입을 보고 덧셈을 할지 문자열 병합을 할지 판단합니다.덧셈과 병합은 모두 왼쪽에서 오른쪽으로 평가합니다.자바스크립트는 두 피연산자를 왼쪽에서 오른쪽으로 평가한 후, 피연산자 중 하나라도 문자열이면 문자열 병합을 수행합니다.두 값이 모두 숫자형이면 덧셈을 합니다.다음 두 행을 보십시오.3 + 5 + \"8\"  // 문자열 \"88\"이 됩니다.\"3\" + 5 + 8 // 문자열 \"358\"이 됩니다.첫 행에서 자바스크립트는 먼저 3 + 5가 덧셈이라고 판단합니다.그 다음에는 8 + “8”을 문자열 병합이라고 판단합니다.두 번째 행에서는 먼저 “3” + 5 를 병합이라고 판단하고,“35” + 8 역시 병합이라고 판단합니다."
}, 

{
"id": "-javascript-2020-04-21-javascript84",
"title": "5.5 숫자비교",
"author": null,
"tags": [],
"url": "/javascript/2020/04/21/javascript84/",
"date": "2020-04-21",
"content": "숫자를 비교할 때는 염두에 두어야 할 것이 있습니다.먼저, 특별한 숫자형 값 NaN은 그 자신을 포함하여 무엇과도 같지 않습니다.즉, NaN === NaN과 NaN == NaN은 모두 false입니다.숫자가 NaN인지 알아보려면 내장된 isNaN 함수를 사용하십시오.isNaN(x) 은 x가 NaN일 때 true를 반환하고 그렇지 않다면 false를 반환합니다.자주 얘기하지만, 자바스크립트의 숫자는 모두 더블 형식입니다.그리고 더블 형식은 근사치이므로, 자바스크립트에서 숫자를 비교하다 보면 경악스러운 결과를 볼 때가 있습니다.자바스크립트에서 정수를 비교할 때, 그 정수가 안전한 범위라면(Number.MIN_SAFE_INTEGER 이상, Number.MAX_SAFE_INTEGER 이하) 안심하고 일치 연산자를 사용할 수 있습니다.하지만 소수점이 있는 숫자를 비교할 때는 관계 연산자를 써서 테스트하는 숫자가 대상 숫자에 ‘충분히 가까운지’ 확인하는 편이 좋습니다.충분히 가깝다는 게 무슨 말이냐고요?때에 따라 다릅니다.자바스크립트에는 특별히 숫자형 상수 Number.EPSILOW이 있습니다.이것은 매우 작은 값(약 2.22e-16)이며, 일반적으로 숫자 두 개를 구별하는 기준으로 사용합니다.다음 예제를 보십시오.let n = 0;while(true) {\tn += 0.1;\tif (n === 0.3) break;}console.log(`Stopped at ${n}`);이 코드를 실행하면 예상 외의 결과에 놀랄 겁니다.이 루프는 0.3에서 멈추지 않고 그 값을 살짝 피한 다음 영원히 실행됩니다.이 결과는 0.1이 더블 형식으로 저확히 나타낼 수 없는 값이기 때문입니다.0.1은 이진 표현으로나타낼 수 있는 숫자들 사이에 걸쳐 있습니다.따라서 이 루프를 세 번째 반복할 때 n의 값은 0.30000000000000004이므로 테스트는 false이고, 유일한 종료 조건이 실패하게 됩니다.Number.EPSILON과 관계 연산자를 사용해서 ‘느슨하게’ 비교하고 성공적으로 루프를 빠져나갈 수 있습니다.let n = 0;while(true) {\tn += 0.1;\tif (Math.abs(n - 0.3) &lt; Number.EPSILON) break;}console.log(`Stopped at ${n}`);테스트하는 숫자(n)에서 비교 대상(0.3)을 뺀 다음 절댓값을 취하는 방식을 썼습니다(Math.abs는 16장에서 설명합니다).그냥 n이 0.3보다 큰지 확인하는 간단한 방법도 있지만, 여기서 사용한 방법은 두 개의 더블 형식이 같다고 할 수 있을 만큼 가까운 숫자인지 판단할 때 일반적으로 사용하는 방법입니다."
}, 

{
"id": "-javascript-2020-04-21-javascript83",
"title": "5.4 비교 연산자",
"author": null,
"tags": [],
"url": "/javascript/2020/04/21/javascript83/",
"date": "2020-04-21",
"content": "비교 연산자는 이름처럼 두 개의 값을 비교합니다.크게 말해 비교 연산자는 일치함(strict equality(===), 동등함(loose equality(==)), 대소 관계의 세 가지 타입으로 나뉩니다(불일치는 일치의 한 종류라고 보기 때문에 다른 타입으로 나누지는 않습니다).초보자들은 일치와 동등의 차이를 이해하지 못하는 경우가 많습니다.먼저 일치에 대해 이해해보기로 합시다.두 값이 같은 객체를 가리키거나, 같은 타입이고 값도 같다면(원시 타입) 이 값을 일치한다고 합니다.일치 관계는 아주 단순하고 이해하기 쉬우므로 버그나 오해를 낳는 경우가 거의 없습니다.두 값이 일치하는지 확인할 때는 === 연산자를 쓰거나 그 반대인 !== 연산자를 씁니다.예제를 살펴보기 전에 먼저 동등 관계를 알아봅시다.한편, 두 값이 같은 객체를 가리키거나 같은 값을 갖도록 변환할 수 있다면 두 값을 동등하다고 합니다.  역주_ 두 값이 같은 객체를 가리킬 때 일치한다고도 하고 동등하다고도 했는데, 좀 이상하게 읽힐 수도 있지만 저자의 설명이 틀린 것은 아닙니다.두 값이 일치하면 당연히 두 값은 동등하기도 합니다.예를 들어 2 === 2는 true이고 2 == 2도 true입니다.앞 부분은 괜찮지만, 두 번째 부분은 수 많은 골칫거리와 혼란을 발생시켰습니다.이따금은 편리할 때도 있습니다.문자열 “33”은 숫자 33으로 변환할 수 있으므로 이 둘은 동등합니다.하지만 타입이 다르므로 일치하지는 않습니다.동등 비교가 편리할 때도 있지만, 이런 편리함 때문에 수많은 부작용이 생길 수 있습니다.따라서 문자열은 미리 숫자로 변환해서 일치하는지 비교하길 권합니다.동등한지 아닌지 비교할 때는 == 연산자나 != 연산자를 사용합니다.동등 연산자 때문에 생기는 문제와 함정을 자세히 알고 싶다면 더글러스 크록포드의 자바스크립트 핵심 가이드(한빛미디어, 2008) 를 권합니다.  TIP동등 연산자 때문에 문제가 생기는 경우는 대개 null과 undefined, 빈 문자열, 숫자 0 때문입니다.위 네 가지 경우에 해당하지 않는 값을 비교한다면 동등 연산자를 써도 안전할 때가 많습니다.하지만 기계적으로 동등 연산자를 쓰는 습관은 빨리 버릴수록 좋습니다.필자가 권하는 대로 일치 연산자만 사용한다면 이런 문제에 대해 생각할 필요도 없습니다.동등 연산자를 써도 안전한지, 아니면 (미세한) 이득이 있는지 생각하느라 중요한 흐름을 방해받지 않아도 됩니다.그냥 일치 연산자를 사용하고 계속 진행하면 됩니다.일치 연산자를 사용했을 때 원하는 결과가 나오지 않으면, 말썽꾸러기인 동등 연산자로 바꾸지 말고 그냥 데이터 타입을 변환하면 됩니다.프로그래밍은 그 자체로도 충분히 힘든 작업입니다.동등 연산자를 써서 불필요한 문제를 초래하지 마십시오.다음은 일치 연산자와 동등 연산자의 예입니다.객체 a와 b에 같은 정보가 들어 있더라도 그들은 서로 다른 객체이며, 일치하지도 않고 동등하지도 않습니다.const n = 5;const s = \"5\";n === s; //false -- 타입이 다릅니다.n !== s;  // truen === Number(s);  // true -- 문자열 \"5\"를 숫자 5로 변환했습니다.n !== Number(s);   // falsen == s;   // true; 권장하지 않습니다.n != s;    // false; 권장하지 않습니다.const a = { name: \"an object\" };const b = { name: \"an object\" };a === b;   // false -- 객체는 항상 다릅니다.a !== b; // truea == b; // false; 권장하지 않습니다.a != b; // true; 권장하지 않습니다.관계 연산자는 관계가 있는 값을 비교하며, 문자열이나 숫자처럼 원래 순서가 있는 데이터 타입에만 사용할 수 있습니다(‘a’는 항상 ‘b’보다 앞에 있습니다).관계 연산자에는 작다(&lt;), 작거나 같다(&lt;=), 크다(&gt;), 크거나 같다(&gt;=) 네 가지가 있습니다.3 &gt; 5; // false3 &gt;= 5; // false3 &lt; 5; // true3 &lt;= 5; // true5 &gt; 5; // false5 &gt;= 5; // true5 &lt; 5; // false5 &lt;= 5; //true"
}, 

{
"id": "-javascript-2020-04-21-javascript82",
"title": "5.3 연산자 우선순위",
"author": null,
"tags": [],
"url": "/javascript/2020/04/21/javascript82/",
"date": "2020-04-21",
"content": "모든 표현식은 값이 된다는 걸 이해했으면, 그 다음은 연산자 우선순위를 이해해야 합니다.연산자 우선순위를 이해해야 자바스크립트 프로그램이 어떻게 동작하는지 이해할 수 있습니다.산술 연산자를 설명했으니 자바스크립트의 여러 연산자에 대한 설명을 잠시 멈추고 연산자 우선순위에 대해 생각해 봅시다.초등 교육을 받았다면 연산자 우선순위에 대해 배웠을 겁니다.다음 문제는 어렵지 않게 풀 수 있을 겁니다.8 / 2 + 3 x (4 x 2 - 1)25라고 답했으면 연산자 우선순위를 정확히 적용한 겁니다.괄호가 제일 먼저고, 그 다음에 곱셈과 나눗셈을 하고, 마지막으로 덧셈과 뺄셈을 합니다.자바스크립트는 표현식을 평가할 때도 비슷한 규칙을 적용합니다.산수에만 쓰는 것은 아닙니다.자바스크립트에서 표현식을 평가하는 순서도 초등학교에서 배웠던 것과 같습니다.물론 자바스크립트에는 연산자가 훨씬 더 많으니 기억할 것이 늘어나기는 합니다.다행히, 산수와 마찬가지로 괄호가 최우선입니다.표현식 순서가 잘 기억나지 않으면, 가장 먼저 이루어져야 하는 순서대로 괄호를 쓰면 그대로 이루어질 겁니다.현재 자바스크립트에는 56개의 연산자가 있고, 우선순위를 기준으로 19개의 그룹으로 묶을 수 있습니다.연산자의 우선순위가 높을수록 먼저 실행됩니다.부록 B에 연산자 우선순위 테이블이 있습니다.필자는 이 테이블을 몇 해에 걸쳐 자연스럽게 기억하게 됐지만, 여전히 가끔 찾아보면서 기억을 되살리기도 하고, 새로운 기능을 배우게 되면 어떤 우선순위가 적용되는지 찾아보기도 합니다.우선순위가 같은 연산자들은 오른쪽에서 왼쪽으로 또는 왼쪽에서 오른쪽으로 평가합니다.예를 들어 곱셈과 나눗셈의 우선순위는 둘 다 14이고, 이들은 왼쪽에서 오른쪽으로 평가합니다.곱셈과 나눗셈이 끝나면 우선순위가 3인 할당 연산자를, 오른쪽에서 왼쪽으로 평가하는 식입니다.이 내용을 염두에 두고 다음 예제의 순서를 생각해 봅시다.let x = 3, y;x += y = 6*5/2;// 이 표현식을 우선순위에 따라 다음에 일어날 행동에 괄호를 치겠습니다.//// 곱셈과 나눗셈, 우선순위 14, 왼쪽에서 오른쪽으로// x += y = (6*5)/2// x += y = (30)/2// x += y = 15// 할당, 우선순위 3, 오른쪽에서 왼쪽으로// x += (y = 15)// x += 15    y는 이제 15입니다.// 18    x는 이제 18입니다.연산자 우선순위를 이해하는 게 처음에는 벅차 보이겠지만, 곧 숨을 쉬듯 자연스러워질 겁니다."
}, 

{
"id": "-javascript-2020-04-20-javascript81",
"title": "5.2 산술 연산자",
"author": null,
"tags": [],
"url": "/javascript/2020/04/20/javascript81/",
"date": "2020-04-20",
"content": "[표 5-1]은 자바스크립트의 산술 연산자입니다.표 5-1 산술 연산자            연산자      설명      예제                  +      덧셈(문자열 병합에도 쓰입니다.)      3 + 2 // 5              -      뺄셈      3 - 2 // 1              /      나눗셈      3/2 // 1.5              *      곱셈      3 * 2 // 6              %      나머지      3 % 2 // 1              -      단항 부정      -x // x의 부호를 바꿉니다. x가 50이면 -x는 -5입니다.              +      단항 플러스      +x // x가 숫자가 아니면 숫자로 변환을 시도합니다.              ++      전위 증가      ++x // x에 1을 더한 다음 평가합니다.              ++      후위 증가      x++ // x를 평가한 다음 1을 더합니다.              –      전위 감소      –x // x에서 1을 뺀 다음 평가합니다.              –      후위 감소      x– // x의 값을 평가한 다음 1을 뺍니다.      자바스크립트의 숫자는 모두 더블 형식자바스크립트의 숫자는 모두 더블 형식이므로 3/2처럼 정수를 연산한 결과도 더블 형식입니다.단항부정과 단항플러스뺄셈과 단항 부정은 모두 - 기호를 사용합니다.그러면 자바스크립트는 둘을 어떻게 구별할까요?답은 매우 복잡하고, 이 책에서 다룰 만한 내용은 아닙니다.우리가 알아야 할 것은 단항 부정이 먼저 이루어지고 그 다음에 뺄셈을 한다는 겁니다.const x = 5;const y = 3 - -x;  // y는 8입니다.같은 규칙이 단항 플러스에도 적용됩니다.단항 플러스 연산자는 자주 사용하는 연산자는 아닙니다.보통 이 연산자를 사용한다면 문자열을 숫자로 강제 변환하는 경우이며, 드물게는 세로로 줄을 맞추고 싶을 때 사용합니다.const s = \"5\";const y = 3 + +s;// y는 8입니다. 단항 플러스를 사용하지 않았다면// 문자열 병합이 일어나서 결과는 \"35\"가 됩니다.// 여기서는 굳이 단항 플러스가 필요하지 않지만 줄을 잘 맞출 수 있습니다.const x1 = 0, x2 = 3, x3 = -1.5, x4 = -6.33;const p1 = -x1*1;const p2 = +x2*2;const p3 = +x3*3;const p4 = -x4*4;필자가 이 예제에서 단항 부정과 단항 플러스를 변수에만 사용한 이유는, 숫자형 리터럴 앞에 있는 -기호는 실제 숫자형 리터럴의 일부로 해석되므로 연산자가 아니기 때문입니다.나머지나머지(remainder) 연산자는 나눗셈을 한 나머지를 반환합니다.표현식의 x % y의 결과는 피제수dividend(x) 를 제수divisor(y) 로 나눈 나머지입니다.예를 들어 10 % 3은 1입니다.음수에 적용하면 결과는 제수가 아니라 피제수의 부호를 따라가므로 이 연산자를 진정한 나머지(modulo) 연산자라 할 수는 없습니다.  역주_ 자바스크립트에는 mod 연산자가 없지만, -10 mod 3은 -1이 아니라 2입니다(구글에서 검색하면 바로 답이 나옵니다.)mod 연산자의 결과가 제수의 부호를 따르는 이유가 궁금하다면 https://goo.gl/FjPtQd를 읽어보시기 바랍니다.번역이 다 된 문서는 아니지만, 문서 중간쯤의 그림을 보시면 무슨 뜻인지 금방 알 수 있습니다.나머지 연산자는 보통 전수 피연산자에만 사용하지만, 자바스크립트에서는 피연산자에 소수점이 있어도 잘 동작합니다.예를 들어 10 % 3.6은 2.8입니다.증가연산자, 감소연산자증가 연산자 ++는 할당 연산자와 덧셈 연산자를 하나로 합친 거나 다름없습니다.마찬가지로 감소 연산자 –는 할당 연산자와 뺄셈 연산자를 하나로 합친 거나 다름없습니다.이들은 간결하고 쓰기 쉽지만 주의해야 합니다.이 연산자가 표현식 깊숙이 묻혀 있다면, 연산자의 부작용을 파악하기 어렵게 될 수 있습니다.전위(prefix)와 후위(postfix)의 차이도 이해해야 합니다.전위 연산자는 먼저 변수의 값을 바꾼 다음에 평가합니다.후위 연산자는 값을 바꾸기 전에 평가합니다.다음 코드를 읽어보고 결과를 맞혀 보십시오.힌트는, 증가와 감소 연산자는 덧셈보다 먼저 실행되며, 이 예제의 표현식은 모두 왼쪽에서 오른쪽으로 진행합니다.let x = 2;const r1 = x++ + x++;const r2 = ++x + ++x;const r3 = x++ + ++x;const r4 = ++x + x++;let y = 10;const r5 = y-- + y--;const r6 = --y + --y;const r7 = y-- + --y;const r8 = --y + y--;계산을 끝냈으면 자바스크립트 콘솔에서 실행해 보십시오.r1과 r8을 모두 맞혔는지, 각 단계에서 x와 y의 값을 맞혔는지 확인해 보십시오.이 연습문제가 어렵게 느껴진다면 종이에 적은 다음, 괄호를 써서 계산 순서를 표시해 보십시오.그리고 그 순서대로 계산한다면 맞출 수 있을 겁니다."
}, 

{
"id": "-javascript-2020-04-20-javascript80",
"title": "5.1 연산자",
"author": null,
"tags": [],
"url": "/javascript/2020/04/20/javascript80/",
"date": "2020-04-20",
"content": "연산자를 표현식의 ‘명사(noun)’ 에 대한 ‘동사(verb)’ 라고 생각해도 좋습니다.표현식이 값이 되는 것이라면 연산자는 값을 만드는 행동이라는 뜻입니다.연산자에 대한 설명은 산술 연산자로 시작하겠습니다.산술 연산자에 대한 경험이 없는 사람은 거의 없으니 직관적으로 이해하기 쉬울 겁니다.  NOTE_ 연산자는 하나 이상의 피연산자가 있어야 결과를 낼 수 있습니다.예를 들어 1 + 2라는 표현식에서 1과 2는 피연산자이고 +는 연산자입니다.엄격히 말하면 피연산자가 맞는 말이지만 피연산자를 매개변수(argument) 라 부르는 경우도 많이 있습니다."
}, 

{
"id": "-javascript-2020-04-20-javascript79",
"title": "5. 표현식과 연산자",
"author": null,
"tags": [],
"url": "/javascript/2020/04/20/javascript79/",
"date": "2020-04-20",
"content": "표현식(expression) 은 값으로 평가될 수 있는 문입니다.즉 결과가 값인 문과, 표현식이 아닌 문의 차이를 이해하는 것이 매우 중요합니다.이 차이를 이해해야만 자바스크립트의 요소들을 효과적으로 조합할 수 있습니다.표현식이 아닌 문(statement) 은 일종의 지시라고 생각할 수 있고, 표현식은 무언가를 요청하는 것이라고 생각할 수 있습니다.자, 직장에 첫 출근했다고 상상해 봅시다.상사가 다가와서 “당신이 할 일은 볼트 A를 너트 B에 끼우는 일입니다.”라고 말합니다.상사가 한 말은 표현식이 아닌 문입니다.상사는 당신에게 조립한 결과물을 요청한 것이 아니라, 그저 조립할 것을 지시했을 뿐입니다.상사가 “볼트 A를 너트 B에 끼우고, 내가 검사할 수 있도록 가져오세요.” 라고 말했다면 그건 표현식입니다.당신은 지시를 받았고, 그 결과를 반환해야 합니다.“어떻든 결과는 마찬가지 아닌가? 조립한 결과를 그냥 두든, 상사에게 가져가든 조립된 건 마찬가지인데.” 라고 생각할 수도 있습니다.프로그래밍 언어라고 상황이 180도 달라지는 건 아닙니다.표현식이 아닌 문도 뭔가를 합니다.하지만 그 결과를 명시적으로 반환하는 것은 표현식입니다.표현식은 값이 됩니다.그 결과를 다른 표현식에 결합해서 다른 값을 얻을 수 있습니다.그 값을 또 다른 표현식에 결합해서 또 다른 값을 얻는 식으로 이어질 수 있습니다.표현식이 아닌 문은 이런 식으로 결합할 수 없습니다.표현식은 값이 되므로 할당에 쓸 수 있습니다.즉, 표현식의 결과를 변수나 상수, 프로퍼티에 할당할 수 있습니다.표현식의 예를 하나 들어 봅시다.곱셈은 표현식입니다.이해하기 쉽겠죠?두 숫자를 곱하면 결과가 나옵니다.매우 단순한 문 두 개를 봅시다.let x;x = 3 * 5;첫 번째 행은 선언문입니다.우리는 변수 x가 있다고 선언했습니다.물론 두 행을 결합할 수 있지만, 그렇게 하면 요점이 잘 드러나지 않습니다.두 번째 행을 잘 봅시다.이 행에는 사실 표현식이 두 개 있습니다.첫 번째 표현식은 3 * 5 입니다.곱셈 표현식이고, 결과는 15입니다.그 다음은 값 15를 변수 x에 할당한 표현식입니다.할당은 그 자체가 표현식입니다.음? 표현식은 값이 된다고 했는데, 그럼 할당 표현식은 어떤 값이 되는 걸까요?물론 할당 표현식도 값이 됩니다.x만 값 15를 할당 받는 것이 아니라, 전체 표현식의 결과도 값 15입니다.할당은 표현식이고, 따라서 값이 되므로, 다른 변수에 다시 할당할 수 있습니다.좀 우스꽝스럽지만, 다음 예제를 보십시오.let x, y;y = x = 3 * 5;이제 x와 y 두 변수가 있고 값은 모두 15입니다.이런 일이 가능한 것은 곱셈과 할당이 모두 표현식이기 때문입니다.자바스크립트는 이렇게 표현식이 결합된 것을 보면 쪼갤 수 있는 만큼 쪼개서 한 부분씩 실행합니다.let x, y;y = x = 3 * 5; //원래 문y = x = 15; // 곱셈 표현식을 평가했습니다.y = 15; // 첫 번째 할당을 평가했습니다. x는 이제 15이고, //y는 아직 undefined입니다.15; // 두 번째 할당을 평가했습니다. y는 이제 15입니다. //전체 문의 결과는 15입니다. 이 값은 사용하지도 않았고 //어딘가에 할당하지도 않았으니 그냥 버려집니다.그러면 이제 자바스크립트는 어떤 원칙으로 표현식을 그런 순서로 실행하는가 하는 의문이 들겁니다.즉, y = x를 먼저 실행해서 y에 값을 undefined를 할당하고 그 다음에 곱셈을 해서 y는 undefined로 남고 x는 15가 될 수도 있지 않느냐는 의문 말입니다.자바스크립트가 표현식을 평가하는 순서를 연산자 우선순위라 부르며, 이 장에서 설명할 겁니다.표현식은 대부분 연산자(operator) 표현식입니다.즉 곱셈 표현식은 곱셈 연산자(*) 와 피연산자(operand) 두 개로 이루어집니다. 피연산자는 서로 곱하는 두 숫자이며 피연산자 자체도 표현식입니다.연산자 표현식이 아닌 표현식에는 식별자 표현식(변수와 상수 이름)과 리터럴 표현식 두 가지가 있습니다.이름만 봐도 알 수 있을 겁니다.변수와 상수, 리터럴은 그 자체가 표현식입니다.표현식은 모두 평등합니다.값이 되는 것은 모두 표현식이므로, 변수와 상수, 리터럴이 모두 표현식인 것은 당연합니다."
}, 

{
"id": "-javascript-2020-04-20-javascript78",
"title": "4.4 요약",
"author": null,
"tags": [],
"url": "/javascript/2020/04/20/javascript78/",
"date": "2020-04-20",
"content": "제어문은 실제로 프로그램이 동작하게 하는 가장 중요한 열쇠입니다.변수와 상수에 중요한 정보가 아무리 많이 들어있다 해도 제어문을 써야 그 데이터에 따라 필요한 선택을 할 수 있습니다.순서도는 프로그램의 흐름을 시각적으로 표현하는 좋은 방법이고, 코드를 작성하기 전에 추상적인 순서도를 그려 보면 문제를 어떻게 해결할지 결정하는 데 도움이 될 수 있습니다.하지만 순서도는 간단하게 그리기가 어려우며, 충분히 훈련된 사람은 프로그램의 흐름을 코드만으로도 자연스럽게 표현할 수 있습니다.사실 순서도를 그리듯, 레고 블록을 조립하듯 시각적으로 프로그램을 만드는 언어를 만들려는 시도는 여러 가지가 있었지만, 텍스트 기반 프로그래밍 언어가 이런 시도에 위협받았던 적은 한 번도 없습니다."
}, 

{
"id": "-javascript-2020-04-20-javascript77",
"title": "4.3.4 배열을 수정할 때 감소하는 인덱스 사용하기",
"author": null,
"tags": [],
"url": "/javascript/2020/04/20/javascript77/",
"date": "2020-04-20",
"content": "배열에 루프를 실행하면서 루프 바디에서 배열을 수정하는 건 위험할 수 있습니다.뜻하지 않게 종료 조건을 바꿀 수도 있으니까요.운이 좋다면 원하지 않는 결과가 나오는 정도겠지만, 운이 나쁘면 무한 루프가 발생할 겁니다.이런 경우 널리 쓰이는 패턴은 감소하는 인덱스를 써서, 배열 마지막 요소에서 루프를 시작하는 방법입니다.이렇게 하면 배열에 요소를 추가하거나 제거해도 종료 조건이 바뀌는 일은 없습니다.예를 들어 bitArrayOfNumbers 에서 찾은 모든 소수를 제거하고 싶다고 합시다.8장에서 배우겠지만, 다음 코드의 splice 메서드는 배열 요소를 추가하거나 제거할 때 사용합니다.이 예제는 예상대로 동작하지 않습니다.for(let i=0; i&lt;bigArrayOfNumbers.length; i++) {\tif(isPrime(bigArrayOfNumbers[i])) bigArrayOfNumbers.splice(i, 1);}인덱스는 점점 커지는데 우리는 요소를 제거하고 있으므로, 소수가 연달아 존재한다면 그중 일부를 제거하지 않고 넘어갈 가능성이 있습니다.감소하는 인덱스를 쓰면 이 문제는 간단히 해결됩니다.for(let i = bigArrayOfNumbers.length-1; i&gt;=0; i--){\tif(isPrime(bigArrayOfNumbers[i])) bigArrayOfNumbers.splice(i, 1);}초기 조건과 종료 조건을 봅시다.배열의 인덱스는 0에서 시작하므로 배열 길이보다 1 작은 값으로 시작해야 합니다.그리고 루프의 종료 조건을 i가 0보다 크거나 같을 때로 정했습니다.그렇지 않다면 이 루프는 배열의 첫 번째 요소에서는 실행되지 않으므로, 첫 번째 요소가 소수라면 문제가 생길 겁니다."
}, 

{
"id": "-javascript-2020-04-20-javascript76",
"title": "4.3.3 루프를 완료한 뒤 인덱스 값 사용하기",
"author": null,
"tags": [],
"url": "/javascript/2020/04/20/javascript76/",
"date": "2020-04-20",
"content": "break 문을 써서 루프를 일찍 종료했을 때 인덱스 변수의 값이 필요할 때가 있습니다.for 루프가 끝나도 인덱스 변수의 값은 그대로 유지된다는 점을 활용할 수 있습니다.이 패턴은 break 문을 써서 루프를 끝내도록 해야만 사용할 수 있습니다.예를 들어 이 패턴을 써서 배열에 들어 있는 첫 번째 소수의 인덱스를 찾을 수 있습니다.let i = 0;for(; i &lt; bigArrayOfNumbers.length; i++){\tif(isPrime(bigArrayOfNumbers[i])) break;}if(i === bigArrayOfNumbers.length) console.log('No prime numbers!');else console.log(`First prime number found at position ${i}`);"
}, 

{
"id": "-javascript-2020-04-19-javascript75",
"title": "4.3.2 break나 return 문을 써서 불필요한 연산 줄이기",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript75/",
"date": "2020-04-19",
"content": "뭔가를 찾기 위해서 루프를 실행했다면, 찾으려는 것을 이미 찾은 후에는 루프 바디를 계속 실행할 필요가 없습니다.예를 들어 봅시다. 어떤 숫자가 소수(prime)인지 판단하는 작업은 CPU 부하가 비교적 높은 일 중 하나입니다.숫자 수천개의 리스트에서 가장 앞에 있는 소수를 찾는다고 했을 때, 다음 코드는 일단 원하는 작업을 하기는 합니다.let firstPrime = null;for(let n of bigArrayOfNumbers){\tif(isPrime(n) &amp;&amp; firstPrime === null) firstPrime = n;}bigArrayOfNumbers에 들어 있는 숫자가 백만 개쯤 되고, 소수는 그 리스트의 마지막쯤에 있다면 이 방법을 써도 상관은 없습니다.하지만 첫 번째 숫자가 소수였다면?아니면, 다섯 번째나 열다섯 번째쯤 있었다면 어떨까요?쓸모없는 작업을 백만번이나 한 셈입니다.생각만 해도 힘이 빠지는 소리군요.break 문을 쓰면 원하는 것을 찾은 즉시 루프에서 빠져나갈 수 있습니다.let firstPrime = null;for(let n of bitArrayOfNumbers){\tif(isPrime(n)){\t\tfirstPrime = n;\t\tbreak;\t}}이 루프가 함수 안에 있었다면 break 대신 return 문을 써도 됩니다."
}, 

{
"id": "-javascript-2020-04-19-javascript74",
"title": "4.3.1 continue 문을 사용하여 조건 중첩 줄이기",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript74/",
"date": "2020-04-19",
"content": "특정 조건이 맞을 때만 루프 바디를 실행해야 할 때가 많습니다.다시 말해 반복문 안에 조건문을 써야 하는 경우입니다.다음 예제를 보십시오.while(funds &gt; 1 &amp;&amp; funds &lt; 100) {\tlet totalBet = rand(1, funds);\tif (totalBet === 13) {\t\tconsole.log(\"Unlucky! Skip this round....\");\t} else {\t\t// 플레이...\t}}이런 경우를 제어문 중첩(nested control flow) 이라 부릅니다.while 루프의 바디에서 할 일은 대부분 else 절에 들어있고, if 절이 하는 일은 console.log를 호출하는 것뿐입니다.continue 문을 써서 이 구조를 간결하게 만들 수 있습니다.while(funds &gt; 1 &amp;&amp; funds &lt; 100) {\tlet totalBet = rand(1, funds);\tif (totalBet === 13) {\t\tconsole.log(\"Unlucky! Skip this round...\");\t\tcontinue;\t}\t// 플레이...}이 단순한 예제에서는 대체 뭐가 좋아졌다는 건지 실감이 잘 안 나겠지만, 루프 바디가 20행 쯤 된다고 생각해 보십시오.중첩을 제거하면 코드를 읽고 이해하기 쉬워집니다."
}, 

{
"id": "-javascript-2020-04-19-javascript73",
"title": "4.3 유용한 제어문 패턴",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript73/",
"date": "2020-04-19",
"content": "이제 자바스크립트의 제어문 기본을 알았으니 널리 쓰이는 패턴에 대해 알아봅시다."
}, 

{
"id": "-javascript-2020-04-19-javascript72",
"title": "4.2.7 for ... of 루프",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript72/",
"date": "2020-04-19",
"content": "for … of 문은 ES6에서 새로 생긴 반복문이며 컬렉션의 요소에 루프를 실행하는 다른 방법입니다.문법은 다음과 같습니다.for (variable of object)\tstatementfor … of 루프는 배열은 물론 (9장에서 설명할) 이터러블(iterable) 객체에 모두 사용할 수 있는 법용적인 루프입니다.다음 예제에서는 배열에 루프를 실행했습니다.const hand = [randFace(), randFace(), randFace()];for (let face of hand)\tconsole.log(`you rolled ... ${face}!`);for … of 는 배열에 루프를 실행해야 하지만 각 요소의 인덱스를 알 필요는 없을 때 알맞습니다.인덱스를 알아야 한다면 일반적인 for 루프를 사용하십시오.const hand = [randFace(), randFace(), randFace()];for (let i = 0; i&lt;hand.length; i++)\tconsole.log(`Roll ${i+1}: ${hand[i]}`);"
}, 

{
"id": "-javascript-2020-04-19-javascript71",
"title": "4.2.6 for ... in 루프",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript71/",
"date": "2020-04-19",
"content": "for … in 루프는 객체의 프로퍼티에 루프를 실행하도록 설계된 루프입니다.문법은 다음과 같습니다.for (variable in object)\tstatement다음 예제를 보십시오.const player = { name: 'Thomas', rank: 'Midshipman', age: 25 };for (let prop in player) {\tif(!player.hasOwnProperty(prop)) continue;\tconsole.log(prop + ': ' + player[prop]);}지금 당장은 혼라스러워 보이겠지만 걱정하지 마십시오.9장에서 이 예제에 대해 더 배우게 됩니다.여기서 player.hasOwnProperty를 호출할 필요는 없지만, 이 메서드를 생략하면 에러가 생길 때가 많습니다.이것 역시 9장에서 설명합니다.지금 당장은 for … in 루프라는 반복문이 있다는 걸 아는 정도로 충분합니다."
}, 

{
"id": "-javascript-2020-04-19-javascript70",
"title": "4.2.5 switch 문",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript70/",
"date": "2020-04-19",
"content": "if … else 문은 두 가지 중 하나를 선택하지만, switch 문은 조건 하나로 여러 가지 중 하나를 선택할 수 있습니다.따라서 참 같은 값/거짓 같은 값보다는 다양하게 나뉘는 조건을 사용합니다.switch 문의 조건은 값으로 평가할 수 있는 표현식 입니다.switch 문의 문법은 다음과 같습니다.switch (expression) {\tcase value1 :\t\t// expression을 평과한 결과가 value1 일 때 실행됩니다.\t\t[break;]\tcase value2 :\t\t// expression을 평가한 결과가 value2일 때 실행됩니다.\t\t[break;]\t\t...\tcase valueN :\t\t// expression을 평가한 결과가 valueN일 때 실행됩니다.\t\t[break;]\tdefault:\t\t// expression을 평가한 결과에 맞는 것이 없을 때 실행됩니다.\t\t[break;]}자바스크립트는 expression을 평가하고 그에 일치하는 첫 번째 case를 찾아서 break, return, continue, throw를 만나거나 swith 문이 끝날 때까지 문을 실행합니다.return과 continue, throw는 나중에 설명합니다.복잡해 보이나요?당신만 그렇게 느끼는 건 아닙니다.switch 문은 그 미묘한 성격 때문에 실수를 초래한다는 비판을 받고 있습니다.초보 프로그래머는 switch 문을 쓰지 말라는 조언을 듣기도 합니다.필자는 switch 문을 적재적소에 쓰기만 하면 매우 유용한 도구라고 생각합니다.물론, 모든 도구가 그렇듯 주의하는 습관을 들여야 하고 알맞은 상황에 써야 합니다.아주 단순한 예제부터 시작해 봅시다.토마스가 숫자에 대한 미신도 갖고 있다면 switch 문을 써서 토마스의 미신을 존중하도록 처리할 수 있습니다.switch (totalBet) {\tcase 7:\t\ttotalBet = funds;\t\tbreak;\tcase 11:\t\ttotalBet = 0;\t\tbreak;\tcase 13:\t\ttotalBet = 0;\t\tbreak;\tcase 21:\t\ttotalBet = 21;\t\tbreak;}지금까지는 아주 단순합니다.토마스는 주머니에서 꺼낸 돈이 11이나 13펜스면 돈을 걸지 않습니다.하지만 13은 11보다 훨씬 불길한 숫자라서, 돈을 걸지 않는 것으로는 모자라고 1펜스를 기부해야 한다면 어떻게 해야 할까요?switch 문을 다음과 같이 바꾸면 됩니다.switch(totalBet) {\tcase 7:\t\ttotalBet = funds;\t\tbreak;\tcase 13:\t\tfunds = funds - 1; // 1펜스를 기부합니다!\tcase 11: \t\ttotalBet = 0;\t\tbreak;\tcase 21:\t\ttotalBet = 21;\t\tbreak;}totalBet이 13이면 1펜스를 기부합니다.그리고 break 문이 없으므로 다음 case 11로 넘어가서 totalBet을 0으로 만듭니다.이 코드는 유효한 자바스크립트이며, 우리가 원하는 일을 정확히 수행합니다.하지만 약점도 있습니다.이 코드는 정확한데도 불구하고 실수처럼 보입니다.동료가 이 코드를 보고 break 문을 깜빡 잊은 거로 생각할 수도 있습니다.그 동료는 break 문을 추가할 테고, 코드는 원하는 대로 동작하지 않게 될 겁니다.break 없는 case 절이 장점보다는 단점이 더 많다고 생각하는 사람들이 많으니, 이 기능을 활용하고 싶다면 항상 주석을 남겨서 의도적으로 break 문을 생략했다는 것을 명확히 하십시오.default 는 특별한 경우입니다.default 절은 일치하는 case 절이 없을 때 실행됩니다.default 절은 필수는 아니지만, 보통 땐 마지막에 사용합니다.switch(totalBet) {\tcase 7:\t\ttotalBet = funds;\t\tbreak;\tcase 13:\t\tfunds = funds - 1; // 1 펜스를 기부합니다!\tcase 11:\t\ttotalBet = 0;\t\tbreak;\tcase 21:\t\ttotalBet = 21;\t\tbreak;\tdefault:\t\tconsole.log(\"No superstition here!\");\t\tbreak;}default 뒤에는 case가 없으므로 break 문이 없어도 되지만, 항상 break 문을 사용하는 게 좋은 습관입니다.언제든 break 문을 주석 처리할 수 있으므로, 설령 break 없는 case 절을 사용하더라도 항상 break 문을 쓰는 습관을 들여야 합니다.break 문이 필요한데도 쓰지 않았다면 매우 찾기 어려운 버그가 생길 수 있습니다.이 규칙의 예외는 switch 문을 함수 안에서 쓸 때뿐입니다.return 문은 즉시 함수를 빠져나가므로 break 문 대신 쓸 수 있습니다.function adjustBet (totalBet, funds) {\tswitch(totalBet) {\t\tcase 7:\t\t\treturn funds;\t\tcase 13:\t\t\treturn 0;\t\tdefault:\t\t\treturn totalBet;\t}}자바스크립트는 공백이 몇 칸이든 신경 쓰지 않으므로 break나 return 문을 실행할 문과 같은 행에 넣으면 switch 문을 더 간결하게 만들 수 있습니다.switch (totalBet) {\tcase 7: totalBet = funds; break;\tcase 11: totalBet = 0; break;\tcase 13: totalBet = 0; break;\tcase 21: totalBet = 21; break;}11펜스와 13펜스일 때 같은 일을 하지만, 여기서는 break 없는 case 절을 쓰지 않았습니다.이렇게 switch 문을 줄바꿈 없이 쓸 때는 case마다 실행문이 하나씩 있고, break 없는 case 절을 쓰지 않아야 의도가 명확하게 드러납니다.switch 문은 표현식 하나로 여러 가지 옵션 중에서 하나를 선택해야 할 때 아주 유용합니다.그렇긴 하지만, 9장에서 동적 디스패치(dynamic dispatch) 에 대해 배우고 나면 switch 문을 그리 많이 쓰지는 않게 될 겁니다."
}, 

{
"id": "-javascript-2020-04-19-javascript69",
"title": "4.2.4 for 루프의 다른 패턴",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript69/",
"date": "2020-04-19",
"content": "쉼표 연산자를 쓰면 초기화와 마지막 표현식에 여러 문을 결합할 수 있습니다.예를 들어 다음 for 루프는 피보나치 수열의 숫자 중 처음 여덟 개를 출력합니다.for (let temp, i =0, j=1; j&lt;30; temp = i, i = j, j = i+temp)\tconsole.log(j);이 예제에서는 초기화를 하면서 변수 temp와 i, j를 동시에 선언했고, 마지막 표현식에서 세 변수를 동시에 조작했습니다.for 루프의 제어부에 아무것도 쓰지 않으면 무한 루프가 만들어집니다.for(;;) console.log(\"I will repeat forever!\");for 루프에서 조건을 생략하면 항상 true로 평가되므로 루프를 빠져나갈 수 없습니다.for 루프는 보통 정수 인덱스를 늘이거나 줄이면서 반복하지만, 꼭 그래야 하는 건 아닙니다.어떤 표현식이든 쓸 수 있습니다.다음 예제를 보십시오.let s = '3';       // 숫자가 들어있는 문자열for(; s.length&lt;10; s = ' ' + s);    // 문자열의 길이를 조건으로 썼습니다.                                    // 여기서 사용한 for 루프 마지막에 세미콜론이 없으면\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    // 에러가 일어납니다.\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (let x= 0.2; x&lt;3.0; x +=0.2)    // 제어 변수가 정수가 아니어도 괜찮습니다.\tconsole.log(x);\tfor (; !player.isBroke;)   // 조건에 객체 프로퍼티를 썼습니다.\tconsole.log(\"Still playing!\");for 루프는 모두 while 루프로 고쳐 쓸 수 있습니다.예를 들어 다음 코드를 보십시오.for([initialization]; [condition]; [final-expression])\tstatement앞에서 본 코드는 다음 코드와 똑같이 동작합니다.[initialization]while([condition]) {\tstatement\t[final-expression]}for 루프를 while 루프를 바꿀 수 있다는 것뿐이지, 그렇게 해야 한다는 건 아닙니다.for 루프의 장점은 루프의 제어부가 첫 번째 행에 모여 있어서 일목요연하게 파악할 수 있다는 겁니다.또한, for 루프에서는 let으로 초기화한 변수가 for 루프 안에서만 유효하다는 장점도 있습니다(7장에서 더 설명합니다).이런 for문을 while 문으로 바꾸면, 컨트롤 변수는 루프 바깥에서도 볼 수 있게 됩니다."
}, 

{
"id": "-javascript-2020-04-19-javascript68",
"title": "4.2.3 메타 문법",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript68/",
"date": "2020-04-19",
"content": "메타 문법(metasyntax) 은 다른 문법을 설명하는 문법입니다.컴퓨터 과학을 공부한 사람은 이 설명을 보고 즉시 ‘배커스-나우르 표기법 확장(EBNF, Extended Backus-Naur Form)’을 떠올렸을 겁니다.단순한 개념에는 어울리지 않게 거창한 이름이죠.이 장에서는 메타 문법을 써서 자바스크립트 제어문의 문법을 간결하게 표기합니다.필자가 사용할 메타 문법은 단순하고 비공식적입니다.사실 중요한 건 이 문법이 모질라 개발자 네트워크(MDN)의 자바스크립트 문서에서 사용하는 문법이라는 겁니다.(https://developer.mozilla.org/en-US/docs/Web/JavaScript)자바스크립트를 공부하다 보면 MDN을 찾아볼 일이 아주 많을 테니, 여기 익숙해지면 도움이 될 겁니다.이 메타 문법에서 기억할 것은 두 가지뿐입니다.대괄호([])로 감싼 것은 옵션이고, 생략 부호(…)는 ‘여기 들어갈 내용이 더 있다’ 는 뜻입니다.단어는 플레이스홀더로 사용하며 그 의미는 문맥에서 알 수 있습니다.예를 들어 statement1과 statement2는 두 개의 서로 다른 문이고 expression은 어떤 값이 되는 것이며, condition은 참 같은 값 또는 거짓 같은 값으로 취급할 표현식입니다.  TIP 블록 문도 문이므로, 문을 쓸 수 있는 곳에는 항상 블록 문도 쓸 수 있습니다.우리는 이미 몇 가지 제어문에 익숙하니 그들의 메타 문법부터 봅시다.while 문while(condition)\tstatementcondition 이 참 같은 값이면 statement를 실행합니다.if … else 문if (condition)\tstatement1[else\tstatement2]condition이 참 같은 값이면 statement1을 실행하고, 그렇지 않고 else 부분이 있다면 statement2를 실행합니다.do … while 문do\tstatementwhile(condition);statement는 최소한 한 번 실행하고, condition이 참 같은 값인 동안 반복해서 실행합니다.for 문for([initialization]; [condition]; [final-expression])\tstatement루프에 들어가기 전에 initialization을 실행합니다.condition이 true인 동안 statement를 실행하고, final-expression을 실행한 다음 condition을 다시 체크합니다."
}, 

{
"id": "-javascript-2020-04-19-javascript67",
"title": "4.2.2 if...else 문을 체인으로 연결하기",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript67/",
"date": "2020-04-19",
"content": "if…else 문을 체인으로 연결하는 것은 사실 특별한 문법은 아닙니다.단순히 if…else 문을 연달아 쓰고, 각 else 절이 다음 if…else 문을 포함할 뿐입니다.하지만 정말 많이 쓰이므로 언급할 가치는 충분합니다.예를 들어 토마스는 자신이 수요일에는 운이 나쁘다는 미신을 믿고 있어 딱 1펜스씩만 건다고 하면, 다음과 같이 if…else 체인으로 나타낼 수 있습니다.if (new Date().getDay() === 3) { // new Date().getDay()는 현재 요일에 해당하는 숫자를 반환합니다. 0은 일요일입니다.\ttotalBet = 1;} else if (funds === 7) {\ttotalBet = funds;} else {\tconsole.log(\"No superstition here!\");}이런 식으로 if … else 문을 결합하면 두 가지 중에서 하나를 선택하는 것이 아니라 세 가지 중에서 하나를 선택할 수 있습니다.예민한 독자라면 블록 아닌 문과 블록 문을 섞어 쓰지 말라는 규칙을 어겼다고 지적할 수도 있습니다.하지만 이건 예외입니다.널리 쓰이는 패턴이고, 혼란을 초래하지도 않습니다.물론 다음과 같이 블록 문만 사용하게 고쳐 쓸 수 있지만, 코드가 더 명확해지기는 커녕 복잡해지기만 했습니다.if (new Date().getDay() === 3) {\ttotalBet = 1;} else {\tif (funds === 7) {\t\ttotalBet = funds;\t} else {\t\tconsole.log(\"No superstition here!\");\t}}"
}, 

{
"id": "-javascript-2020-04-19-javascript66",
"title": "4.2.1 제어문의 예외",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript66/",
"date": "2020-04-19",
"content": "제어문의 일반적인 실행 방식을 바꾸는 네 가지 문이 있습니다.이들은 일종의 조커라고 생각해도 됩니다.  break루프 중간에 빠져나갑니다.  continue루프에서 다음 단계로 바로 건너뜁니다.  return제어문을 무시하고 현재 함수를 즉시 빠져나갑니다. 6장을 보십시오.  throw예외 핸들러에서 반드시 처리해야 할 예외(exception) 를 일으킵니다. 예외 핸들러는 현재 제어문 바깥에 있어도 상관없습니다. 11장을 보십시오.각 문의 사용법은 이 장을 진행하면서 명확히 이해하게 될 겁니다.지금은 이들이 앞으로 설명할 제어문의 일반적인 동작 방식을 벗어난다는 것만 기억하면 됩니다."
}, 

{
"id": "-javascript-2020-04-19-javascript65",
"title": "4.2 자바스크립트의 제어문",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript65/",
"date": "2020-04-19",
"content": "이제 제어문이 어떤 일을 하는지 확실히 알았고 가장 기본적인 것들을 사용해 봤으니 자바스크립트의 제어문에 대해 자세히 알아봐도 될 것 같습니다.그리고 이제 순서도는 그만 그릴 겁니다.순서도는 훌륭한 시각화 도구이고, 그림을 통해 배우는데 익숙한 사람에게는 특히 알맞지만, 여기서부터는 순서도로 나타내기 어려운 것들이 많이 등장할 겁니다.제어문은 크게 말해 조건문과 반복문 두 가지 범주로 나뉩니다.조건문에는 이미 본 if와 if…else 문이 있고, 그 외에 곧 살펴볼 switch 문이 있습니다.조건문은 말하자면 갈림길과 같습니다.선택할 수 있는 길이 몇 가지 있으면 그 중 하나를 선택할 뿐, 다른 곳에는 갈 수 없습니다.반복문에는 while과 do…while, for 루프가 있습니다.이들은 조건이 맞는 동안 바디를 계속 반복합니다."
}, 

{
"id": "-javascript-2020-04-19-javascript64",
"title": "4.1.9 하나로 합치기",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript64/",
"date": "2020-04-19",
"content": "순서도를 모두 합치려면 아주 큰 종이가 필요하겠지만, 프로그램을 합치는 건 매우 쉽습니다.다음 프로그램에는 console.log 를 호출하는 부분이 들어있습니다.이 함수는 토마스가 게임을 어떻게 진행하고 있는지 알아보려고 넣은 겁니다.지금 당장 console.log에 대해 이해할 필요는 없습니다.책을 진행하면서 고급 테크닉을 배우다 보면 자연히 알게 됩니다.토마스가 지금 몇 판째 게임을 하는지 알아보는 round 변수도 추가했습니다.// m 이상 n 이하의 무작위 정수를 반환합니다.function rand(m, n) {\treturn m + Math.floor((n - m + 1) * Math.random());}// 크라운 앤 앵커 게임의 여섯 그림 중 하나에 해당하는 문자열을 무작위로 반환합니다.function randFace() {\treturn [\"crown\", \"anchor\", \"heart\", \"spade\", \"club\", \"diamond\"]\t\t[rand(0, 5)];}let funds = 50; // 시작 조건let round = 0;while(funds &gt; 1 &amp;&amp; funds &lt; 100) {\tround++;\tconsole.log(`round ${round}:`);\tconsole.log(`\\tstarting funds: ${funds}p`);\t// 돈을 겁니다.\tlet bets = { crown: 0, anchor: 0, heart: 0, spade: 0, club: 0, diamond: 0};\tlet totalBet = rand(1, funds);\tif (totalBet === 7) {\t\ttotalbet = funds;\t\tbets.heart = totalBet;\t} else {\t\t// 판돈을 나눕니다.\t\tlet remaining = totalBet;\t\tdo {\t\t\tlet bet = rand(1, remaining);\t\t\tlet face = randFace();\t\t\tbets[face] = bets[face] + bet;\t\t\tremaining = remaining - bet;\t\t} while (remaining &gt; 0)\t}\tfunds = funds - totalBet;\tconsole.log('\\tbets: ' + Object.keys(bets).map(face =&gt; `${face}: ${bets[face]} pence`).join(', ') + ` (total: ${totalBet} pence)`);\t// 주사위를 굴립니다.\tconst hand = [];\tfor (let roll = 0; roll &lt; 3; roll++) {\t\thand.push(randFace());\t}\tconsole.log(`\\thand: ${hand.join(', ')}`);\t// 딴 돈을 가져옵니다.\tlet winnings = 0;\tfor (let die=0; die&lt; hand.length; die++) {\t\tlet face = hand[die];\t\tif(bets[face] &gt; 0) winnings = winnings + bets[face];\t}\tfunds = funds + winnings;\tconsole.log(`\\twinnings : ${winnings}`);}console.log(`\\tending funds: ${funds}`);"
}, 

{
"id": "-javascript-2020-04-19-javascript63",
"title": "4.1.8 if 문",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript63/",
"date": "2020-04-19",
"content": "이제 거의 다 됐습니다!돈도 걸었고 주사위도 굴렸습니다.이제 남은 일은 딴 돈을 가져오는 것뿐입니다.hand 배열에는 무작위로 선택된 그림(face) 이 세 개 있습니다.따라서 for 루프를 한 번 더 써서 이 중에 맞춘 것이 있는지 알아봐야 합니다.if 문을 사용하면 됩니다.이번에는 else 절이 필요 없습니다.마지막 순서도는 [그림 4-6]과 같습니다.if…else 문과 if 문의 차이를 보십시오.if…else 문에서는 모든 분기가 행동으로 연결됐지만, if 문에서는 분기 중 하나만 행동으로 연결됩니다.이 순서도를 코드로 옮기면 게임이 완성됩니다.let winnings = 0;for (let die=0; die&lt;hand.length; die++) {\tlet face = hand[die];\tif(bets[face] &gt; 0) winnings = winnings + bets[face];}funds = funds + winnings;여기서는 for 루프의 조건을 체크할 때 3보다 작은지 확인하지 않고 hand.length 보다 작은지 확인했습니다(3이긴 합니다만).이 부분의 목적은 맞춘 것이 있는지 체크하는 것입니다.지금은 주사위를 세 번 굴리는 것이 게임의 규칙이지만, 규칙이 바뀔 수도 있고, 보너스로 주사위를 더 굴린다거나 벌칙으로 주사위 숫자를 제한할 수도 있을 겁니다.요점은 이겁니다.이 코드를 더 범용적으로 만들기가 쉬워집니다.규칙을 바꿔서 주사위를 굴리는 횟수가 달라지더라도 이 코드를 고칠 필요는 없습니다.주사위를 몇 번 굴리든 상관없이 이 코드는 우리가 원하는 대로 동작합니다."
}, 

{
"id": "-javascript-2020-04-19-javascript62",
"title": "4.1.7 for 루프",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript62/",
"date": "2020-04-19",
"content": "토마스는 이번 판에 걸 돈을 다 걸었습니다!이제 주사위를 굴릴 시간입니다.for 루프는 대단히 유연하며 while 루프나 do…while 루프는 모두 for 루프로 고쳐쓸 수 있습니다.하지만 for 루프가 가장 잘 어울리는 경우는 어떤 일을 정해진 숫자만큼 반복하려 할 때, 특히 그 일을 지금 몇 번째 하는지 알아야 할 때입니다.즉, 주사위를 정해진 숫자만큼(여기서는 세 번) 굴릴 때도 for 루프가 가장 알맞습니다.순서도부터 그려봅니다.[그림 4-5]를 보십시오.for 루프는 세 부분으로 나뉩니다.각 부분은 초기화(roll = 0), 조건(roll &lt; 3), 마지막 표현식(roll++) 입니다.while 루프로도 할 수 있는 일이지만, 루프를 제어하는 모든 요소가 한 곳에 있어서 편리합니다.자바스크립트로 바꾸면 다음과 같습니다.const hand = [];for (let roll = 0; roll &lt; 3; roll++) {\thand.push(randFace());}프로그래머들은 항상 0부터 시작하는 버릇이 있습니다.우리도 주사위 횟수를 0에서 시작해 2로 끝냅니다.  TIP for 루프에서 반복 횟수를 나타내는 변수 이름에는 무엇이든 쓸 수 있지만, 인덱스의 약자인 i를 쓰는 사람이 많습니다.여기서는 주사위를 굴리고 있다는 것이 명확히 나타나도록 roll 을 사용했지만, 이 예제를 처음 만들 때는 습관적으로 i 부터 썼다는 걸 고백합니다."
}, 

{
"id": "-javascript-2020-04-19-javascript61",
"title": "4.1.6 do...while 루프",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript61/",
"date": "2020-04-19",
"content": "토마스가 우연히 7펜스를 꺼내지 않았다면 무작위로 사각형에 돈을 걸어야 합니다.토마스는 판돈을 나눌 때도 범상치 않습니다.오른손에 동전을 쥐고 왼손으로 그 동전을 집지만, 세지는 않습니다.잡히는 대로 집어서 아무 사각형에나 걸기 때문에, 때로는 동전 한 개를 걸 때도 있고 오른손에 쥔 동전 전부를 걸 때도 있습니다.같은 사각형에 여러 번 걸 때도 있습니다.무작위로 판돈을 나누는 행동을 순서도에 반영하면 [그림 4-4]와 같습니다.while 루프와의 차이를 보십시오.시작하면서 조건을 검사하지 않고 마지막에 검사합니다.do… while 루프는 루프 바디를 최소 한 번은 실행하려 할 때 사용합니다.while 루프의 조건이 거짓 같은 값으로 시작하면 루프 바디는 한 번도 실행되지 않습니다.이제 자바스크립트를 봅시다.let remaining = totalBet;do {\tlet bet = rand(1, remianing);\tlet face = randFace();\tbets[face] = bets[face] + bat;\tremaining = remaining - bet;} while(remaining &gt; 0);"
}, 

{
"id": "-javascript-2020-04-19-javascript60",
"title": "4.1.5 if...else 문",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript60/",
"date": "2020-04-19",
"content": "이제 순서도에서 ‘돈을 거는’ 행동을 만들어 봅시다.토마스는 어떻게 돈을 걸까요?토마스는 오른쪽 주머니에 손을 집어넣고 잡히는 대로 돈을 꺼냅니다.동전 한 개만 나올 때도 있겠고, 가진 돈 전체가 나올 때도 있을 겁니다.이 돈이 그가 이번 판에 거는 돈입니다.하지만 토머스는 선원답게 미신을 믿는 편이고, 숫자 7은 행운의 상징이라고 철석같이 믿습니다.따라서 우연히 7펜스가 나오면, 토마스는 이것이 대박을 칠 조짐이라 생각하며 주머니에 있는 돈을 모두 털어 하트에 겁니다.그렇지 않다며 아무렇게나 돈을 겁니다(이 행동은 다음으로 미룹시다).중앙의 결정 노드(totalBet === 7)는 if… else 문에 해당합니다.while 문과 달리 if… else 문 자체에는 반복 기능이 없습니다.판단하고, 그에 따라 움직입니다.이 순서도를 자바스크립트로 바꾸면 다음과 같습니다.const bets = { crown: 0, anchor: 0, heart: 0, spade: 0, club: 0, diamond: 0 };let totalBet = rand(1, funds);if (totalBet === 7) {\ttotalBet = funds;\tbets.heart = totalBet;} else {\t// 그 판에 걸 돈을 분배합니다.}funds = funds - totalBet;else 절은 if… else 문의 옵션입니다. 여기에 대해서는 나중에 다시 설명합니다."
}, 

{
"id": "-javascript-2020-04-19-javascript59",
"title": "4.1.4 보조 함수",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript59/",
"date": "2020-04-19",
"content": "이 장의 예제에는 보조 함수(helper function) 두 개가 필요합니다.우리는 아직 함수나 의사 난수 발생기에 대해 배우지 않았습니다.이들에 대해서는 나중에 다시 설명합니다.지금은 다음 보조 함수를 그대로 가져다 쓰십시오.// m 이상 n 이하의 무작위 정수를 반환합니다.function rand(m, n) {\treturn m + Math.floor((n - m + 1) * Math.random());}// 크라운 앤 앵커 게임의 여섯 가지 도형 중 하나를 무작위 반환합니다.function randFace() {\treturn [\"crown\", \"anchor\", \"heart\", \"spade\", \"club\", \"diamond\"]\t\t[rand(0, 5)];}"
}, 

{
"id": "-javascript-2020-04-19-javascript58",
"title": "4.1.3 공백",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript58/",
"date": "2020-04-19",
"content": "대부분의 경우 자바스크립트는 줄바꿈 문자를 포함해, 추가 공백을 신경 쓰지 않습니다.(return 문 뒤에 줄바꿈 문자를 쓰면 문제가 생깁니다. 여기에 대해서는 6장에서 더 설명합니다.)스페이스 하나는 스페이스 10개나 마찬가지고, 스페이스 10개나 빈줄 10개나 마찬가지입니다.그렇다고 해서 공백을 아무렇게나 쓰라는 말은 아닙니다.예를 들어 앞에서 쓴 while 문은 다음 코드와 동등합니다.while(funds &gt; 1 &amp;&amp; funds &lt; 100)\tfunds = funds + 2;하지만 위 코드는 두 문 사이에 어떤 연관이 있다는 느낌을 주지 않습니다.이런 코드는 오해의 소지가 다분하므로 피해야 합니다.다음 코드도 같은 일을 하는데, 이런 스타일은 비교적 흔히 쓰이는 편이며 모호해 보이지도 않습니다.// 줄바꿈이 없습니다.while(funds &gt; 1 &amp;&amp; funds &lt; 100) funds = funds + 2;// 줄바꿈 없이 문 하나를 블록 안에 썼습니다.while(funds &gt; 1 &amp;&amp; funds &lt; 100) { funds = funds + 2; }프로그래머 중에는 제어문 바디를 항상(단 하나의 문이라도) 블록 안에 써서 일관성을 유지하고 의미를 명료하게 표현해야 한다고 주장하는 사람들이 있습니다.필자는 그런 주장에 적극적으로 동참하는 편은 아니지만, 부주의한 들여쓰기는 이런 논쟁에 기름을 붓는 행동이라는 점은 지적해 두고 싶습니다.while(funds &gt; 1 &amp;&amp; funds &lt; 100)\tfunds = funds + 2;\tfunds = funds - 1;위 식은 언뜻 보면 while 루프의 바디에서 2개 문(2보 전진, 1보 후퇴)을 실행하는 것처럼 보입니다.하지만 여기에는 블록이 없으므로 자바스크립트는 위 코드를 다음과 같이 해석합니다.while(funds &gt; 1 &amp;&amp; funds &lt;100)\tfunds = funds + 2; // while 루프 바디\tfunds = funds - 1; //while 루프가 끝난 다음 실행됩니다.필자는 개인적으로 문 하나만 쓸 때는 블록을 생략하는 편이지만, 들여쓰기는 항상 의미가 명확히 드러나도록 써야 합니다.또한, 팀이나 오픈 소스 프로젝트에서 협력하고 있다면 거기서 선택한 스타일 가이드를 따라야 하며 개인적인 의견은 양보해야 합니다.문 하나를 블록 안에 쓰느냐 마느냐 하는 논쟁은 제쳐두더라도, 문법적으로는 유효하지만 거의 모든 사람에게 환영받지 못하는 스타일이 있습니다.같은 if 문 안에서 블록문과 블록 없는 문을 섞어 쓰지 마십시오.// 이렇게 하지 마십시오.if (funds &gt; 1) {\tconsole.log(\"There's money left!\");\tconsole.log(\"That means keep playing!\");} else\tconsole.log(\"I'm broke! Time to quit.\");\t// 이렇게도 하지 마십시오.if (funds &gt; 1)\tconsole.log(\"There's money left! Keep playing!\");else {\tconsole.log(\"I'm broke!\");\tconsole.log(\"Time to quit.\");}"
}, 

{
"id": "-javascript-2020-04-19-javascript57",
"title": "4.1.2 블록 문",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript57/",
"date": "2020-04-19",
"content": "블록 문(block statement) 은 엄밀히 말해 제어문이 아니지만 제어문과 함께 쓰입니다.(복합문(compound statement) 이라고도 합니다.)블록 문은 문(statement) 여러 개를 중괄호로 묶은 것이며 자바스크립트는 이들을 하나의 단위로 취급합니다.제어문 없이 블록 문만 써도 되지만 별 의미는 없습니다.다음 예제를 보십시오.{\t// 블록 문을 시작합니다.\tconsole.log(\"statement 1\");\tconsole.log(\"statement 2\");\t// 블록 문을 끝냅니다.}console.log(\"statement 3\");처음의 두 console.log는 블록 안에 있습니다.유효한 문법이지만, 무의미합니다.블록 문이 유용해지는 것은 제어문과 함께 쓸 때입니다.예를 들어 while 문에서 실행하는 루프는 블록 문 전체를 실행한 후 조건을 다시 테스트합니다.예를 들어 ‘2보 전진 후 1보 후퇴’를 한다면 다음과 같이 쓸 수 있을 겁니다.let funds = 50; // 시작 조건while(funds &gt; 1 &amp;&amp; funds &lt; 100) {\tfunds = funds + 2; // 2보 전진\tfunds = funds - 1; // 1보 후퇴}이 while 루프에는 끝이 있습니다.루프가 반복될 때마다 funds는 2만큼 늘어나고 1만큼 줄어드므로, 합하면 1이 늘어납니다.결국 funds는 100이 되고 루프는 끝납니다.제어문에는 블록을 쓰는 것이 일반적이지만 꼭 그래야 하는 건 아닙니다.예를 들어 100이 될 때까지 계속 2를 더하기만 한다면 블록 문을 쓰지 않아도 됩니다.let funds = 50; //시작 조건while(funds &gt; 1 &amp;&amp; funds &lt; 100)\tfunds = funds + 2;"
}, 

{
"id": "-javascript-2020-04-19-javascript56",
"title": "4.1.1 while 루프",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript56/",
"date": "2020-04-19",
"content": "마침내 코드로 작성할만한 일감이 나왔습니다.순서도에는 이미 첫 번째 제어문인 while 루프가 나타나 있습니다.while 루프는 조건을 만족하는 동안 코드를 계속 반복합니다.우리의 순서도에서 조건은 funds &gt; 1 &amp;&amp; funds &lt; 100입니다.코드로 나타내 봅시다.let funds = 50; // 시작 조건whild(funds &gt; 1 &amp;&amp; funds &lt; 100) {\t// 돈을 겁니다.\t\t// 주사위를 굴립니다.\t\t// 그림을 맞추면 돈을 가져옵니다.}이 프로그램은 지금 당장 실행하면 영원히 끝나지 않습니다.funds는 50에서 시작하고 늘어나거나 줄어들지 않으니 조건은 계속 맞기 때문입니다.세부 사항을 설명하기 전에 먼저 블록 문에 대해 이야기하고 넘어갑시다."
}, 

{
"id": "-javascript-2020-04-19-javascript55",
"title": "4.1 제어문의 기초",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript55/",
"date": "2020-04-19",
"content": "순서도에 대해 들어본 일이 있을 겁니다.순서도는 제어문을 시각적으로 나타내는 방법입니다.이 장에서 사용하는 예제에서는 시뮬레이션을 만듭니다.더 정확히 말해, 우리는 19세기 중반 왕립 해군의 장교 후보생 토마스가 당시 유행했던 주사위 게임 크라운 앤 앵커를 하는 과정을 모사할 겁니다.게임은 단순합니다.평평한 면 위에 여섯 개의 사각형이 있고 각 사각형에는 크라운, 앵커, 하트, 클럽, 스페이드, 다이아몬드를 나타내는 그림이 있습니다.게임을 하는 선원은 그 사각형에 마음대로 돈을 걸 수 있습니다.돈을 건 다음에는 (평면에 있는 사각형 숫자와 일치하는) 6면체 주사위 세 개를 굴립니다.주사위가 사각형 번호에 일치하는 숫자에 멈추면, 선원은 거기 건 만큼의 돈을 따게 됩니다.다음은 선원이 돈을 거는 방법 몇 가지와, 주사위를 잘 굴렸을 때 따는 돈을 정리한 겁니다.            거는 돈      주사위 결과      따는 돈                  크라운에 5 펜스      크라운, 크라운, 크라운      15펜스              크라운에 5 펜스      크라운, 크라운, 앵커      10펜스              크라운에 5 펜스      크라운, 하트, 스페이드      5펜스              크라운에 5 펜스      하트, 앵커, 스페이드      0              크라운에 3 펜스, 스페이드에 2펜스      크라운, 크라운, 크라운      9펜스              크라운에 3 펜스, 스페이드에 2펜스      크라운, 스페이드, 앵커      5펜스              모든 사각형에 1 펜스씩      어떤 주사위가 나오든      3펜스 (좋은 전략이 아닙니다!)      필자가 이 예제를 택한 이유는 별로 복잡하지 않으면서도, 조금만 상상력을 발휘하면 제어문의 용도를 알기 쉽게 나타낼 수 있기 때문입니다.19세기 선원이 어떻게 도박을 했는지 알아 둘 필요는 별로 없겠지만, 이런 형태의 시뮬레이션을 적용할 수 있는 분야는 생각보다 많습니다.크라운 앤 앵커를 수학적으로 모델화할 수 있다면, 다음 회사 축제 때 크라운 앤 앵커 부스를 열고 돈을 제일 많이 딴 동료를 명예의 전당에 올리는 이벤트를 열 수 있을지도 모릅니다.이 장에서 만든 시뮬레이션은 그 모델이 제대로 만들어졌는지 검증하는 데 쓸 수 있을 겁니다.게임 자체는 간단하지만, 플레이 방법은 수천 가지가 넘습니다.토마스는 아주 간단한 방법부터 시작할 테고, 이 장을 진행하면서 좀 더 영리하게 돈을 걸게 될겁니다.기본 조건부터 만듭시다.시작 조건과 끝내는 조건입니다.토마스는 항구에 내려서 크라운 앤 앵커 게임을 하러 갈 때마다 자본금으로 50 펜스를 준비합니다.토마스에게는 스스로 정한 제한이 있습니다.운이 좋아서 자본금을 배로 불리면, 주머니에 100 펜스를 넣고 즐겁게 도박장을 떠날 겁니다(100 펜스는 그의 한달 급여의 절반 정도 되는 돈입니다).자본금을 배로 불리거나, 아니면 전부 잃을 때까지 계속합니다.우리는 게임을 돈을 거는 부분, 주사위 굴리는 부분, 딴 돈이 있으면 가져오는 부분으로 나눌겁니다.이제 우리는 토마스가 어떻게 행동할지 추상화 한 간단한 순서도를 그릴 수 있습니다.이 순서도는 다음 [그림 4-1]과 같습니다.순서도에서 마름모 모양은 예/아니오인 결정이며 사각형은 행동입니다.시작과 끝은 원으로 나타냅니다.이 순서도를 바로 프로그램으로 바꿀 수는 없습니다.사람이 이해하기엔 매우 쉽지만, 컴퓨터가 이해하기엔 너무 복잡합니다.컴퓨터에 주사위를 굴리라고 해도 전혀 알아듣지 못합니다.주사위가 뭐지?어떻게 굴리지?이 문제를 해결하려면 ‘돈을 건다’, ‘주사위를 굴린다’, ‘돈을 가져온다’는 각각의 행동을 순서도로 나타내야 합니다.순서도를 그릴 종이가 아주 크다면 이 모두를 하나로 그릴 수 있지만, 책의 지면은 한정되어 있으니 우리는 각 행동을 따로 그릴 겁니다.결정하는 노드도 컴퓨터에게는 너무 모호합니다.‘100 펜스를 따거나 50펜스 전부를 잃는다’?컴퓨터는 이해할 수 없는 말입니다.그럼 컴퓨터는 무엇을 이해할 수 있을까요?이 장의 목적에 맞도록, 순서도의 각 행동(사각형)에서는 다음과 같은 동작만 할 수 있도록 제한할 겁니다.  변수 할당 : funds = 50, bets = {}, hand = []  m 이상 n 이하의 무작위 정수 : rand(1, 6) (이 함수는 나중에 다시 설명할 보조 함수입니다.)  하트, 크라운 등을 결정할 무작위 문자열 randFace() (역시 보조함수입니다.)(역주_ 카드의 그림을 보통 face라고 부릅니다. 예를 들어 포커에 사용하는 카드에서 왕자(J), 여왕(Q), 왕(K)를 보통 face card라고 부릅니다.)  객체 프로퍼티 할당 : bets[“heart”] = 5, bets[randFace()] = 5  배열에 요소 추가 : hand.push(randFace())  간단한 사칙연산 : funds - totalBet, funds + winnings  증가 : roll++ (++은 roll 변수에 1을 더한다는 의미입니다.)순서도의 결정 부분(마름모)은 다음과 같이 제한합니다.  숫자 비교: funds &gt; 0, funds &lt; 100  일치 비교: totalBet === 7 (등호를 세 개 쓴 이유는 5장에서 설명합니다.)  논리 연산자 : funds &gt; 0 &amp;&amp; funds &lt; 100 (앰퍼샌드 두 개는 ‘그리고’ 입니다. 5장에서 다시 설명합니다.)여기에서 사용한 모든 ‘허용된 행동’은 아주 쉽게 자바스크립트 문법으로 바꿀 수 있습니다.용어에 대해 한 가지만 더 짚고 넘어갑시다.이 장 전체에서 참 같은 값과 거짓 같은 값이라는 용어를 계속 사용할 겁니다.이 용어는 true와 false를 비유하거나 에둘러 말하는 것이 아닙니다.이들은 자바스크립트에서 의미가 있는 용어입니다.이들 용어의 정확한 의미는 5장에서 설명하겠지만, 지금은 이들을 각각 true와 false로 생각하면 됩니다.이제 사용할 수 있는 범위를 제한했으니, 그에 맞게 다시 그린 순서도는 [그림 4-2]와 같습니다."
}, 

{
"id": "-javascript-2020-04-19-javascript54",
"title": "4. 제어문",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript54/",
"date": "2020-04-19",
"content": "초보 프로그래머에게는 종종 레시피를 따라 하라는 비유를 권하곤 합니다.이런 비유는 현실을 비교적 잘 나타내기는 하지만, 모순도 있습니다.먹을 만한 음식을 만들려면, 조리법에서 선택을 최소화해야 합니다.완성된 조리법은 한 단계씩 그대로 따라하면 될 뿐, 선택의 여지는 없거나 매우 좁습니다.물론 가끔 버터 대신 라드를 쓴다거나 입맛에 맞는 양념을 쓰라는 등 선택의 여지가 있기도 합니다.하지만 조리법은 대개 순서대로 따라 해야 하는 각 단계를 나열한 형태입니다.이번 4장은 전부 변경과 선택에 관한 내용입니다.반복 작업을 효율적으로 자동화하고 변화하는 조건에 대응하려면 이 장에서 배우는 내용이 필수적입니다.  NOTE_ 프로그래밍 경험이 있다면, 특히 C++이나 자바, C# 등 C 언어에서 파생된 문법을 사용하는 언어를 배웠다면 제어문에 익숙할 테니 이번 장의 첫번째 부분은 대충 훑어보거나 건너뛰어도 괜찮습니다.하지만 건너뛴다면 19세기 선원들이 즐겨하던 놀이에 대해서는 알 수 없게 됩니다."
}, 

{
"id": "-javascript-2020-04-19-javascript53",
"title": "3.20 요약",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript53/",
"date": "2020-04-19",
"content": "프로그래밍 언어에서 데이터 타입은 말로 설명할 수 있는 것들을 프로그램에 구현하는 기본 요소입니다.이 장에서 배운 것들 중 매일 사용하게 될 핵심은 다음과 같습니다.  자바스크립트에는 문자열, 숫자, 불리언, null, undefined, 심볼의 여섯가지 원시 타입과 객체 타입이 있습니다.  자바스크립트의 모든 숫자는 배정도 부동소수점 숫자(더블)입니다. (..번역본이라 오타가 들어간건가.. 배정도..? 무슨말이지..)  배열은 특수한 객체이며, 객체와 마찬가지로 매우 강력하고 유연한 데이터 타입입니다.  날짜, 맵, 셋, 정규표현식 등 자주 사용할 다른 데이터 타입들은 특수한 객체 타입입니다.프로그래밍을 하다 보면 문자열을 정말 많이 사용하게 될 겁니다.다음 장으로 넘어가기 전에 문자열의 이스케이프 규칙과 문자열 템플릿이 어떻게 동작하는지 정확하게 이해하길 강력히 권합니다.참조형과 원시형원시 값은 불변이고, 원시 값을 복사/전달할 때는 값 자체를 복사/ 전달합니다.따라서 ‘원본’의 값이 바뀌더라도 ‘사본’의 값이 따라서 바뀌지는 않습니다.let a = 1; // 원본let b = a; // 사본. b는 1입니다. a가 아닙니다.a = 2; // 원본 값 바꿈console.log(b); // 1. 사본의 값은 바뀌지 않음또한, 값 자체를 복사했으므로 변수와 값은 일치합니다.a === 2  // true값 자체를 전달하므로 함수 안에서 변수의 값이 바뀌어도 함수 외부에서는 바뀌지 않은 상태로 남습니다.function change (a) {\ta = 5;}a = 3;change(a);console.log(a); // 3객체는 가변이고, 객체를 복사/전달할 때는 객체가 아니라 그 객체를 가리키고 있다는 사실(참조)을 복사/전달합니다.따라서 원본이 바뀌면 사본도 따라서 바뀝니다.이런 특징을 강조하고 싶을 때 객체를 참조 타입이라고 부르기도 합니다.let o = {a: 1};let p = o; // 이제 p는 o가 '가리키고 있는 것'을 가리킵니다.o.a = 2;console.log(p);   // {a: 2}주의할 점이 하나 있습니다.다음 코드는 앞의 예제와 비슷해 보이지만 결과는 전혀 다릅니다.let o = {a: 1};let p = o;       // 이제 p는 o가 '가리키고 있는 것'을 가리킵니다.p === o;       // trueo = {a: 2};           // 이제 o는 다른 것을 가리킵니다. {a: 1}을 수정한 것이 아닙니다.p === o;              // falseconsole.log(p);       // {a: 1}객체를 가리키는 변수는 그 객체를 가리키고 있을 뿐, 객체 자체는 아닙니다.따라서 변수와 객체는 결코 일치하지 않습니다.let q = {a: 1};q === {a: 1}    // false참조를 전달하므로 함수 안에서 객체를 변경하면 함수 외부에서도 바뀝니다.function change_o (o) {\to.a = 999;}let o = {a: 1};change_o(o);console.log(o)  // {a: 999}"
}, 

{
"id": "-javascript-2020-04-19-javascript52",
"title": "3.19.3 불리언으로 변환",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript52/",
"date": "2020-04-19",
"content": "5장에서 자바스크립트가 ‘참 같은 값’과 ‘거짓 같은 값’을 어떻게 다루는지 설명하므로 여기서 자세히 설명하지는 않습니다.간단히 말하면, 부정(not) 연산자 (!) 를 써서 모든 값을 불리언으로 바꿀 수 있습니다.부정 연산자를 한 번 사용하면 ‘참 같은 값’은 false로 바뀝니다.부정 연산자를 한 번 더 쓰면 true를 얻을 수 있습니다.숫자형 변환과 마찬가지로 Boolean 생성자를 써도 결과는 같습니다(여기서도 new 키워드는 사용하지 않습니다).const n = 0;  // 거짓 같은 값const b1 = !!n;   // falseconst b2 = Boolean(n);   // false"
}, 

{
"id": "-javascript-2020-04-19-javascript51",
"title": "3.19.2 문자열로 변환",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript51/",
"date": "2020-04-19",
"content": "자바스크립트의 모든 객체에는 문자열 표현을 반환하는 toString() 메서드가 있습니다.사실 toString() 메서드를 사용할 일은 별로 많지 않습니다.문자열 병합에서 자동으로 숫자를 문자열로 변환하므로, 숫자를 문자열로 직접 바꿀 일은 그리 많지 않습니다.어떤 경우든 숫자를 문자열로 바꿔야 한다면, toString() 메서드는 잘 동작하고 상식적인 결과를 반환합니다.const n = 33.5;n; // 33.5 - 숫자const s = n.toString();s; // \"33.5\" - 문자열Date 객체의 toString() 메서드는 좀 길긴 하지만 쓸만한 결과를 반환합니다.하지만 대부분의 객체는 아무짝에도 쓸모없는 문자열 “[object object]” 를 반환합니다.객체의 toString() 메서드를 수정해서 더 유용한 문자열 표현을 반환하게 할 수 있습니다.이 방법은 9장에서 설명합니다.한편 배열의 toString() 메서드는 꽤 쓸만합니다.이 메서드는 각 요소를 문자열로 바꾼 다음 쉼표로 연결한 문자열을 반환합니다.const arr = [1, true, \"hello\"];arr.toString(); // \"1, true, hello\""
}, 

{
"id": "-javascript-2020-04-19-javascript50",
"title": "3.19.1 숫자로 바꾸기",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript50/",
"date": "2020-04-19",
"content": "문자열을 숫자로 바꾸기문자열을 숫자로 바꿔야 할 경우가 많습니다.사용자에게 받은 입력은 보통 문자열로, 자바스크립트에는 문자열을 숫자로 바꾸는 방법이 몇 가지 있습니다.첫 번째는 Number 객체 생성자를 사용하는 방법입니다.(보통 생성자를 사용할 때는 항상 new 키워드를 사용하며, new 키워드에 대해서는 9장에서 설명합니다. 여기서 사용하는 방법은 예외입니다.)const numStr = \"33.3\";const num = Number(numStr); // 이 행은 숫자 값을 만듭니다.\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Number 객체의 인스턴스가 아닙니다.숫자로 바꿀 수 없는 문자열에서는 NaN이 반환됩니다.두 번째 방법은 내장 함수인 parseInt나 parseFloat 함수를 사용하는 방법입니다.이들은 Number 생성자와 비슷하게 동작하지만 몇 가지 다른 점이 있습니다.parseInt를 사용할 때는 기수(radix) 를 넘길 수 있습니다.기수는 변환할 문자열이 몇 진수 표현인지 지정합니다.예를 들어 16진수를 변환할 때는 기수로 16을 넘깁니다.기수 기본값은 10이므로 10진수 표현을 변환할 때는 기수를 쓰지 않아도 결과는 같지만, 항상 기수를 명시하길 권합니다.parseInt와 parseFloat는 모두 숫자로 판단할 수 있는 부분까지만 변환하고, 그 뒤에 있는 문자열은 무시합니다.따라서 문자열의 형태가 엉망진창이어도 입력값으로 쓸 수 있습니다.다음 예제를 보십시오.const a = parseInt(\"16 volts\", 10); // \" volts\"는 무시됩니다. 10진수 16입니다.const b = parseInt(\"3a\", 16); // 16진수 3a를 10진수로 바꿉니다. 결과는 58입니다.const c = parseFloat(\"15.5 kph\"); // \" kph\"는 무시됩니다. parseFloat는 항상 기수가 10이라고 가정합니다.Date 객체를 숫자로 바꾸기Date 객체를 숫자로 바꿀 때는 valueOf() 메서드를 사용합니다.이 숫자는 UTC 1970년 1월 1일 자정으로부터 몇 밀리초가 지났는지 나타내는 숫자입니다.const d = new Date(); // 현재 날짜const ts = d.valueOf(); // UTC 1970년 1월 1일 자정으로부터\t\t\t\t\t\t\t\t\t\t\t\t// 몇 밀리초가 지났는지 나타내는 숫자불리언 값을 1 또는 0으로 바꾸기불리언을 1 (true)이나 0(false)으로 바꿔야 할 때도 있습니다.이렇게 변환할 때는 조건 연산자를 사용합니다.조건 연산자는 5장에서 설명합니다.const b = true;const n = b ? 1:0;"
}, 

{
"id": "-javascript-2020-04-19-javascript49",
"title": "3.19 데이터 타입 변환",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript49/",
"date": "2020-04-19",
"content": "데이터 타입을 다른 타입으로 바꾸는 일은 매우 자주 하는 작업입니다.사용자 입력이나 다른 시스템에서 가져온 데이터를 그대로 쓸 수 있는 경우는 별로 없고, 대개 변환해야 합니다.이 섹션에서는 데이터 변환에 자주 쓰이는 테크닉을 소개합니다."
}, 

{
"id": "-javascript-2020-04-19-javascript48",
"title": "3.18 맵과 셋",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript48/",
"date": "2020-04-19",
"content": "ES6에서는 새로운 데이터 타입 Map과 Set, 그리고 그들의 ‘약한’ 짝인 WeakMap과 WeakSet을 도입했습니다.맵은 객체와 마찬가지로 키와 값을 연결하지만, 특정 상황에서 객체보다 유리한 부분이 있습니다.셋은 배열과 비슷하지만 중복이 허용되지 않습니다.WeakMap과 WeakSet은 Map과 Set과 마찬가지로 동작하지만,특정 상황에서 성능이 더 높아지도록 일부 기능을 제거한 버전입니다.맵과 셋은 10장에서 설명합니다."
}, 

{
"id": "-javascript-2020-04-19-javascript47",
"title": "3.17 정규표현식",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript47/",
"date": "2020-04-19",
"content": "(regex 또는 regexp로도 쓰는) 정규표현식(regular expression) 은 자바스크립트의 부속 언어에 가깝습니다.정규표현식은 여러 가지 프로그래밍 언어에서 일종의 확장으로 제공하며,문자열에서 필요한 복잡한 검색과 교체 작업을 비교적 단순하게 만듭니다.정규표현식은 17장에서 설명합니다.자바스크립트의 정규표현식은 RegExp 객체를 사용합니다.슬래시 한 쌍(/…/) 사이에 심볼을 넣는 리터럴 문법도 있습니다.다음은 정규표현식의 예제입니다.정규표현식을 처음본다면 괴상망측해 보일 겁니다.// 극히 간단한 이메일 정규표현식const email = /\\b[a-z0-9._-]+@[a-z_-]+(?:\\.[a-z]+)+\\b/;// 미국 전화번호 정규표현식const phone = /(:?\\+1)?(:?\\(\\d{3}\\)\\s?|\\d{3}[\\s-]?)\\d{3}[\\s-]?\\d{4}/;"
}, 

{
"id": "-javascript-2020-04-19-javascript46",
"title": "3.16 날짜",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript46/",
"date": "2020-04-19",
"content": "자바스크립트의 날짜와 시간은 내장된 Date 객체에서 담당합니다.Date 객체는 자바스크립트에서 불만스러운 부분 중 하나입니다.Date 객체는 원래 자바에서 가져온 겁니다(‘자바’스크립트가 자바와 연관된 몇 안 되는 부분 중 하나입니다).Date 객체는 사용하기 어려운 편이고, 특히 타임존이 다른 날짜를 다룰 때는 매우 어렵습니다.현재 날짜와 시간을 나타내는 객체를 만들 때는 new Date()를 사용합니다.const now = new Date();now; // Fri Dec 16 2016 09:20:16 GMT+0900 (KST)특정 날짜에 해당하는 객체를 만들 때는 다음과 같이 합니다.halloween = new Date(2016, 9, 31); // 월은 0에서 시작합니다. 즉,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 9는 10월입니다.특정 날짜와 시간에 해당하는 객체를 만들 때는 다음과 같이 합니다.const halloweenParty = new Date(2016, 9, 31, 19, 0); // 19:00 = 7:00 PM날짜 객체를 만들면 다음과 같이 각 부분을 가져올 수 있습니다.halloweenParty.getFullYear(); // 2016halloweenParty.getMonth(); // 9halloweenParty.getDate(); // 31halloweenParty.getDay(); // 1 (월요일입니다. 0은 일요일입니다.)halloweenParty.getHours(); // 19halloweenParty.getMinutes(); // 0halloweenParty.getSeconds(); // 0halloweenParty.getMilliseconds(); // 0날짜에 대해서는 15장에서 자세히 설명합니다."
}, 

{
"id": "-javascript-2020-04-19-javascript45",
"title": "3.15 객체와 배열 마지막의 쉼표",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript45/",
"date": "2020-04-19",
"content": "날카로운 독자라면 예제 코드를 읽으면서 객체와 배열 요소를 여러 행에 나눠 썼을 때 마지막에 쉼표가 있는 것을 눈치챘을 겁니다(이런 마지막 쉼표를 trailing comma, dangling comma, termianl comma 등으로 부릅니다).const arr = [\t\"One\",\t\"Two\",\t\"Three\",];const o = {\tone: 1,\ttwo: 2,\tthree: 3,};자바스크립트 문법에서는 마지막 쉼표를 계속 허용했었지만,인터넷 익수플로러 초기 버전은 마지막 쉼표를 쓰면 에러를 냈으므로 쓰지 않는 프로그래머가 많습니다.필자는 배열과 객체에서 잘래내고 붙여넣는 일이 많고, 객체 마지막에 프로퍼티를 추가하는 일이 많으므로 마지막 쉼표를 항상 사용합니다.즉, 필자의 상식으로는, 배열과 객체 리터럴의 마지막에는 항상 쉼표가 있습니다.마지막 쉼표를 쓰느냐 마느냐 하는 논쟁이 늘 있지만, 필자는 마지막 쉼표를 선호합니다.독자 여러분이 마지막 쉼표를 썼을 때 문제가 생긴다고 느끼거나, 팀의 스타일 가이드에서 마지막 쉼표를 쓰지 않도록 정했다면 필자의 의견은 잊고 마지막 쉼표를 쓰지 마십시오.  NOTE_ 널리 사용되는 자바스크립트 객체 표기법(JSON)에서는 마지막 쉼표를 허용하지 않습니다."
}, 

{
"id": "-javascript-2020-04-19-javascript44",
"title": "3.14 배열",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript44/",
"date": "2020-04-19",
"content": "자바스크립트 배열은 특수한 객체입니다.일반적인 객체와 달리 배열 콘텐츠에는 항상 순서가 있고, 키는 순차적인 숫자입니다.배열은 유용한 메서드를 많이 가진 대단히 강력한 데이터 타입입니다.배열 메서드는 8장에서 설명합니다.다른 언어를 공부했다면 자바스크립트 배열이 C언어의 효율적인 배열(indexed array) 과 더 강력한 동적 배열, 링크드 리스트(linked list) 를 혼합한 것임을 알 수 있을 겁니다.자바스크립트 배열에는 다음과 같은 특징이 있습니다.  배열 크기는 고정되지 않습니다. 언제든 요소를 추가하거나 제거할 수 있습니다.  요소의 데이터 타입을 가리지 않습니다. 즉, 문자열만 쓸 수 있는 배열이라던가 숫자만 쓸 수 있는 배열 같은 개념이 아예 없습니다.  배열 요소는 0으로 시작합니다.  CAUTION_ 배열은 기능이 추가된 특수한 객체이므로 배열에 숫자가 아닌 키나 분수, 음수 등을 키로 쓸 수는 있습니다.가능하기는 하지만, 이런 행동은 배열의 설계 목적에 어긋날 뿐 아니라 혼란스러운 동작과 찾기 어려운 버그를 초래할 수 있으므로 피해야 합니다.자바스크립트의 배열 리터럴은 다음과 같이 대괄호 안에 배열 요소를 쉼표로 구분해서 씁니다.const a1 = [1, 2, 3, 4]; // 숫자로 구성된 배열const a2 = [1, 'two', 3, null]; // 여러 가지 타입으로 구성된 배열const a3 = [\t\"What the hammer? What the chain?\",\t\"In what furnace was thy brain?\",\t\"What the anvil? What dread grasp\",\t\"Dare its deadly terrors clasp?\",];const a4 = [ // 객체가 들어가있는 배열\t{ name: \"Ruby\", hardness:9 },\t{ name: \"Diamond\", hardness: 10 },\t{ name: \"Topaz\", hardness:8 },];const a5 = [  // 배열이 들어있는 배열\t[1, 3, 5],\t[2, 4, 6],];배열에는 요소 숫자를 반환하는 length 프로퍼티가 있습니다.const arr = ['a', 'b', 'c'];arr.length; // 3배열 요소에 접근할 때는 대괄호 안에 요소의 인덱스 숫자를 씁니다.const arr = ['a', 'b', 'c'];// 첫 번째 요소를 가져옵니다.arr[0]; // 'a'// arr의 마지막 요소의 인덱스는 arr.length-1 입니다.arr[arr.length - 1]; // 'c'배열 요소의 값을 덮어쓸 때는 새 값을 할당하면 됩니다.(할당할 때 배열 길이나 그보다 큰 인덱스를 사용하면 배열 크기가 그에 맞게 늘어납니다.)const arr = [1, 2, 'c', 4, 5];arr[2] = 3; // arr은 이제 [1, 2, 3, 4, 5] 입니다.8장에서 배열과 그 요소를 수정하는 방법에 대해 자세히 설명합니다."
}, 

{
"id": "-javascript-2020-04-19-javascript43",
"title": "3.13 Number, String, Boolean 객체",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript43/",
"date": "2020-04-19",
"content": "이 장 초반에서 숫자와 문자열, 불리언에는 각각 대응하는 객체 타입 Number, String, Boolean이 있다고 언급했습니다.이들 객체에는 두 가지 목적이 있습니다.  하나는 Number.INFINITY 같은 특별한 값을 저장하는 것이고,  다른 하나는 함수 형태로 기능을 제공하는 것입니다.다음을 보십시오.const s = \"hello\";s.toUpperCase(); // \"HELLO\"이 예제의 s는 마치 객체처럼, 즉 함수 프로퍼티를 가진 것처럼 보입니다.하지만 우리는 s가 분명 원시 문자열 타입임을 알고 있습니다.어떻게 된 걸까요?자바스크립트는 일시적인 String 객체를 만든 겁니다.이 임시 객체에 toUpperCase 함수가 들어있습니다.자바스크립트는 함수를 호출하는 즉시 임시 객체를 파괴합니다.객체가 임시로 만들어진다는 사실은 다음과 같이 문자열 프로퍼티를 할당해 보면 알 수 있습니다.const s = \"hello\";s.rating = 3; // 에러가 없습니다. 성공일까요?s.rating; // undefined이 예제는 마치 문자열 s에 프로퍼티를 할당하는 것처럼 보입니다.사실은 일시적인 String 객체에 프로퍼티를 할당한 겁니다.임시 객체는 즉시 파괴되므로 s.rating은 undefined 입니다.이런 동작은 전혀 드러나지 않고 사실 생각할 필요도 거의 없지만,자바스크립트가 이면에서 무슨 일을 하는지 알아 두면 도움이 될 수 있습니다."
}, 

{
"id": "-javascript-2020-04-19-javascript42",
"title": "3.12 객체",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript42/",
"date": "2020-04-19",
"content": "원시 타입은 단 하나의 값만 나타낼 수 있고 불변이지만,이와 달리 객체는 여러 가지 값이나 복잡한 값을 나타낼 수 있으며, 변할 수도 있습니다.객체의 본질은 컨테이너입니다.컨테이너의 내용물은 시간이 지나면서 바뀔 수 있지만, 내용물이 바뀐다고 컨테이너가 바뀌는 건 아닙니다.즉, 여전히 같은 객체입니다.객체에도 중괄호, 즉 {과 }를 사용하는 리터럴 문법이 있습니다.중괄호는 한 쌍이므로 객체가 어디에서 시작하고 어디에서 끝나는지 나타낼 수 있습니다.빈 객체로 시작해 봅시다.const obj = {};  NOTE_ 객체 이름은 아무거나 써도 되지만, 일반적으로 user나 shoppingCart 처럼 의미를 알 수 있는 이름을 써야 합니다.우리는 이제 막 객체에 대해 배우는 중이고 이 예제의 객체가 무언가를 나타내는 것은 아니니 그냥 obj라고 부릅니다.객체의 컨텐츠는 프로퍼티(property) 또는 멤버(member) 라고 부릅니다.프로퍼티는 이름(키)과 값으로 구성됩니다.프로퍼티 이름은 반드시 문자열 또는 심볼이어야 하며, 값은 어떤 타입이든 상관없고 다른 객체여도 괜찮습니다.obj에 color 프로퍼티를 추가합시다.obj.color = \"yellow\";프로퍼티 이름에 유효한 식별자를 써야 멤버 접근 연산자(member access operator)(.) 를 사용할 수 있습니다.프로퍼티 이름에 유효한 식별자가 아닌 이름을 쓴다면 계산된 멤버 접근 연산자(computed member access operator)([]) 를 써야 합니다.(이후 멤버 접근 연산자는 ‘점 연산자’, 계산된 멤버 접근 연산자는 ‘대괄호’라고 간단하게 표기하겠습니다.)프로퍼티 이름이 유효한 식별자여도 대괄호로 접근할 수 있습니다.obj[\"not an identifier\"] = 3;obj[\"not an identifier\"]; // 3obj[\"color\"]; // \"yellow\"심볼 프로퍼티에 접근할 때도 대괄호를 사용합니다.const SIZE = Symbol();obj[SIZE] = 8;obj[SIZE]; // 8이제 obj에는 “color” (유효한 식별자 문자열), “not an identifier” (유효한 식별자가 아닌 문자열), SIZE(심볼) 세 가지 프로퍼티가 있습니다.  NOTE_ 자바스크립트 콘솔에서 이 예제를 실행해 보면 콘솔에서는 SIZE를 obj의 프로퍼티로 나열하지 않는 걸 볼 수 있습니다(console.log(obj)).  obj[SIZE]를 입력해 보면 SIZE가 obj의 프로퍼티인 것을 확인할 수 있지만, 심볼 프로퍼티는 다르게 처리되며 기본적으로는 표시되지 않습니다.또한, 이 프로퍼티의 키는 SIZE 심볼이며 문자열 “SIZE”가 아닙니다.obj.SIZE = 0을 입력한 후 obj[SIZE]와 obj.SIZE(또는 obj[“SIZE”])를 입력해 보면 이 사실을 확인할 수 있습니다.(점 연산자는 문자열 프로퍼티에 대해 항상 동작합니다.)이 단계에서 잠시 멈추고 원시 값과 객체의 차이에 대해 되새겨 봅시다.이 섹션에서 우리는 변수 obj에 저장된 객체를 저장했지만, obj는 항상 같은 객체를 가리키고 있었습니다.obj에 저장한 것이 문자열이나 숫자, 기타 다른 원시 값이었다면 수정할 때마다 다른 값을 가리켰을 겁니다.달리 말해 obj는 계속 같은 객체를 가리키고, 바뀐 것은 객체의 프로퍼티입니다.(역주_ 참조형과 원시형의 차이 및 동작에 관해서는 3장의 마지막 부분에 따로 설명합니다.)obj는 빈 객체로 만들었지만, 객체 리터럴 문법에서는 객체를 만드는 동시에 프로퍼티를 만들 수 있습니다.중괄호 안에서 각 프로퍼티를 쉼표로 구분하고, 프로퍼티 이름과 값은 콜론으로 구분합니다.const sam1 = {\tname: 'Sam',\tage: 4,};const sam2 = { name: 'Sam', age: 4 }; // 한 줄로 선언했습니다.const sam3 = {\tname: 'Sam',\tclassification: {    // 프로퍼티 값도 객체가 될 수 있습니다.\t\tkingdom: 'Anamalis',\t\tphylum: 'Chordata',\t\tclass: 'Mamalia',\t\torder: 'Carnivoria',\t\tfamily: 'Felidae',\t\tsubfamily: 'Felinae',\t\tgenus: 'Felis',\t\tspecies: 'catus',\t}}이 예제에서는 객체 리터럴 문법에 따라 세 가지 객체를 만들었습니다.sam1과 sam2의 프로퍼티는 똑같지만, 둘은 서로 다른 객체입니다.원시 값과는 반대입니다(값이 숫자 3인 두 변수는 같은 원시 값을 가리킵니다).sam3의 classification 프로퍼티는 그 자체가 객체입니다.sam3의 family에 접근하는 방법은 여러가지 입니다.여기서는 큰 따옴표를 썼지만, 작은 따옴표나 백틱을 써도 됩니다.sam3.classification.family; // \"Felidae\"sam3[\"classification\"].family; // \"Felidae\"sam3.classification[\"family\"]; // \"Felidae\"sam3[\"classification\"][\"family\"]; // \"Felidae\"객체에 함수를 담을 수도 있습니다.함수에 대해서는 6장에서 자세히 설명합니다.지금은 함수가 일종의 부속 프로그램이라고 생각하면 됩니다.sam3에 함수를 추가할 때는 다음과 같이 합니다.sam3.speak = function() { return \"Meow!\"; };이제 함수 뒤에 괄호를 붙여 함수를 호출할 수 있습니다.sam3.speak(); // \"Meow!\"마지막으로, 객체에서 프로퍼티를 제거할 때는 delete 연산자를 사용합니다.delete sam3.classification; // classification 트리 전체가 삭제됐습니다.delete sam3.speak; // speak 함수가 삭제됐습니다.객체지향 프로그래밍(OOP)에 익숙하다면 자바스크립트 객체를 OOP에 어떻게 사용하는지 궁금할 겁니다.지금은 객체를 범용 컨테이너라고 생각하십시오.OOP에 대해서는 9장에서 설명합니다."
}, 

{
"id": "-javascript-2020-04-19-javascript41",
"title": "3.11 null과 undefined",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript41/",
"date": "2020-04-19",
"content": "null과 undefined는 자바스크립트의 특별한 타입입니다.null이 가질 수 있는 값은 null 하나뿐이며, undefined가 가질 수 있는 값도 undefined 하나뿐입니다.null과 undefined는 모두 존재하지 않는 것을 나타냅니다.그리고 이 둘을 서로 다른 데이터 타입으로 분리한 것은 끝없는 혼란을 낳았고, 특히 초보자들이 고생하고 있습니다.일반적인 규칙을 제시한다면, null은 프로그래머에게 허용된 데이터 타입이며 undefined는 자바스크립트 자체에서 사용한다고 기억하십시오.이 규칙이 강제는 아닙니다.프로그래머도 언제든 undefined 값을 사용할 수는 있지만, 꼭 필요할 때만 사용하도록 주의해야 합니다.필자가 변수에 직접 undefined를 할당하는 경우는, 아직 값이 주어지지 않은 변수의 동작을 고의로 흉내내야 할 때뿐입니다.변수의 값을 아직 모르거나 적용할 수 없는 경우에는 대부분 null이 더 나은 선택입니다.사소한 것에 지나치게 신경쓰는 것처럼 보일 테고, 어떤 면에서는 실제로 그렇기도 합니다.초보 프로그래머들은 불확실할 때는 null을 사용하라고 배우니까요.변수를 선언하기만 하고 명시적으로 값을 할당하지 않으면 그 변수에는 기본적으로 undefined가 할당됩니다.다음은 null 과 undefined 리터럴의 몇 가지 예제입니다.let currentTemp; // 암시적으로 undefined입니다.const targetTemp = null; // 대상 온도는 null, 즉 \"아직 모르는\" 값입니다.currentTemp = 19.5; // currentTemp에는 이제 값이 있습니다.currentTemp = undefined; // currentTemp는 초기화되지 않은 듯 합니다. 권장하지 않습니다."
}, 

{
"id": "-javascript-2020-04-19-javascript40",
"title": "3.10 심볼",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript40/",
"date": "2020-04-19",
"content": "심볼(symbol) 은 유일한 토큰을 나타내기 위해 ES6에서 도입한 새 데이터 타입입니다.심볼은 항상 유일합니다.다른 어떤 심볼과도 일치하지 않습니다.이런 면에서는 심볼은 객체와 유사합니다.객체는 모두 유일합니다.항상 유일하다는 점을 제외하면 심볼은 원시 값의 특징을 모두 가지고 있으므로 확장성 있는 코드를 만들 수 있습니다.여기에 대해서는 9장에서 더 설명합니다.심볼은 Symbol() 생성자로 만듭니다.(자바스크립트의 객체지향 프로그래밍에 익숙하다면 심볼을 만들 때 new 키워드를 사용할 수 없으며, 대문자로 시작하는 식별자는 new와 함께 쓴다는 불문율의 예외임을 새로 기억해야 합니다.)원한다면 생성자에 간단한 설명을 추가할 수 있습니다.const RED = Symbol(\"The color of a sunset!\");const ORANGE = Symbol(\"The color of a sunset!\");RED === ORANGE // false; 심볼은 모두 서로 다릅니다.우연히 다른 식별자와 혼동해서는 안 되는 고유한 식별자가 필요하다면 심볼을 사용하십시오."
}, 

{
"id": "-javascript-2020-04-19-javascript39",
"title": "3.9 불리언",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript39/",
"date": "2020-04-19",
"content": "불리언은 true와 false 두 가지 값밖에 없는 데이터 타입입니다.C 같은 일부 언어에서는 불리언 대신 숫자를 사용합니다.0은 false이고, 다른 숫자는 모두 true입니다.자바스크립트에서도 비슷한 방식을 사용합니다.모든 값을 참 같은 값(truthy), 거짓 같은 값(falsy)으로 나눌 수 있습니다.이에 대해서는 5장에서 다시 설명합니다.불리언을 쓸 생각이라면 따옴표 안에 넣지 않도록 조심하십시오.문자열 “false”가 참 같은 값이라는 사실을 모르고 실수하는 사람들이 많습니다.불리언 리터럴은 다음과 같이 써야 합니다.let heating = true;let cooling = false;"
}, 

{
"id": "-javascript-2020-04-19-javascript38",
"title": "3.8.3 숫자와 문자열",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript38/",
"date": "2020-04-19",
"content": "숫자를 따옴표 안에 넣으면 그건 숫자가 아니라 문자열입니다.그렇긴 하지만, 자바스크립트는 필요하다면 숫자가 들어 있는 문자열을 자동으로 숫자로 바꿉니다.이런 일이 언제 일어나는지, 어떻게 일어나는지를 알지 못하면 혼란스러울 수 있습니다.여기에 관해서는 5장에서 다시 설명합니다.다음 예제에 문자열을 숫자로 바꾸는 경우와 숫자로 바꾸지 않는 경우를 묘사했습니다.const result1 = 3 + '30'; // 3이 문자열로 바뀝니다. 결과는 문자열 '330' 입니다.const result2 = 3 * '30'; // '30'이 숫자로 바뀝니다. 결과는 숫자 90입니다.숫자가 필요할 땐 숫자를 쓰십시오(즉, 따옴표를 쓰지 마십시오).문자열이 필요할 땐 문자열을 쓰십시오.모호한 부분은 사용자 입력을 받을 때입니다.사용자 입력은 거의 항상 문자열로 들어오므로, 숫자가 필요할 때 숫자로 바꾸는 건 당신이 해야할 일입니다.이 장 후반에서 데이터 타입을 바꾸는 방법을 설명합니다."
}, 

{
"id": "-javascript-2020-04-19-javascript37",
"title": "3.8.2 여러 줄 문자열",
"author": null,
"tags": [],
"url": "/javascript/2020/04/19/javascript37/",
"date": "2020-04-19",
"content": "ES6 이전의 여러 줄 문자열 지원은 솔직히 좋다고 하기는 어려웠습니다.명세에는 소스 코드의 각 행 마지막에서 줄바꿈 문자를 이스케이프할 수 있도록 정의했지만,브라우저의 지원이 형편없었으므로 필자는 이 기능을 사용한 적이 없습니다.ES6에서는 이 기능이 좀 더 믿을 만하게 바뀌었지만, 아직은 조심해야 할 함정이 남아 있습니다.이 기능은 자바스크립트 콘솔에서는 동작하지 않으므로 시험해 보려면 자바스크립트 파일을 만들어야 합니다.따옴표를 사용한 문자열에서 다음과 같이 줄바꿈 문자를 이스케이프해 봅시다.const multiline = \"line1\\line2\";multiline 문자열에 줄바꿈 문자가 들어갈 것 같나요?아닙니다.첫 행 마지막의 역슬래시는 줄바꿈 문자를 이스케이프하기는 하지만, 문자열에 줄바꿈 문자를 삽입하지는 않습니다.따라서 결과는 line1line2입니다.줄바꿈 문자가 들어가게 하려면 다음과 같이 써야 합니다.const multiline = \"line1\\n\\line2\";백틱을 사용한 문자열에서는 조금 더 상식적인 결과가 나옵니다.const multiline = `line1line2`;이들 코드의 결과에는 줄바꿈 문자가 들어 있습니다.하지만 어느 쪽이든, 다음 줄 앞에 있는 들여쓰기가 결과 문자열에 포함됩니다.예를 들어 다음 코드의 결과 문자열에는 분명 줄바꿈 문자가 들어가지만, 원하지 않는 공백이 line2와 line3 앞에 들어갑니다.const multiline = `line1\tline2\tline3`;따라서 필자는 여러 줄 문자열을 권하지 않습니다.여러 줄 문자열을 쓰려면 코드를 읽기 쉽게 만드는 들여쓰기를 포기하거나,결과 문자열에 원하지 않는 공백이 들어가거나 둘 중 하나입니다.소스 코드에서 문자열을 여러 행에 나눠 써야 할 때 필자는 보통 문자열 병합을 사용합니다.const multiline = \"line1\\n\" +\t\"line2\\n\" +\t\"line3\";이렇게 하면 코드를 읽기 쉽게 쓸 수 있고, 결과 문자열도 원하는 형태로 만들어 집니다.문자열 병합을 사용할 때는 따옴표와 백틱을 섞어 써도 괜찮습니다.const multiline = 'Current temperature:\\n' +\t`\\t${currentTemp}\\u00b0C\\n` +\t\"Don't worry...the heat is on!\";"
}, 

{
"id": "-javascript-2020-04-18-javascript36",
"title": "3.8.1 템플릿 문자열",
"author": null,
"tags": [],
"url": "/javascript/2020/04/18/javascript36/",
"date": "2020-04-18",
"content": "값을 문자열 안에 써야 하는 일이 아주 많습니다.이때 문자열 병합(concatenation) 을 통해 변수나 상수를 문자열 안에 쓸 수 있습니다.let currentTemp = 19.5;// 00b0는 온도를 나타내는 유니코드 코드 포인트입니다.const message = \"The current temperature is \" + currentTemp + \"\\u00b0C\";ES6 이전에는 변수나 상수를 문자열 안에 쓰는 방법은 (외부 라이브러리를 사용하지 않으면) 문자열 병합뿐이었습니다.ES6에서는 문자열 템플릿(template) 이라는 기능을 도입했습니다.이 기능을 문자열 채우기(interpolation) 라 부르기도 합니다.문자열 템플릿은 문자열의 정해진 위치에 값을 채워넣는 간편한 방법입니다.문자열 템플릿에는 큰따옴표나 작은따옴표를 쓰지 않고 백틱(backtick)을 사용합니다.다음은 앞에서 살펴본 예제를 문자열 템플릿을 사용해서 고쳐 쓴 겁니다.let currentTemp = 19.5;const message = `The current temperature is ${currentTemp}\\u00b0C`;문자열 템플릿 안에서는 달러 기호가 특수문자가 됩니다.달러 기호 다음에 중괄호로 감싼 값을 쓰면 그 값이 문자열에 삽입됩니다.(중괄호 안에 어떤 표현식이라도 쓸 수 있습니다. 표현식에 대해서는 5장에서 설명합니다.)(문자열 템플릿 안에 달러 기호를 써야 한다면 역슬래시로 이스케이프하면 됩니다.)문자열 템플릿은 필자가 좋아하는 ES6 기능 중 하나입니다.이 책에서 문자열 템플릿을 자주 사용할 겁니다."
}, 

{
"id": "-javascript-2020-04-18-javascript35",
"title": "3.8 특수문자",
"author": null,
"tags": [],
"url": "/javascript/2020/04/18/javascript35/",
"date": "2020-04-18",
"content": "역슬래시는 따옴표를 이스케이프할 때만 쓰지는 않습니다.줄바꿈 문자처럼 화면에 표시되지 않는 일부 특수문자나 임의의 유니코드 문자를 나타낼 때도 역슬래시를 사용합니다.[표 3-1]은 널리 쓰이는 특수문자입니다.표3-1 널리쓰이는 특수문자            코드      설명      예제                  \\n      줄바꿈 문자(Newline), 엄밀히 말하면 ASCII/Unicode 10인 라인피드(line feed) 문자입니다.      “Line1\\nLine2”              \\r      캐리지 리턴(Carriage return) (ASCII/Unicode 13)      “Windows line 1\\r\\nWindows line2”              \\t      탭(ASCII/Unicode 9)      “Speed:\\t60kph”              \\’      작은따옴표, 꼭 이스케이프할 필요가 없어도 작은따옴표를 쓸 수 있는 곳에는 항상 이스케이프한 작은 따옴표를 쓸 수 있습니다.      Don\\‘t              \\”      큰따옴표, 꼭 이스케이프할 필요가 없어도 큰따옴표를 쓸 수 있는 곳에는 항상 이스케이프한 큰따옴표를 쓸 수 있습니다.      ‘Sam said \\“hello\\”.’                    백틱, ES6에서 새로 생겼습니다.      `New in ES6:  strings.`              $      달러 기호, ES6에서 새로 생겼습니다.      `New in ES6 : ${interpolation}`              \\\\      역슬래시      “Use \\\\\\\\ to represent \\\\!”              \\uXXXX      임의의 유니코드 코드 포인트, 여기서 XXXX는 16진수 코드 포인트입니다.      “De Morgan’s law: \\u2310(P \\u22c0Q) \\u21d4 (\\u2310p) \\u22c1(\\u2310Q)”              \\xXX      라틴-1 문자. 여기서 XX는 16진수 라틴-1 코드 포인트입니다.      “\\xc9p\\xe9e is fun, but foil is more fun.”      라틴-1 문자셋은 유니코드의 부분집합이며 라틴-1 문자 \\xXX 는 유니코드 코드 포인트 \\u00XX 와 똑같습니다.16진수에는 소문자나 대문자를 모두 쓸 수 있는데, 필자는 소문자가 읽기 쉬워서 소문자를 주로 쓰는 편입니다.소문자나 대문자를 다 쓸 수 있다고? 이게 무슨말인지 잘 이해가 안감.. \\u21D4와 \\u21d4가 같다는 말인가? 그래서 \\u21D4로 안쓰고 \\u21d4로 쓴다는 말인가?유니코드 문자 코드를 이스케이프하지 않고 에디터에서 직접 입력할 수도 있습니다.유니코드 문자를 직접 입력하는 방법은 여러 가지로, 에디터와 운영체제에 따라 다릅니다.유니코드 문자를 직접 입력하려면 에디터나 운영체제의 문서를 참고하십시오.다음 [표 3-2]는 자주 쓰이지 않는 특수문자를 정리한 겁니다.필자는 이 문자를 자바스크립트 프로그램에서 사용한 적이 한 번도 없지만, 책의 완성도를 위해 여기 정리했습니다.표 3-2 특수문자            코드      설명      예제                  \\0      NUL 문자 (ASCII/Unicode 0)      “ASCII NUL: \\0”              \\v      세로 탭(vertical tab) (ASCII/Unicode 11)      “Vertical tab: \\v”              \\b      백스페이스 (ASCII/Unicode 8)      “Backspace: \\b”              \\f      폼 피드(form feed) (ASCII/Unicode 12)      “Form feed: \\f”      "
}, 

{
"id": "-javascript-2020-04-18-javascript34",
"title": "3.7.1 이스케이프",
"author": null,
"tags": [],
"url": "/javascript/2020/04/18/javascript34/",
"date": "2020-04-18",
"content": "텍스트로 만들어진 프로그램에서 텍스트 데이터를 사용할 때는 항상 텍스트 데이터와 프로그램 자체를 구별할 방법이 필요합니다.이때 문자열을 따옴표 안에 쓰는 방법이 있습니다.하지만 문자열 안에 따옴표를 써야 한다면 어떻게 해야 할까요?이 문제를 해결하려면 따옴표를 이스케이프해서 문자열 주위에 쓰는 부호가 아님을 나타내야 합니다.다음 예제를 보십시오.여기에는 이스케이프가 필요하지 않습니다.const dialog = 'Sam looked up, and said \"hello, old friend!\", as Max walked in.';const imperative = \"Don't do that!\";dialog 는 작은 따옴표로 감싸여 있으므로 문자열 안에 큰따옴표를 걱정없이 쓸 수 있습니다.마찬가지로, imperative 는 큰따옴표로 감싸여 있으므로 문자열 안에 아포스트로피를 걱정없이 쓸 수 있습니다.하지만 두 가지 따옴표를 모두 써야 한다면 어떨까요?다음을 보십시오.// 에러가 일어납니다.const dialog = \"Sam looked up and said \"don't do that!\" to Max.\";dialog 문자열에는 어떤 따옴표를 쓰더라도 에러가 생깁니다.이때 역슬래시(\\) 를 써서 따옴표를 이스케이프 하면 문자열이 여기서 끝나지 않았다고 자바스크립트에 알릴 수 있습니다.앞에서 본 예제를 다음과 같이 고쳐 쓰면 어떤 따옴표라도 쓸 수 있습니다.const dialog1 = \"He looked up and said \\\"don't do that!\\\" to Max.\";const dialog2 = 'He looked up and said \"don\\'t do that!\" to Max.';당연히 떠오르는 문제가 있습니다.문자열에서 역슬래시 문자를 써야 할 때는 어떻게 할까요?다행히 역슬래시는 자기 자신을 이스케이프할 수 있습니다.const s = \"In JavaScript, use \\\\ as an escape character in strings.\";큰 따옴표를 쓸지, 작은 따옴표를 쓸지는 스스로 정하면 됩니다.  필자는 사용자에게 표시될 텍스트에는 보통 큰 따옴표를 사용합니다.텍스트엔 따옴표보다는 don’t 등의 어포스트로피를 더 많이 쓰는 편이므로, 큰 따옴표를 쓰는 편이 필자에게 맞습니다.  자바스크립트 문자열 안에 HTML을 쓸 때는 반대로 작은따옴표를 씁니다.HTML 문자열을 작은 따옴표로 감싸면 속성값에 큰따옴표를 쓸 수 있기 때문입니다."
}, 

{
"id": "-javascript-2020-04-18-javascript33",
"title": "3.7 문자열",
"author": null,
"tags": [],
"url": "/javascript/2020/04/18/javascript33/",
"date": "2020-04-18",
"content": "문자열(string) 은 텍스트 데이터입니다.string이라는 단어는 string of characters에서 나왔습니다.이 표현은 1800년대 후반 식자공들이 일정한 순서로 배열된 심볼을 가리킬 때 썼던 표현이며 나중에는 수학자들도 사용했습니다.자바스크립트 문자열은 유니코드(Unicode) 텍스트입니다.유니코드는 텍스트 데이터에 관한 표준이며 사람이 사용하는 언어 대부분의 글자와 심볼에 해당하는 코드 포인트(code point) 를 포함하고 있습니다.(여기서 말하는 ‘언어’에는 놀랍게도 이모티콘까지 표현됩니다.)유니코드 자체는 모든 언어의 텍스트를 나타낼 수 있지만, 유니코드를 사용하는 소프트웨어가 모든 코드 포인트를 정확히 렌더링한다고 보장하지는 않습니다.이 책에서는 브라우저와 콘솔에 정확히 나타날 것이 거의 확실한, 널리 쓰이는 유니코드 문자만 사용할 겁니다.널리 쓰이지 않는 글자나 언어를 사용해야 한다면 유니코드에서 코드 포인트를 어떻게 렌더링하는지 따로 조사해야 할 겁니다.자바스크립트의 문자열 리터럴에는 작은따옴표, 큰따옴표, 백틱(backtick)을 사용합니다.(백틱 - grave accent mark 라고 부르기도 합니다.)백틱은 ES6에서 도입한 것이며 곧 설명할 템플릿 문자열(template string) 에서 사용합니다."
}, 

{
"id": "-javascript-2020-04-18-javascript32",
"title": "3.6 숫자",
"author": null,
"tags": [],
"url": "/javascript/2020/04/18/javascript32/",
"date": "2020-04-18",
"content": "3이나 5.5, 1,000,000처럼 컴퓨터가 정확히 나타낼 수 있는 숫자도 있지만, 근사치로만 표현할 수 있는 숫자도 많습니다.예를 들어π는 절대 컴퓨터로 표현할 수 없습니다.원주율을 구성하는 숫자는 무한하고 반복되지도 않기 때문입니다.10/3 같은 숫자는 특별한 테크닉을 써서 나타낼 수 있긴 하지만, 소수점 아래 자리가 무한히 반복되므로(3.3333….) 일반적으로 근사치로만 나타냅니다.자바스크립트도 다른 프로그래밍 언어와 마찬가지로 실제 숫자의 근사치를 저장할 때 IEEE-764배정도(double-precision) 부동소수점 숫자 형식을 사용합니다.앞으로는 이 형식을 ‘더블’ 이라고 부를 겁니다.이 형식의 세부 사항은 이 책의 범위를 벗어납니다.하지만 자바스크립트로 심도 있는 숫자형 분석을 하지 않는 한 더블 형식을 이해할 필요는 별로 없습니다.그런데 더블 형식의 근사치 결과는 종종 사람들을 당혹스럽게 만들곤 합니다.예를 들어 자바스크립트에서 0.1 + 0.2는 0.30000000000000004를 반환합니다.이 결과는 자바스크립트에 버그가 있거나 덧셉을 할 줄 몰라서가 아닙니다.이건 무한한 값을 유한한 메모리 안에서 가능한 한 정확히 짐작하려다가 생긴 결과일 뿐입니다.자바스크립트에는 숫자형 데이터 타입이 하나밖에 없는데, 이건 흔치 않은 일입니다.(이런 상황은 나중에 바뀔 수도 있습니다. 세분화된 정수 타입은 꼭 필요한 기능입니다.)대부분의 프로그래밍 언어는 여러 가지 정수 타입을 사용하며 부동소수점 숫자 타입도 두 가지 이상 사용합니다.숫자형 데이터를 하나만 갖기로 한 선택은 자바스크립트를 단순한 언어로, 특히 초보자에게 부담 없는 언어로 만들었다는 장점이 있습니다.반면, 자바스크립트를 고성능 정수 연산이나 정밀한 소수점 연산이 필요한 애플리케이션에서 쓸 수 없게 만든 선택이기도 합니다.자바스크립트는 10진수, 2진수, 8진수, 16진수의 네 가지 숫자형 리터럴을 인식합니다.10진 리터럴에는 소수점 없는 정수, 소수점 있는 10진수(12.34 등), 과학에서 사용하는 지수 표기법을 쓸 수 있습니다.그 외에도 무한대, 음의 무한대, ‘숫자 아님’을 나타내는 특별한 값들이 있습니다.엄밀히 말해 이들은 숫자형 리터럴이 아니지만, 숫자형 값이므로 여기 포함했습니다.let count = 10; // 숫자 리터럴, count는 더블입니다.const blue = 0x0000ff; // 16진수, 16진수 ff는 10진수 255와 같습니다.const umask = 0o0022; // 8진수, 8진수 22는 십진수 18과 같습니다.const roomTemp = 21.5; // 십진수const C = 3.0e6; // 지수 (3.0 x 10^6 = 3,000,000)const e = -1.6e-19; // 지수 (-1.6 x 10^-19 = 0.00000000000000000016)const inf = Infinity;const ninf = -Infinity;const nan = NaN; // \"숫자가 아님\"  TIP 10진수, 16진수, 지수 등 어떤 리터럴 형식을 사용하더라도 결국 숫자는 더블 형식으로 저장됩니다.다양한 리터럴 형식은 숫자를 간편한 형식으로 표현할 수 있도록 제공된 것뿐입니다.자바스크립트가 표시할 수 있는 숫자 형식에는 제한이 있습니다. 이에 대해서는 16장에서 설명합니다.독자 중에 수학자가 있다면 무한대는 숫자가 아니라고 주장할 겁니다.물론 무한대는 숫자가 아닙니다.NaN도 숫자는 아닙니다.이들은 계산에 사용하는 숫자라기보다는 일종의 플레이스홀더입니다.또한 숫자에 대응하는 Number 객체에는 중요한 숫자형 값에 해당하는 유용한 프로퍼티가 있습니다.const small = Number.EPSILON; // 1에 더했을 때 1과 구분되는 결과를 만들 수 있는// 가장 적은 값입니다. 근사치는 2.2e-16입니다.const bigInt = Number.MAX_SAFE_INTEGER;// 표현할 수 있는 가장 큰 정수const max = Number.MAX_VALUE;// 표현할 수 있는 가장 큰 숫자const minInt = Number.MIN_SAFE_INTEGER; // 표현할 수 있는 가장 작은 정수const min = Number.MIN_VALUE;// 표현할 수 있는 가장 작은 숫자const nInf = Number.NEGATIVE_INFINITY;// -Infinityconst nan = Number.NaN;// NaNconst inf = Number.POSITIVE_INFINITY;// Infinity이들의 중요성에 대해서는 16장에서 설명합니다."
}, 

{
"id": "-javascript-2020-04-18-javascript31",
"title": "3.5 원시 타입과 객체",
"author": null,
"tags": [],
"url": "/javascript/2020/04/18/javascript31/",
"date": "2020-04-18",
"content": "자바스크립트의 값은 원시 값(primitive) 또는 객체(object) 입니다.문자열과 숫자 같은 원시 타입은 불변(immutable) 입니다.숫자 5는 항상 숫자 5입니다.문자열 “alpha”도 항상 문자열 “alpha”입니다.숫자가 불변임은 분명하지만, 문자열에 대해서는 혼동하는 사람들이 있습니다.예를 들어 “alpha” + “omega” 처럼 문자열을 병합한다면, 같은 문자열을 수정했을 뿐이라고 생각하는 겁니다.하지만 그렇지 않습니다.그건 다른 문자열입니다.5와 6이 서로 다른 숫자인 것과 마찬가지로 alpha와 alphaomega는 서로 다른 문자열입니다.원시 타입에는 여섯 가지가 있습니다.  숫자  문자열  불리언  null  undefined  심볼(Symbol)다만 불변성이라는 말이 변수의 값이 바뀔 수 없다는 뜻은 아닙니다.let str = \"hello\";str = \"world\";str은 먼저 불변인 값 “hello”로 초기화됐고, 다시 새로운 불변값 “world”를 할당받았습니다.중요한 것은 “hello”와 “world”가 서로 다른 문자열이라는 겁니다.바뀐 것은 str이 저장하는 값뿐입니다.이런 차이는 대개 이론적인 것이지만, 알고 있으면 6장에서 함수를 설명할 때 도움이 됩니다.이들 여섯 가지 원시 타입 외에 객체가 있습니다.원시 값과 달리 객체는 여러 가지 형태와 값을 가질 수 있습니다.객체의 유연한 성질 때문에 커스텀 데이터 타입을 만들 때 객체를 많이 사용합니다.자바스크립트에는 다음과 같이 몇 가지 내장된 객체 타입이 있습니다.  Array  Date  RegExp  Map과 WeakMap  Set과 WeakSet마지막으로, 원시 타입 중 숫자와 문자열, 불리언에는 각각 대응하는 객체 타입인 Number, String, Boolean이 있습니다.이들 대응하는 객체에 실제 값이 저장되지는 않습니다.이들은 대응하는 원시 값에 기능을 제공하는 역할을 합니다.이들 객체 타입은 대응하는 원시 값과 함께 설명할 겁니다."
}, 

{
"id": "-javascript-2020-04-18-javascript30",
"title": "3.4 리터럴",
"author": null,
"tags": [],
"url": "/javascript/2020/04/18/javascript30/",
"date": "2020-04-18",
"content": "우리는 이미 리터럴(literal) 을 사용했습니다.앞에서 currentTempC에 값을 할당할 때 사용한 22와 22.5가 숫자형 리터럴입니다.마찬가지로, room1을 초기화 할 때 문자열 리터럴인 \"conference_room_a\"를 사용했습니다.리터럴이라는 단어는 값을 프로그램 안에서 직접 지정한다는 의미입니다.리터럴은 값을 만드는 방법입니다.자바스크립트는 당신이 제공한 리터럴 값을 받아 데이터를 만듭니다.리터럴과 식별자(identifier) 의 차이를 이해하는 것이 중요합니다.예를 들어 앞에서 room1 변수에 값 \"conference_room_a\"을 할당한 것을 생각해 봅시다.room1은 변수를 가리키는 식별자입니다.그리고 \"conference_room_a\"은 문자에 리터럴인 동시에 room1의 값입니다.자바스크립트는 따옴표를 통해 리터럴과 식별자를 구분합니다.식별자는 숫자로 시작할 수 없으므로 숫자에는 따옴표가 필요 없습니다.다음 예제를 보십시오.let room1 = \"conference_room_a\"; // \"conference_room_a\"(따옴표 안)은 리터럴입니다.let currentRoom = room1; // 이제 currentRoom의 값은\t\t\t\t\t\t\t\t\t\t\t\t// room1의 값 (\"conference_room_a\")과 같습니다.currentRoom = conference_room_a; // 에러가 일어납니다.\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// conference_room_a 란 식별자는 존재하지 않습니다.  TIP 식별자를 써야 하는 곳, 다시 말해 값이 필요한 곳에는 어디든지 리터럴을 쓸 수 있습니다.예를 들어 프로그램에서 ROOM_TEMP_C가 있는 곳 어디든 숫자형 리터럴 21.5를 써도 됩니다.숫자형 리터럴을 한두군데 쓰는 정도라면 이렇게 해도 괜찮습니다.하지만 그런 곳이 10개, 또는 100개쯤 된다면 상수나 변수를 써야 합니다.상수나 변수를 쓰면 코드를 이해하기 쉽고 값을 바꿀 때도 한 곳에서만 바꾸면 됩니다.어디에 변수를 쓰고 어디에 상수를 쓸지 결정하는 것은 프로그래머의 몫입니다.어떤 경우는 상수를 쓰는 것이 거의 확실합니다.예를 들어 파이의 근삿값이나 DAYS_IN_MARCH 같은 경우는 상수가 적절합니다.ROOM_TEMP_C 처럼 모호한 경우도 있습니다.필자는 21.5도라는 온도를 아주 쾌적한 온도라고 생각하지만, 그렇게 생각하지 않는 사람도 있을 겁니다.따라서 이 값을 애플리케이션 안에서 바꿀 수 있어야 한다면 변수를 쓰는 게 맞습니다."
}, 

{
"id": "-javascript-2020-04-18-javascript29",
"title": "3.3 식별자 이름",
"author": null,
"tags": [],
"url": "/javascript/2020/04/18/javascript29/",
"date": "2020-04-18",
"content": "변수와 상수, 함수 이름을 식별자(identifier) 라 부릅니다.그리고 식별자에는 규칙이 있습니다.  식별자는 반드시 글자나 달러 기호($), 밑줄(_)로 시작해야 합니다.  식별자에는 글자와 숫자, 달러 기호, 밑줄만 쓸 수 있습니다.  π나 〥같은유니코드문자도쓸수있습니다.  예약어는 식별자로 쓸 수 없습니다.(부록 A에 예약어를 정리했습니다.)다른 언어에서는 달러 기호를 특수문자로 사용하지만 자바스크립트는 그렇지 않습니다.a나 z 같은 글자와 마찬가지로 식별자 이름에 사용할 수 있습니다.제이쿼리(jQuery) 같은 라이브러리는 이런 장점을 활용해서 달러 기호 자체를 식별자로 사용합니다.예약어는 자바스크립트에서 사용하는 단어이므로 프로그래머는 쓸 수 없습니다.예를 들어 let이라는 변수를 만들 수 없습니다.자바스크립트 식별자 표기법은 여러 가지이지만, 가장 널리 쓰는 두 가지는 다음과 같습니다.  카멜 케이스(camel case)currentTempC, anIdentifierName 등은 카멜 케이스에 따라 이름을 지은 겁니다.카멜이라는 이름은 중간중간의 대문자가 낙타의 혹처럼 보인다고 해서 붙였습니다.  스네이크 케이스(snake case)current_temp_c, an_identifier_name 등은 스네이크 케이스에 따라 이름을 지은 겁니다.스네이크 케이스는 카멜 케이스보다는 조금 덜 쓰입니다.표기법은 무엇을 써도 좋지만, 일관성을 지켜야 합니다.한 가지 표기법을 선택하고 그걸 계속 지키십시오.팀에서 일하고 있거나 프로젝트를 커뮤니티에 공유할 생각이라면, 그들이 어떤 표기법을 선호하는지 알아두십시오.식별자를 만들 때는 다음과 같은 방침을 염두에 두길 권합니다.  식별자는 대문자로 시작해서는 안됩니다. 9장에서 배울 클래스뿐입니다.  밑줄 한 개 또는 두 개로 시작하는 식별자는 아주 특별한 상황, 또는 ‘내부’ 변수에서만 사용합니다. 자신만의 특별한 변수 카테고리를 만들지 않는 한, 변수나 상수 이름을 밑줄로 시작하지 마십시오.  제이쿼리를 사용할 경우, 달러 기호로 시작하는 식별자는 보통 제이쿼리 객체라는 의미입니다. 제이쿼리는 19장에서 설명합니다."
}, 

{
"id": "-javascript-2020-04-18-javascript28",
"title": "3.2 변수와 상수 중 어떤 것을 써야 할까요?",
"author": null,
"tags": [],
"url": "/javascript/2020/04/18/javascript28/",
"date": "2020-04-18",
"content": "될 수 있으면 변수보다 상수를 써야 합니다.데이터의 값이 아무 때나 막 바뀌는 것보다는, 고정된 값이 이해하기 쉽습니다.상수를 사용하면 값을 바꾸지 말아야 할 데이터에서 실수로 값을 바꾸는 일이 줄어듭니다.예를 들어, 사용자에게 어떤 행동을 취하는 프로그램이라면 user 변수를 써야겠다고 생각할 수 있습니다.그런데 사용자가 단 한 명이라면?당연히 user의 값은 바뀔 수 없고, 만약 바뀌었다면 그건 에러입니다.상수를 사용하면 프로그래머가 신경쓰지 않아도 자바스크립트가 이런 상황에서 에러를 일으킵니다.사용자가 두 명이라면 user 변수 하나를 재사용하는 것보다는 user1과 user2로 나누는 편이 낫습니다.따라서 우선 상수를 먼저 생각합니다.그 상수의 값이 바뀌는 게 자연스럽다고 생각된다면, 언제든지 변수로 바꿀 수 있습니다.상수를 쓰면 안 되고 항상 변수를 써야 하는 상황도 있습니다.예를 들어 4장에서 배울 루프 제어에는 변수를 써야 합니다.시간이 지나면서 값이 바뀌는 경우에도 변수를 써야 합니다.이번 장에서 사용한 targetTempC, currentTemp 같은 변수가 좋은 예입니다.하지만 일단 상수를 쓰는 습관을 들이면, 변수가 꼭 필요한 상황이 생각보다 훨씬 적다는 걸 알고 놀라게 될 겁니다.이 책의 예제에서는 가능하면 항상 변수 대신 상수를 쓰도록 노력했습니다."
}, 

{
"id": "-javascript-2020-04-18-javascript27",
"title": "3.1 변수와 상수",
"author": null,
"tags": [],
"url": "/javascript/2020/04/18/javascript27/",
"date": "2020-04-18",
"content": "변수(variable) 란 간단히 말해 이름이 붙은 값으로, 변수라는 이름이 암시하듯 값은 언제든 바뀔 수 있습니다.예를 들어 날씨에 관한 프로그램을 만든다면 currentTempC 라는 변수를 사용할 수 있을 겁니다.let currentTempC = 22;  // 섭씨온도  NOTE_ let 키워드는 ES6에서 새로 생겼습니다.ES6 이전에는 var 키워드만 사용할 수 있었는데, var에 대해서는 7장에서 설명합니다.currentTempC = 22.5;이번에는 let을 사용하지 않았습니다.let은 변수 선언에만 쓰이고, 각 변수는 한 번만 선언할 수 있습니다.  TIP 단위가 필요한 숫자에서 단위와 값을 명확히 연결하는 방법은 없습니다.즉, 언어의 기능에는 currentTempC가 섭씨온도라고 명확히 규정할 방법이 없습니다.그런데 이 변수에 화씨온도를 할당하면 예상치 못한 결과가 나올 겁니다.따라서 필자는 변수 이름에 C를 붙여서 섭씨(Celsius) 단위임을 명확히 나타내고자 했습니다.자바스크립트는 이런 규칙을 강제할 수 없지만, 이런 규칙은 작은 실수를 방지하는 일종의 문서화입니다.변수를 선언할 때 꼭 초깃값을 지정해야 하는 건 아닙니다.초기값을 할당하지 않으면 암시적으로 특별한 값 undefined가 할당됩니다.let targetTempC; // let targetTempC = undefined; 와 같습니다.let문 하나에서 변수 여러 개를 선언할 수 있습니다.let targetTempC, room1 = \"conference_room_a\", room2 = \"lobby\";위 예제에서는 변수 세 개를 선언했습니다.targetTempC는 값을 할당하지 않았으므로 암시적으로 undefined를 받습니다.room1은 선언과 동시에 \"conference_room_a\"를 할당했고, room2 역시 선언과 동시에 \"lobby\"를 할당했습니다.room1과 room2는 문자열(텍스트) 변수입니다.상수(constant) 는 ES6에서 새로 생겼습니다.상수도 변수와 마찬가지로 값을 할당받을 수 있지만, 한 번 할당한 값을 바꿀 수는 없습니다.상수를 써서 쾌적한 온도와 최고 온도를 지정해 봅시다.const 역시 상수 여러 개를 선언할 수 있습니다.const ROOM_TEMP_C = 21.5, MAX_TEMP_C = 30;절대적인 규칙은 아니지만, 상수 이름에는 보통 대문자와 밑줄만 사용합니다.이런 규칙을 따르면 코드에서 상수를 찾기 쉽고, 상수의 값을 바꾸려 하지도 않게 됩니다."
}, 

{
"id": "-javascript-2020-04-18-javascript26",
"title": "3. 리터럴과 변수, 상수, 데이터 타입",
"author": null,
"tags": [],
"url": "/javascript/2020/04/18/javascript26/",
"date": "2020-04-18",
"content": "3장은 데이터에 관한 장이며, 데이터를 자바스크립트가 이해할 수 있는 형식으로 바꾸는 법을 배웁니다.컴퓨터가 모든 데이터를 0과 1로 바꾼다는 사실은 아마 알고 있을 겁니다.하지만 우리가 직접 0과 1만으로 일을 할 수는 없고, 우리에게 익숙한 형태인 숫자와 텍스트, 날짜 등을 다뤄야 합니다.이런 숫자와 텍스트, 날짜 등을 데이터 타입(data type) 이라 부릅니다.자바스크립트에서 사용할 수 있는 데이터 타입을 다루기 전에 먼저 변수(variable) 와 상수(constant), 리터럴(literal) 에 대해 알아봅시다.이들은 자바스크립트가 데이터를 보관하는 메커니즘입니다.  NOTE_ 프로그램을 배울 때 용어의 중요성을 과소평가하는 사람이 많습니다.리터럴과 값(value)이 어떻게 다른지, 표현식(expression)과 문(statement)이 어떻게 다른지 이해하지 못하면 프로그램 언어를 배우는 데 장애가 될 수 있습니다.이런 용어는 자바스크립트는 물론 컴퓨터 과학 전반에서 사용하는 용어입니다.개념을 잘 이해하는 것도 물론 중요하지만, 용어에 관심을 가지면 배운 언어에 관한 지식을 다른 언어에도 적용할 수 있고 더 많은 소스에서 배울 수 있습니다."
}, 

{
"id": "-javascript-2020-04-17-javascript25",
"title": "2.5 요약",
"author": null,
"tags": [],
"url": "/javascript/2020/04/17/javascript25/",
"date": "2020-04-17",
"content": "이번 2장에서는 ES6 지원이 아직 널리 정착되지는 않았지만, 트랜스컴파일을 통해 ES5 코드로 바꿀 수 있으니 ES6의 장점을 포기할 필요는 없음을 알게 됐습니다.개발용 컴퓨터를 설정할 때는 다음과 같은 준비가 필요합니다.  좋은 에디터(1장을 보십시오.)  깃 설치에 관한 내용은 https://git-scm.com/ 을 보십시오.  Gulp npm install -g gulp 명령으로 설치합니다.  ESLint npm install -g eslint 명령으로 설치합니다.새 프로젝트를 시작할 때는 다음과 같은 준비가 필요합니다.  프로젝트에 사용할 전용 디렉터리, 이 디렉터리를 프로젝트 루트라고 부릅니다.  깃 저장소(git init)  package.json 파일 (npm init)  Gulpfile gulpfile.js 이 장에서 만든 파일을 쓰십시오.  걸프와 바벨의 로컬 패키지, npm i -D @babel/register @babel/core @babel/preset-env  .babelrc 파일 { \"presets\": [ \"@babel/preset-env\" ] }  .eslintrc 파일, eslint --init 명령으로 만들고 원하는 대로 수정합니다.  노드 소스용 서브디렉터리 es6  브라우저 소스용 서브디렉터리 public/es6이상의 준비가 끝났으면 기본적인 작업 순서는 다음과 같습니다.  코드를 수정할 때는 논리적으로 일관되게 수정합니다.  걸프를 실행해서 코드에 존재하는 실수와 잠재적 오류를 찾습니다.  수정한 내용이 잘 동작하고 린트 프로그램에서 지적하는 것이 없을 때까지 반복합니다.  git status 명령을 써서 원하지 않는 파일이 커밋되지 않는지 확인하십시오. 깃에서 추적하지 말아야할 파일이 있다면 .gitignore 파일에 추가하십시오.  git add -A 명령으로 바꾼 내용을 저장소에 추가합니다. 한꺼번에 추가하지 않으려면 git add 명령을 파일마다 내려도 됩니다.  git commit -m \"[description of your changes]\" 명령으로 커밋합니다.프로젝트에 따라서는 걸프 작업에 테스크를 추가하거나, git push 명령으로 코드를 깃허브나 비트버킷 같은 공유 저장소에 올리는 등 다른 단계가 추가될 수 있습니다.하지만 여기서 제시한 단계를 생략하지는 마십시오.앞으로 책에서 소스 코드를 제시할 때는 빌드와 실행에 필요한 단계를 다시 설명하지는 않을 겁니다.예제에서 브라우저 코드라고 명시하지 않았다면 코드 샘플은 모두 노드에서 실행해야 합니다.예를 들어 example.js 파일을 사용하는 예제가 있다면 그 파일을 es6 폴더에 저장한 후 다음과 같이 실행하십시오.$ gulp$ node dist/example.js걸프 명령을 생략하고 babel-node로 실행해도 됩니다.babel-node도 트랜스컴파일 과정을 거치므로 시간이 줄어들지는 않습니다.$ babel-node es6/example.js이제 진짜 자바스크립트를 배울 시간입니다!"
}, 

{
"id": "-javascript-2020-04-14-javascript24",
"title": "2.4 린트",
"author": null,
"tags": [],
"url": "/javascript/2020/04/14/javascript24/",
"date": "2020-04-14",
"content": "인터뷰에 나가거나 파티에 참석할 때는 옷을 롤러로 문질러 보푸라기(lint)를 제거하지 않습니까?물론 그럴 테죠. 가능한 한 멋지게 보여야할 테니까요.마찬가지로 코드를(그 코드를 만든 당신도) 린트해서 멋져 보이게 할 수 있습니다.린트 프로그램은 당신의 코드를 세심히 검토해서 자주 일어나는 실수를 알려줍니다.필자는 25년째 소프트웨어를 만들고 있지만,아직도 실수를 저지르고 린트 프로그램이 찾아 준 다음에나 발견하곤 합니다.초보자에게 린트 프로그램은 정말 비할 데 없이 중요한 도구입니다.자바스크립트 린트 프로그램은 여러가지가 있지만, 필자는 그 중에서 니콜라스 자카스의 ESLint를 추천하는 편입니다.ESLint를 설치합시다.$ npm intall -g eslintESLint를 사용하기 전에 프로젝트에 쓸 설정 파일 .eslintrc 파일을 만들어 ESLint의 린트 규칙을 적용할 수 있습니다.eslint --init명령을 내리고 몇 가지 질문에 답하면 기본 .eslintrc 파일이 만들어집니다.프로젝트 루트에서eslint --init명령을 실행하십시오.첫 번째로 받을 질문은 계속 질문에 대답하면서 스타일을 정할 것인지,널리 쓰이는 스타일 가이드를 따를 것인지,기존 자바스크립트 파일을 분석해서 스타일을 정할 것인지 입니다.질문에 대답하면서 스타일을 정하겠다고 답하면 다음과 같은 질문을 받습니다. (나중에 질문이 바뀔 수 있습니다.)아무래도 질문이 바뀐 것 같습니다.  위의 질문은  오로지 문법검사만  문법과 문제점  문법 그리고 문제점 그리고 코드스타일두번째에 체크하고 넘어갑니다.깃배쉬에서는 숫자키로 입력을 합니다. 두번째를 선택하고 싶다면 숫자 2를 입력하고 enter키를 누르면 됩니다.이번엔 당신의 프로젝트에서 사용할 모듈유형을 묻는 질문입니다.JavaScript 모듈을 사용하기 때문에 숫자 ‘1’을 입력한 후 Enter키를 입력합니다.당신의 프로젝트에서 사용하는 프레임워크에 대해 묻는 질문입니다.현재는 리액트 그리고 뷰를 사용하지 않기 때문에 ‘3’을 입력하고 Enter 키를 입력합니다.이번엔 타입스크립트를 사용하느지에 대한 질문입니다.사용 안하므로 n을 입력하고 Enter 키를 입력합니다.어디에서 당신의 코드가 실행될지를 묻는 질문입니다.브라우저에서 실행될 지, 노드에서 실행될지를 묻는 질문입니다.둘 다에서 실행되는 거면 둘 다 체크하면 됩니다.당신의 환경설정 파일이 어떤 형태의 파일이면 좋겠는 지를 묻는 질문입니다.자바스크립트를 선택, 즉 ‘1’을 입력 후 Enter 키를 입력합니다.이렇게하면 eslint 설정 파일을 생성할 수 있습니다.책에 쓰여있는 과거 질문은 아래와 같았습니다. 한 4년전쯤 eslint  질문이었던 것 같습니다.  ECMAScript 6 기능을 사용합니까? - YES  ES6 모듈을 사용합니까? - YES  어디에서 코드를 실행합니까(노드 또는 브라우저)? - 브라우저와 노드에 각각 다른 설정을 적용하는 것이 이상적이겠지만, 그건 너무 고급 설정입니다. 노드를 선택하십시오.  CommonJS를 사용합니까? - No (CommonJS는 ES6 스타일 모듈의 일종이며 이 책에서 사용하지는 않습니다.)  JSX를 사용합니까? - NO (JSX는 XML 기반 자바스크립트 확장이며 페이스북의 UI 라이브러리 리액트에서 사용합니다. 이 책에서 JSX를 사용하지는 않습니다.)  들여쓰기를 어떤 식으로 하겠습니까? - 최근의 스택오버플로 설문을 보면 프로그래머 상당수가 탭을 사용한다고 응답했지만, 경험 많은 프로그래머는 스페이스를 선호합니다. 여기에 대한 답은 스스로 정하십시오.  문자열에 어떤 따옴표를 사용합니까? - 무엇이든 상관 없습니다.  줄 끝 문자에 무엇을 사용합니까(유닉스 또는 윈도우)? - 리눅스나 macOS를 사용한다면 유닉스를 선택하십시오. 윈도우를 사용한다면 윈도우를 선택하십시오.  세미콜론을 필수로 하길 원합니까? - YES  설정 파일 형식은 무엇으로 하겠습니까(JavaScript, YAML, JSON) - JavaScript. YAML은 JSON과 비슷한 데이터 직렬화형식이며 널리 쓰입니다. 자바스크립트를 선택하면 프로퍼티 키에 따옴표를 쓰지 않아도 에러로 간주하지 않으므로 타이핑을 줄일 수 있습니다.모든 질문에 답하면, .eslintrc 파일이 생성됩니다. 이제 ESLint를 사용할 수 있습니다.ESLint를 사용하는 방법은 여러 가지입니다.eslint es6/test.js위의 명령어 처럼 직접 실행해도 되고, 에디터에 통합할 수도 있고 Gulpfile에 추가해도 됩니다.에디터에 통합하면 아주 편리하지만, 방법이 에디터와 운영체제마다 전부 다르므로 이 책에서 설명할 수는 없습니다.에디터에 통합하길 원한다면 에디터 이름 뒤에 eslint를 붙여 검색해 보십시오.에디터에 통합하든 하지 않든, Gulpfile에는 ESLint를 꼭 추가하길 권합니다.결국 빌드할 때마다 걸프를 실행하므로 여기서 코드를 체크하는 것이 좋습니다.먼저 다음 명령을 실행합니다.npm install --save-dev gulp-eslintnpm i -D gulp-eslint그리고 gulpfile.js를 다음과 같이 수정합니다.const {src, dest, parallel, series} = require('gulp');const babel = require('gulp-babel');const eslint = require('gulp-eslint');function js_eslint() {    return src([\"es6/**.*.js\", \"public/es6/**/*.js\"])        .pipe(eslint())        .pipe(eslint.format());}function node_babel () {    return src(\"es6/**/*.js\")        .pipe(babel())        .pipe(dest(\"dist\"));}function browser_babel () {    return src(\"public/es6/**/*.js\")        .pipe(babel())        .pipe(dest(\"public/dist\"))}exports.default = series(js_eslint, parallel(node_babel, browser_babel));이제 ESLint에서 우리 코드 중 어떤 부분을 지적하는지 봅시다.Gulpfile의 기본 작업에 ESLint를 추가했으므로 걸프를 실행하기만 하면 됩니다.이런식으로 오류 또는 문제점이 있으면 실시간으로 알려줍니다.ESLint는 다행히 무엇을 실수로 지적할지 정할 수 있습니다.책과 달리 위와 같이 생성해서 gulp 명령어를 실행하면, 아무런 오류도 잡아내지 않습니다.그동안 버전업이 많이되면서 이 부분도 차이가 나는듯 합니다.다음은 책 내용입니다.  $ gulp[15:04:16] Using gulpfile ~/git/gulpfile.js[15:04:16] Starting 'default'...[15:04:16] Finished 'default' after 84 ms[15:04:16]/home/ethan/lj/es6/test.js4:59 error Unexpected trailing comma comma-dangle9:5 error Unexpected console statement no-consoleX 2 problems (2 errors, 0 warnings)    니콜라스 자카스와 필자는 줄 끝에 쉼표를 쓰는 것에 대해 의견이 다른 것 같습니다.다행히 ESLint는 무엇을 실수로 지적할지 정할 수 있습니다.comma-dangle 규칙의 기본값은 never이고, 우리는 이 규칙을 아예 끄거나 (필자가 주로 쓰는 설정인) always-multiline으로 정할 수 있습니다..eslintrc 파일을 수정해서 이 설정을 바꿔 봅시다.줄 끝 쉽표를 실수로 간주하는 니콜라스의 의견에 동의한다면 그냥 never로 두면 됩니다..eslintrc의 각 규칙은 배열입니다.배열의 첫 번째 요소는 숫자입니다.0은 규칙을 적용하지 않는 것이고, 1은 실수라고 지적하며, 2는 에러로 간주합니다.  {\t\"rules\": {\t\t/*\t\t\t마지막 쉼표에 관한 규칙을 수정했습니다.  \t\t\t하지만 이 파일은 JSON 파일이므로, 마지막 쉼표를 허용하는\t\t\t이 파일에는 마지막 쉼표를 쓸 수 없습니다.\t\t*/\t\t\"comma-dangle\": [\t\t\t2,\t\t\t\"always-multiline\"\t\t],\t\t\"indent\": [\t\t\t2,\t\t\t4\t\t],\t\t/* ... */\t}}    걸프를 다시 실행하면 줄 끝 쉼표를 에러로 지적하지 않습니다.사실, test.js에서 줄 끝 쉼표를 제거하면 에러가 일어납니다.  두 번째 에러는 console.log에 관한 것입니다.console.log를 실무 브라우저 코드에 남겨두는 것은 일반적으로 엉성한 습관이라 여기며, 구식 브라우저 대상일 경우 위험하기까지 합니다.하지만 연습과 공부 목적이라면 console.log에 대한 경고를 꺼도 됩니다.이 책을 진행하는 동안 console.log를 많이 사용합니다.그리고 quotes 규칙도 끄는 편이 낫습니다.이들 규칙을 비활성화하는 것은 독자의 연습분제로 남기겠습니다.  ESLint에는 설정 옵션이 아주 많으며, 이들은 모두 http://eslint.org/에 문서화되어 있습니다.  이제 ES6 코드를 작성하고, ES5 코드로 트랜스컴파일하고, 린트로 개선할 수 있으니 ES6를 본격적으로 배울 준비가 끝났습니다~!이 책을 번역하는 시점에서 마지막 쉼표를 지적하는 규칙이 사라졌지만, 저자의 의도를 존중하기 위해 원문을 그대로 옮겼습니다. 참고하시기 바랍니다."
}, 

{
"id": "-javascript-2020-04-14-javascript23",
"title": "2.3.1 바벨을 걸프와 함께 사용하기",
"author": null,
"tags": [],
"url": "/javascript/2020/04/14/javascript23/",
"date": "2020-04-14",
"content": "이제 걸프가 유용한 일을 하게 할 수 있습니다.우리가 작성할 ES6 코드를 ES5 코드로 바꾸는 일 말입니다.es6와 public/es6에 있는 코드를 ES5 코드로 변환해서 dist와 public/dist에 저장할 겁니다.npm install --save-dev gulp-babel 명령으로 gulp-babel 패키지를 설치하고 gulpfile.js를 다음과 같이 수정합니다.const {src, dest, parallel} = require('gulp');const babel = require('gulp-babel');function node_babel () {    return src(\"es6/**/*.js\")        .pipe(babel())        .pipe(dest(\"dist\"));}function browser_babel () {    return src(\"public/es6/**/*.js\")        .pipe(babel())        .pipe(dest(\"public/dist\"))}exports.default = parallel(node_babel, browser_babel);걸프는 파이프라인 개념으로 작업을 처리합니다.먼저 변환할 파일을(src(\"es6/**/*.js\")) 지정했습니다.**는 “서브디렉터리를 포함해 모든 디렉터리”를 뜻하는 와일드카드입니다.따라서 이 소스 필터는 서브디렉터리 깊이에 관계없이 es6에 있는 모든 .js 파일을 선택합니다.다음에는 이 소스 파일을 바벨에 파이프로 연결합니다.바벨은 ES6 코드를 ES5 코드로 변형합니다.마지막 단계에서는 컴파일된 ES5 코드를 dist 디렉터리에 저장합니다.걸프는 소스 파일 이름과 디렉터리 구조를 그대로 유지합니다.예를 들어 es6/a.js 파일은 dist/a.js 로 컴파일되고, es6/a/b/c.js 파일은 dist/a/b/c.js 로 컴파일되는 식입니다.같은 과정을 public/es6 디렉터리의 파일에 대해서도 반복합니다.아직 ES6에 대해 배우지 않았지만, ES6 샘플 파일을 만들고 걸프 설정이 제대로 동작하는지 확인해 봅시다.ES6의 새 기능을 사용하는 파일 es6/test.js을 만듭니다.지금 이 파일을 이해할 수 없어도 상관없습니다.이 책을 마칠 때쯤이면 이해할 수 있습니다.'use strict';// es6 기능 : 블록 스코프 변수 선언const sentences = [    {subject: 'JavaScript', verb: 'is', object: 'great'},    {subject: 'Elephants', verb: 'are', object: 'large'},];// es6 기능 : 객체 분해function say({subject, verb, object}) {    // es6 기능 : 템플릿 문자열    // 아래 사용한 것은 따옴표가 아니라 백틱(`), 즉    // 키보드의 탭 키 바로 위에 있는 문자입니다.    console.log(`${subject} ${verb} ${object}`);}// es6 기능 : for..offor (let s of sentences) {    say(s);}그리고 이 파일을 public/es6에 복사합니다.파일을 바꿔보고 싶다면 sentences 배열의 단어는 바꿔도 됩니다.이제 gulp 명령을 내립니다.작업이 끝나면 dist와 public/dist 디렉터리를 보십시오.두 디렉터리에 모두 test.js 파일이 있을 겁니다.파일을 열어서 ES6 파일과 다른 것을 확인하십시오.아래는 위의 ES6가 ES5로 컴파일된 모습입니다.'use strict'; // es6 기능 : 블록 스코프 변수 선언var sentences = [{  subject: 'JavaScript',  verb: 'is',  object: 'great'}, {  subject: 'Elephants',  verb: 'are',  object: 'large'}]; // es6 기능 : 객체 분해function say(_ref) {  var subject = _ref.subject,      verb = _ref.verb,      object = _ref.object;  // es6 기능 : 템플릿 문자열  // 아래 사용한 것은 따옴표가 아니라 백틱(`), 즉  // 키보드의 탭 키 바로 위에 있는 문자입니다.  console.log(\"\".concat(subject, \" \").concat(verb, \" \").concat(object));} // es6 기능 : for..offor (var _i = 0, _sentences = sentences; _i &lt; _sentences.length; _i++) {  var s = _sentences[_i];  say(s);}이제 ES6 코드를 바로 실행해 봅시다.현재 책과 다른 모습을 볼 수 있습니다.노드는 ES6 기능 지원을 점점 더 늘리고 있으니, 여러분이 이 책을 읽는 시점에 따라서는 완벽히 실행될 수도 있습니다.이제 ES5 코드를 실행합시다.ES6 코드를 어디서든 사용할 수 있는 ES5 코드로 바꾸는 데 성공했습니다.마지막으로, dist와 public/dist 디렉터리를 .gitignore 파일에 추가하십시오.우리는 ES6 소스만 추적하고, 자동으로 생성되는 ES5 파일은 추적하지 않습니다.# npm 디버그 기록npm-debug.log*# 프로젝트 의존성node_modules# macOS 폴더 속성.DS_Store# 임시 파일*.tmp*~# 결과물distpublic/dist"
}, 

{
"id": "-javascript-2020-04-14-javascript22",
"title": "2.3 트랜스컴파일러",
"author": null,
"tags": [],
"url": "/javascript/2020/04/14/javascript22/",
"date": "2020-04-14",
"content": "이 책을 쓰는 시점에서 가장 널리 쓰이는 트랜스컴파일러는 바벨과 트레이서입니다.필자는 두 트랜스컴파일러를 모두 사용해 봤는데, 둘 다 기능이 충실하고 사용하기 쉬웠습니다.이 책에서는 트랜스컴파일러로 바벨을 사용합니다.이제 시작합시다.바벨은 ES5를 ES6로 바꾸는 트랜스컴파일러로 시작했고, 프로젝트가 성장하면서 ES6와 리액트(React), ES7 등 여러 가지를 지원하는 범용 트랜스컴파일러가 됐습니다.바벨 버전 6부터는 ES5를 ES6로 변환하려면 ES6 변환 프리셋을 설치하고 바벨이 해당 프리셋을 사용하게끔 설정해야 합니다.어떤 프로젝트에서는 ES6를, 어떤 프로젝트에서는 리액트를 쓰게 될 수도 있으므로 이번 설정은 이 프로젝트에만 적용되게 만들 겁니다.먼저 ES6 프리셋, 코어, 레지스터를 설치합니다.npm i -D @babel/register @babel/core @babel/preset-env프로젝트 루트에 .babelrc 파일을 만듭니다.(파일 이름 없이 확장자만 쓰면 숨긴 파일이 됩니다.)touch .babelrc이 파일의 내용은 다음과 같습니다.{    \"presets\": [ \"@babel/preset-env\" ]}이 파일이 있으면 프로젝트에서 바벨을 사용할 때 ES6를 사용한다는 것을 인식하게 됩니다.(babel-preset-env는 babel-preset-latest (또는 babel-preset-es2015, babel-preset-es2016 및 babel-preset-es2017과 동일)와 정확히 동일하게 작동합니다.)"
}, 

{
"id": "-javascript-2020-04-13-javascript21",
"title": "2.2.7 프로젝트 구조",
"author": null,
"tags": [],
"url": "/javascript/2020/04/13/javascript21/",
"date": "2020-04-13",
"content": "걸프와 바벨을 써서 ES6 코드를 ES5 코드로 바꾸기 전에 코드를 어디에 저장할지 생각해야 합니다.자바스크립트 개발에서 프로젝트 레이아웃을 어떻게 구성하는지 정한 국제 표준 같은 건 없습니다.표준을 정하기엔 생태계가 너무 다양합니다.소스 코드를 src나 js 디렉터리에 저장하는 경우가 매우 많습니다.우리는 소스 코드를 es6 디렉터리에 저장할 겁니다.이렇게 하면 소스 코드를 ES6 코드로 만들었음을 명확히 알 수 있습니다.서버 쪽(노드) 코드와 클라이언트 쪽(브라우저) 코드를 모두 포함하는 프로젝트가 많으므로 우리 코드도 양쪽 카테고리를 모두 만듭니다.서버쪽 코드는 프로젝트 루트의 es6 디렉터리에 저장합니다.브라우저 코드는 public/es6 디렉터리에 저장합니다.브라우저에 보내는 자바스크립트는 원래 공개된(public) 것이고, 이런 식으로 저장하는 프로젝트가 아주 많습니다.다음 섹션에서는 ES6 코드를 ES5 코드로 변환합니다.ES6 코드와 ES5 코드를 섞어 놓을 수는 없으므로 ES5 코드를 저장할 장소가 필요합니다.이런 코드는 distribution의 약자인 dist 디렉터리에 저장하는 경우가 많습니다.준비가 끝나면 프로젝트 루트는 다음과 같은 모양이 될 겁니다."
}, 

{
"id": "-javascript-2020-04-13-javascript20",
"title": "2.2.6 빌드 도구 : 걸프와 그런트",
"author": null,
"tags": [],
"url": "/javascript/2020/04/13/javascript20/",
"date": "2020-04-13",
"content": "개발 과정에서 피할 수 없는 반복 작업을 자동화하는 빌드 도구가 필요합니다.현재 자바스크립트에서 가장 널리 쓰이는 빌드 도구는 그런트(Grunt)와 걸프(Gulp)입니다.이 둘은 모두 훌륭한 빌드 시스템입니다.그런트는 걸프보다 몇 해 먼저 등장했기에 커뮤니티도 더 크지만, 걸프는 그 차이를 빠르게 좁히고 있습니다.자바스크립트 개발을 시작하는 프로그래머들이 걸프를 선택하는 경우가 점점 더 늘어나고 있으므로 이 책에서는 걸프를 사용합니다.물론 어느 쪽이 더 낫다고 말하는 것은 아닙니다.먼저 걸프를 전역으로 설치합시다.$ npm intall -g gulp  CAUTION_ 리눅스나 macOS를 사용한다면 -g(전역) npm에서 플래그를 사용하기 위해 관리자 권한이 필요할 수도 있습니다.sudo npm intall -g gulp 명령을 내리면, 슈퍼유저 비밀번호를 묻는 프롬프트가 나타나고 이 명령어에 한해서 슈퍼유저 권한을 받게 됩니다.다른 사람이 관리하는 시스템을 사용한다면 sudoers 파일에 여러분을 추가해 달라고 요청할 수 있습니다.걸프를 전역으로 설치하는 것은 개발에 사용할 컴퓨터에 한 번만 하면 됩니다.그리고 프로젝트마다 로컬 걸프가 필요하므로, 프로젝트 루트에서 npm i -D gulp 명령을 실행합니다.걸프는 최종 사용자에게는 필요 없지만, 개발 과정에서 도움이 되는 개발 의존성에 속합니다.걸프가 없어도 앱은 잘 동작하지만, 개발할 때 걸프가 있으면 작업이 편해집니다.걸프가 설치되면 다음과 같이 gulpfile.js를 만듭니다.const gulp = require('gulp');// 걸프 의존성을 여기 씁니다.function first_function () {    // 걸프 작업을 여기 씁니다.    return console.log('걸프실행');}exports.default = first_function;아직 걸프가 할 일을 지정하지는 않았지만, 성공적으로 설치됐는지 확인하는 건 가능합니다.  CAUTION_ 윈도우 사용자라면 “The build tools for Visual Studio 2010 (Platform Toolset = v100) cannot be found.” 라는 에러가 표시될 수 있습니다.npm 패키지 중 상당수가 비쥬얼 스튜디오의 빌드 도구가 있어야 동작합니다.비쥬얼 스튜디오 다운로드 페이지에서 무료 버전을 내려받을 수 있습니다.비쥬얼 스튜디오 설치가 끝나면 시작 메뉴에서 “VS2015용 MSBuild 명령 프롬프트”를 찾아보십시오.이 명령어 프롬프트에서 프로젝트 루트로 이동하고 걸프를 다시 설치해 보면 잘 실행될 겁니다.비쥬얼 스튜디오의 명령어 프롬프트를 계속 사용할 필요는 없지만,  비쥬얼 스튜디오에 의존하는 npm 모듈을 설치할 때는 이 프롬프트를 사용하는 것이 가장 쉬운 방법입니다."
}, 

{
"id": "-javascript-2020-04-13-javascript19",
"title": "2.2.5 npm 패키지 관리",
"author": null,
"tags": [],
"url": "/javascript/2020/04/13/javascript19/",
"date": "2020-04-13",
"content": "꼭 npm을 알아야만 자바스크립트 개발이 가능한 건 아니지만,패키지 관리 도구로 npm을 사용하는 사람이 점점 늘어나고 있습니다.노드 개발에서는 npm이 필수라고 해도 과언이 아닙니다.실제로 노드 앱을 개발하든, 아니면 브라우저 앱만 개발하든, npm을 사용하면 일이 훨씬 쉬워집니다.여기서는 npm을 통해 빌드 도구와 트랜스컴파일러를 설치하겠습니다.npm은 노드를 설치할 때 함께 설치됩니다.따라서 아직 노드를 설치하지 않았따면 노드.js 홈페이지(https://nodejs.org/)에 가서 녹색 INSTALL 버튼을 클릭하십시오.이때 안정 버전과 최신 버전을 선택해 내려받을 수 있는데, 필자는 안정 버전을 설치하길 권합니다.설치가 끝나면 노드와 npm이 잘 동작하는지 다음 명령으로 확인하십시오.$ node -v$ npm -v노드와 npm은 계속 업데이트되므로 버전 번호는 다 다를 수 있습니다.npm의 목적은 간단히 말해 설치된 패키지 관리입니다.‘패키지’는 완전한 애플리케이션일 수도 있고, 코드 샘플일 수도 있고, 프로젝트에서 사용할 모듈 또는 라이브러리일 수도 있습니다.npm은 패키지를 설치할 때 전역으로(globally), 또는 로컬로(locally) 설치할 수 있습니다.전역으로 설치하는 패키지는 보통 개발 과정에서 사용하는, 터미널에서 실행하는 도구들입니다.로컬 패키지는 각 프로젝트에 종속되는 패키지입니다.패키지를 설치할 때는 npm install 명령어를 사용합니다.인기 있는 페키지 언더스코어(underscore) 를 설치하면서 어떻게 동작하는지 알아봅시다.프로젝트 루트에서 다음 명령을 실행하십시오.$ npm install underscore언더스코어 최신 버전을 설치했다는 메시지가 보입니다.위에 경고 메시지는 package.json 파일이 없다는 경고입니다.없어도 경고문구만 뜨지 딱히 오류는 안 생깁니다.노드 예전 버전에선 경고문구가 안뜨지만 최신버전에서는 뜹니다.버전 번호는 다르게 표시될 수 있습니다.언더스코어는 의존성이 없는 모듈이므로 npm의 출력 결과도 간단합니다.복잡한 모듈이라면 출력 결과가 한 페이지를 넘을 때도 있습니다.특정 버전을 설치하고 싶다면 다음과 같이 버전 번호를 명시적으로 지정해도 됩니다.$ npm install underscore@1.8.0그러면 이 모듈이 실제 설치된 위치는 어디일까요?프로젝트 루트를 보면 새 서브디렉터리 node_modules가 생겼습니다.로컬 모듈은 이 디렉터리에 설치됩니다.일단 node_modules 디렉터리를 삭제하십시오.이 디렉터리는 곧 다시 만들겁니다.설치하는 모듈이 늘어나면 모듈을 추적하고 관리할 방법이 필요해집니다.프로젝트에 설치하고 사용하는 모듈을 의존성(dependency) 이라 부릅니다.프로젝트가 성장하면서 늘어날 필요 패키지를 간결하게 정리할 방법이 있으면 좋을 겁니다.npm은 package.json 파일을 통해 의존성을 관리합니다.package.json을 직접 만들 필요는 없습니다.$ npm init명령을 내리고 몇 가지 질문에 답하면 됩니다.그냥 모든 질문에 엔터를 눌러서 기본값을 사용하고 나중에 파일을 수정해도 됩니다.지금 바로 npm init 명령을 내리고, package.json 파일을 열어 보십시오.의존성은 일반 의존성과 개발 의존성으로 나뉩니다.개발 의존성은 앱을 실행할 때는 필요 없지만, 프로젝트를 개발할 때 필요하거나 도움이 되는 패키지를 말합니다.곧 예제를 볼 겁니다.지금부터는 로컬 패키지를 설치할 때 –save(또는 -S 또는 미입력) 또는 –save-dev(또는 -D) 플래그를 사용합니다.이 플래그를 쓰지 않아도 패키지가 설치되긴 하지만, package.json 파일에는 등록되지 않습니다.(노드 최신버전은 플래그를 입력하지 않아도 자동으로 package.json 파일에 등록됩니다.)–save 플래그를 써서 언더스코어를 다시 설치해 봅시다.$ npm install --save underscore위의 경고 문구는 패키지 구성 요소가 빠져있다는 경고입니다.이 책을 공부할 때는 이 경고를 무시해도 됩니다.npm을 통해 패키지를 배포하려 한다면 이 경고에 신경을 써야 하지만,이 책에서는 배포에 관해 설명하지 않습니다.이제 package.json 파일을 보면 의존성 리스트에 언더스코어가 있습니다.의존성 관리가 가능한 것은, package.json 파일에서 패키지 이름과 버전 번호를 읽고 필요 패키지를 다시 내려받아 설치할 수 있기 때문입니다.지금 해봅시다.node_modules 디렉터리를 다시 삭제하고, npm install 명령을 내립니다.네, 패키지 이름을 쓰지 않는 것이 맞습니다.npm은 package.json 파일을 읽고 필요한 패키지를 자동으로 설치합니다.새로 만들어진 node_modules 디렉터리를 보면 확인할 수 있습니다."
}, 

{
"id": "-javascript-2020-04-12-javascript18",
"title": "2.2.4 깃과 버전 컨트롤",
"author": null,
"tags": [],
"url": "/javascript/2020/04/12/javascript18/",
"date": "2020-04-12",
"content": "이 책에서 버전 컨트롤에 대해 자세히 설명하지는 않지만, 혹시 버전 컨트롤을 사용하지 않았다면 지금부터라도 사용하십시오.아직 깃에 익숙하지 않다면 이 책을 통해 기회가 있으니 꼭 익숙해지기 바랍니다.먼저 프로젝트 루트에서 저장소를 초기화합니다.$ git init이 명령은 프로젝트 저장소를 만드는 명령입니다.이제 프로젝트 루트에 숨김 디렉터리 .git이 생겼습니다.버전 컨트롤을 사용하다 보면 깃에서 추적하지 않았으면 하는 파일이 분명 생길 겁니다.빌드 과정에서 생기는 파일, 임시 파일 같은 것들입니니다..gitignore 파일을 만드십시오.# npm 디버그 기록npm-debug.log*# 프로젝트 의존성node_modules# macOS 폴더 속성.DS_Store# 임시 파일*.tmp*~이 밖에도 쓸모없는 파일이 있어서 제외하고 싶다면 여기 추가하면 됩니다.예를 들어 에디터에서 파일을 저장할 때마다 .bak 파일을 만든다면 이 리스트에 *.bak을 추가하면 됩니다.깃을 사용하다 보면 git status 명령을 아주 많이 사용하게 될 겁니다.이 명령은 저장소의 현재 상태를 출력하는 명령입니다.지금 해 보십시오.다음과 같은 내용이 보여야 합니다.$ git statusOn branch masterInitial commitUntracked files:\t(use \"git add &lt;file&gt;...\" to include in what will be committed)\t.gitignore\tnothing added to commit but untracked files present (use \"git add\" to track)여기서 눈여겨볼 점은 깃이 디렉터리에 새 파일(.gitignore)이 있지만, 추적하고 있지 않다(untracked)고 보고하는 겁니다.깃 저장소를 사용하는 작업의 기본 단위는 커밋입니다.현재 저장소에는 커밋이 없습니다.저장소를 초기화하고 파일을 하나 만들었지만, 깃에 등록한 것은 아무것도 없습니다.깃은 어떤 파일을 추적해야 하는지 짐작하지 않으므로 .gitignore 파일을 명시적으로 저장소에 추가해야 합니다.$ git add .gitignore아직 커밋은 하지 않았습니다.다음 커밋에서 .gitignore 파일을 커밋하게끔 대기(stage) 시키기만 했습니다.git status 명령을 다시 실행하면 달라진 것이 있습니다.$ git statusOn branch masterInitial commitChanges to be committed:\t(use \"git rm --cached &lt;file&gt;...\" to unstage)\t\t\tnew file: .gitignore이제 .gitignore를 커밋할 준비가 됐습니다.아직 커밋은 하지 않았지만, 다음에 커밋할 때는 .gitignore를 변경한 내용이 포함될 겁니다.파일을 더 추가할 수 있지만, 일단 커밋을 해 봅시다.$ git commit -m \"Initial commit: added .gitignore.\"이 명령에서 -m 다음에 있는 것은 커밋 메시지입니다.커밋할 때마다 간단한 설명을 붙일 수 있습니다.커밋 메시지를 읽어보면 프로젝트를 어떻게 바꿔 왔는지 알 수 있습니다.커밋을 일종의 프로젝트 스냅샷이라 생각해도 됩니다.지금 찍은 스냅샷에는 .gitignore 파일 하나만 있고, 필요하다면 언제든 이 상태로 돌아올 수 있습니다.git status 명령을 다시 내리면 다음과 같은 화면을 볼 수 있습니다.On branch masternothing to commit, working directory clean프로젝트를 조금 더 바꿔봅시다.npm debug.log 파일을 무시하도록 .gitignore 파일을 설정 했는데, 확장자가 .log인 파일은 모두 무시하도록 바꿔 봅시다..gitignore 파일을 열고 npm-debug.log*를 *.log로 바꿉니다.프로젝트 설명을 마크다운 형식으로 제공하는 것이 일반적이니 README.md 파일도 하나 만듭시다.# Learning JavaScript, 3rd Edition## Chapter 2: JavaScript Development ToolsIn this chapter we're learning about Git and other development tools.다시 git status 명령을 내리면 다음과 같은 화면을 볼 수 있습니다.$ git statusOn branch masterChanges not staged for commit:\t(use \"git add &lt;file&gt;...\" to update what will be committed)\t(use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\t\t\tmodified: .gitignore\t\tUntracked files:\t(use \"git add &lt;file&gt;...\" to include in what will be committed)\t\t\tREADME.md바뀐 것이 두 가지 있습니다.하나는 추적 중인 파일 .gitignore이고 다른 하나는 새 파일 README.md입니다.앞서 git add 명령을 내렸던 것과 똑같이 할 수도 있습니다.$ git add .gitignore$ git add README.md하지만 이번에는 와일드카드를 써서 바뀐 사항을 모두 추가하게 한 다음 한꺼번에 커밋해 봅시다.$ git add -A$ git commit -m \"Ignored all .log files and added README.md.\"프로젝트를 만들다 보면 이 작업, 즉 바뀐 것을 추가하고 커밋하는 작업을 아주 자주 하게 될 겁니다.커밋 메시지는 짧고 논리적으로 일관되게 만들어야 합니다.당신이 생각하는 내용을 다른 사람에게 설명한다고 생각하고 커밋 메시지를 만드십시오.$ git add -A$ git commit -m \"[brief description of the changes you just made]\"  TIP 초보자들은 git add라는 명령을 보고 저장소에 ‘파일을 추가한다’고 착각하곤 합니다.물론 새 파일을 추가하는 경우도 있겠지만, 저장소에 이미 있는 파일을 수정하는 경우도 많습니다.다시 말해, 파일이 아니라 변경사항을 추가하는 겁니다.여기서 설명한 것은 깃으로 하는 작업 중 가장 간단한 것입니다.깃에 대해 더 자세히 알고 싶다면 깃허브의 초보자용 자료를 보거나, 존 롤리거와 매튜 맥컬로프가 쓴 Version Control with Git, 2nd ed. (O’reilly, 2012)을 보십시오.https://git-scm.com/book/ko/v2에 한글로 번역된 문서가 있으므로 필요할 때마다 찾아보면 도움이 될겁니다."
}, 

{
"id": "-javascript-2020-04-12-javascript17",
"title": "2.2.3 프로젝트 루트",
"author": null,
"tags": [],
"url": "/javascript/2020/04/12/javascript17/",
"date": "2020-04-12",
"content": "프로젝트마다 디렉터리를 따로 만드는 게 좋습니다.이 디렉터리를 프로젝트 루트라고 부를 겁니다.예를 들어 이 책의 예제를 lj 디렉터리에 저장한다면 그 디렉터리가 프로젝트 루트입니다.이 책의 모든 터미널 예제는 당신이 프로젝트 루트에 있다고 가정하고 만들었습니다.예제를 따라 했는데 뭔가 잘 안 되면, 가장 먼저 프로젝트 루트에서 명령을 내렸는지 확인하십시오.우리가 만들 파일은 모두 프로젝트 루트를 기준으로 한 상대 경로입니다.예를 들어 프로젝트 루트가 home/joe/work/lj 인데 책에서 public/js/test.js 파일을 만들라고 지시한다면, 그 파일의 전체 경로는 home/joe/work/lj/public/js/test.js 입니다."
}, 

{
"id": "-javascript-2020-04-12-javascript16",
"title": "2.2.2 터미널",
"author": null,
"tags": [],
"url": "/javascript/2020/04/12/javascript16/",
"date": "2020-04-12",
"content": "이 장을 따라 하는 동안에는 터미널(명령줄 또는 명령어 프롬프트라고도 합니다.) 에서 작업하게 됩니다.터미널은 텍스트 명령으로 컴퓨터를 조작하는 방법으로 프로그래머들은 터미널을 즐겨 사용합니다.물론 터미널을 사용하지 않아도 필요한 일은 다 할 수 있지만,필자는 터미널 사용법을 꼭 익히는 게 중요하다고 생각합니다.상당히 많은 책과 교재들이 터미널을 사용하도록 쓰여 있고, 터미널에서 사용하도록 설계된 도구들도 많기 때문입니다.가장 많이 쓰이는 터미널은 배시(bash) 라 불리는 셸입니다.리눅스와 macOS 컴퓨터에서는 기본적으로 배시를 사용합니다.윈도우에도 터미널이 있지만, 곧 설치할 깃에서는 따로 배시 터미널을 제공합니다.필자는 이 터미널을 사용하길 권합니다.이 책에서는 계속 배시를 사용합니다.리눅스나 macOS를 사용한다면 터미널 프로그램을 찾아보십시오.윈도우를 사용한다면 깃을 설치한 후 Git bash 프로그램을 찾아보십시오.터미널을 시작하면 커서가 깜박이는 프롬프트를 볼 수 있습니다.여기에 명령어를 입력합니다.기본 프롬프트에는 컴퓨터 이름이나 현재 디렉터리 이름이 들어가 있는 경우가 많고,일반적으로 달러 기호($)로 끝납니다.따라서 이 장의 코드 샘플에 달러 기호가 있으면 터미널이라고 생각하면 됩니다.달러 기호 다음에 있는 내용은 직접 입력해야 합니다.예를 들어 현재 디렉터리의 파일 리스트를 보려면 프롬프트에서 ls를 입력합니다.$ ls배시에서는 디렉터리 이름을 슬래시(/)로 구분합니다.윈도우에서는 디렉터리 이름을 역슬레시()로 구분하지만, 깃 배시에서는 역슬래시를 슬래시로 바꿔 표현합니다.배시에서는 홈 디렉터리(일반적으로 파일을 저장하는 디렉터리)를 ~로 표시합니다.이 장을 진행하려면 다른 디렉터리로 이동하는 명령(cd)과 새 디렉터리를 만드는 명령(mkdir)을 알고 있어야 합니다.예를 들어 홈 디렉터리로 이동하려면 다음과 같이 입력합니다.$ cd ~pwd 명령어는 현재 디렉터리 경로를 출력합니다.$ pwd현재 디렉터리에 서브디렉터리 test를 만들려면 다음과 같이 입력합니다.$ mkdir test새로 만든 디렉터리로 이동하려면 다음과 같이 입력합니다.$ cd test마침표 두 개(..)는 부모 디렉터리입니다.즉, 한 단계 위 디렉터리로 이동하려면 다음과 같이 입력합니다.앞의 명령어를 따라 했다면 홈 디렉터리로 돌아가게 됩니다.$ cd ..터미널에서 사용할 수 있는 명령어는 아주 많지만, 2장을 진행하기 위해서는 이들 명령어만 알아도 충분합니다.터미널에 대해 더 알고 싶다면 콘솔 기초 강의를 보십시오."
}, 

{
"id": "-javascript-2020-04-12-javascript15",
"title": "2.2.1 깃 설치",
"author": null,
"tags": [],
"url": "/javascript/2020/04/12/javascript15/",
"date": "2020-04-12",
"content": "아직 시스템에 깃을 설치하지 않았다면 깃 홈페이지(https://git-scm.com/)에서 운영체제에 맞는 설치 파일과 설치방법을 찾을 수 있습니다."
}, 

{
"id": "-javascript-2020-04-12-javascript14",
"title": "2.2 ES6 기능",
"author": null,
"tags": [],
"url": "/javascript/2020/04/12/javascript14/",
"date": "2020-04-12",
"content": "ES6에는 새 기능이 너무 많아서 트랜스컴파일러조차 전부 지원하지 못할 정도입니다.뉴욕에사는 개발자 캉각스는 이 혼란을 타개하기 위해 ES6(와 ES7)의 기능별 호환성 테이블을 운영하고 있습니다.2015년 8월 기준으로, 가장 많은 기능을 지원하는 바벨(Babel) 조차 72%에 불과합니다.힘 빠지는 말일 수도 있지만, 바벨은 가장 중요한 기능부터 차례로 지원하고 잇으며, 이 책에서 설명하는 기능은 모두 지원합니다.트랜스컴파일을 시작하기 전에 약간의 준비 작업이 필요합니다.필요한 도구를 모두 갖춰야 하고, 새 프로젝트에서 이들 도구를 사용하도록 설정하는 방법을 배워햐 합니다.새 프로젝트를 설정하는 방법은 몇 번만 해보면 무의식적으로 하게 될 겁니다.그때까지는, 새프로젝트를 시작할 때 이 장을 참고하십시오."
}, 

{
"id": "-javascript-2020-04-12-javascript13",
"title": "2.1 ES6 사용하기",
"author": null,
"tags": [],
"url": "/javascript/2020/04/12/javascript13/",
"date": "2020-04-12",
"content": "좋은 소식과 나쁜 소식이 있습니다.좋은 소식은 ES6가 자바스크립트를 즐겁고 흥미롭게 진화시켰다는 겁니다.나쁜 소식은 아직 ES6를 실무에서 쓰긴 좀 이르다는 겁니다.ES6를 전혀 사용할 수 없다는 뜻이 아닙니다.단지, 프로그래머가 ES6 코드를 어디에서든 쓸 수 있는 ‘안전한’ ES5 코드로 트랜스컴파일하는 수고를 좀 더 해야 한다는 뜻입니다.프로그래밍을 오래 해 왔다면 이렇게 생각할 수도 있습니다.“와, 믿을 수 없는데? 컴파일과 링크가 필요 없는 언어라니, 생각해 본 적도 없어.”필자도 꽤 오랫동안 프로그래밍을 해 왔고, 컴파일과 링크가 필요한 프로그램을 작성하곤 했지만 과거에 대한 향수 같은 것은 느끼지 않습니다.자바스크립트는 인터프리팅 언어이고 번거로운 부대작업이 필요 없다는 장점이 있습니다.(노드 같은 자바스크립트 엔진은 분명 자바스크립트를 컴파일하긴 하지만, 프로그래머가 개입할 필요 없이 자동으로 이루어집니다.)자바스크립트의 장점은 어디서든 쓰인다는 겁니다.자바스크립트는 거의 항상 브라우저 스크립트 언어의 표준이었고, 노드의 등장으로 이제 브라우저 바깥으로 영역을 확대하고 있습니다.그런 배경이 있으니, 브라우저가 지원하지 않을 수도 있다는 걱정 없이 ES6 코드를 사용하려면 아직 몇 년은 기다려야 할 수도 있다는 사실에 당혹감을 느낄 수도 있습니다.노드 개발자라면 상황이 조금 낫습니다.신경 써야 할 자바스크립트 엔진이 하나뿐이므로 노드의 ES6 지원을 지켜보면서 그에 맞게 대응하면 되니까요.  NOTE_ 이 책의 ES6 예제는 파이어폭스에서 작동하며, ES6 피들(http://www.es6fiddle.net/) 같은 웹 사이트에서도 동작합니다.하지만 실무에 사용하려면 이 장에서 소개하는 도구와 테크닉이 필요합니다.자바스크립트가 ES5에서 ES6로 넘어가는 과정은 점진적입니다.다른 언어에서는 볼 수 없었던 부분이죠.즉, 지금 사용하는 브라우저가 ES6의 기능을 일부 지원하지만 전체를 지원하지는 못할 수도 있습니다.자바스크립트가 점진적으로 변화할 수 있는 까닭은 자바스크립트의 동적 성격 때문이기도 하고,최근 브라우저 업데이트 방식 때문이기도 합니다.최근의 브라우저를 가리키는 에버그린(evergreen) 이라는 용어를 들어봤을 겁니다.브라우저 제작자들은 사용자가 직접 업데이트해야 하는 뚜렷한 버전 번호라는 개념에서 벗어나고 있습니다.브라우저가 제대로 동작하려면 항상 인터넷에 연결되어 있어야 하므로,항상 최신 버전을 유지할 수 있습니다.물론 버전은 여전히 존재하지만, 에버그린 브라우저들은 사용자가 업그레이드를 거부할 수 없게 하므로 최신 버전을 사용할 가능성이 큽니다.물론 에버그린 브라우저라도 ES6의 훌륭한 기능을 모두 지원할 때까지는 시간이 걸릴 겁니다.따라서 그때까지는 트랜스컴파일을 피할 수 없습니다."
}, 

{
"id": "-javascript-2020-04-12-javascript12",
"title": "2. 자바스크립트 개발 도구",
"author": null,
"tags": [],
"url": "/javascript/2020/04/12/javascript12/",
"date": "2020-04-12",
"content": "1장에서 본 것처럼 텍스트 에디터와 브라우저만 있어도 자바스크립트를 작성할 수 있지만, 유용한 개발 도구도 많이 있습니다.그리고 앞으로는 ES6만 사용할 것이므로 ES6 코드를 ES5 코드로 바꿀 방법도 필요합니다.이 장에서 설명하는 도구들은 매우 널리 쓰이므로, 오픈 소스 프로젝트나 소프트웨어 개발 팀에 참여하면 거의 반드시 사용하게 될 겁니다.  깃(git) : 프로젝트가 커져도 쉽게 관리할 수 있고 다른 개발자와 협력할 수 있게 돕는 버전 컨트롤 도구입니다.  노드(Node) : 브라우저 밖에서 자바스크립트를 실행할 수 있게 하는 도구입니다. 노드와 함께 설치되는 npm은 이 리스트의 다른 도구를 설치할 때 필요합니다.  걸프(Gulp) : 반복적인 개발 작업을 자동화하는 빌드 도구입니다. 그런트(Grunt)도 널리 쓰입니다.  바벨(Babel) : ES6 코드를 ES5 코드로 변환하는 트랜스컴파일러입니다.  ES린트(ESLint) : 자주 하는 실수를 피하고 더 나은 프로그래머가 되도록 돕는 린트 프로그램입니다.2장은 우리의 주제인 자바스크립트에서 멀어지는 장이 아닙니다.자바스크립트 개발에 널리 쓰이는 중요한 도구와 테크닉을 소개하는 장입니다."
}, 

{
"id": "-javascript-2020-04-12-javascript11",
"title": "1.10 Hello, World",
"author": null,
"tags": [],
"url": "/javascript/2020/04/12/javascript11/",
"date": "2020-04-12",
"content": "브라이언 커니핸의 예제로 이 장의 마지막을 장식하도록 합시다.어려운 부분은 이미 다 했습니다.이제 할 일은 텍스트를 추가하는 것뿐입니다.onMouseDown 핸들러 앞에 다음 코드를 추가하십시오.$(document).ready(function () {    'use strict';    paper.install(window);    paper.setup(document.getElementById('mainCanvas'));    var c = Shape.Circle(200, 200, 80);    c.fillColor = 'black';    var text = new PointText(200, 200);    text.justification = 'center';    text.fillColor = 'white';    text.fontSize = 20;    text.content = 'hello world';    var tool = new Tool();    tool.onMouseDown = function (event) {        var c = Shape.Circle(event.point.x, event.point.y, 20);        c.fillColor = 'green';    }    paper.view.draw();})여기서 추가한 내용은 매우 단순합니다.텍스트의 배경으로 쓸 다른 원을 하나 더 만들고, 텍스트 객체 PointText를 만들었습니다.텍스트가 캔버스의 중앙에 위치하도록 하고, 정렬 방식과 색깔, 크기 같은 몇 가지 속성을 지정했습니다.마지막으로 실제 텍스트 컨텐츠인 “hello world”를 지정했습니다.자바스크립트로 텍스트를 출력한 것이 이번이 처음은 아닙니다.이 장 초반의 console.log 예제에서도 이미 텍스트를 출력했습니다.물론 그 예제에서도 “hello world” 텍스트를 출력하는 것이 1972년에 했을 방법과 더 비슷할 겁니다.하지만 중요한 것은 텍스트의 내용이나 어떻게 출력되는지가 아닙니다.중요한 것은 자동으로 실행되는 것을 만들었다는 점, 그리고 눈으로 볼 수 있는 효과가 있다는 점입니다.브라우저를 새로고침하면 거룩한 “hello, world”의 전통에 동참하게 됩니다.“hello world”를 출력해본 것이 처음이라면, 프로그래밍의 세계에 오신 것을 환영합니다.그렇지 않다면, 이 예제를 통해 자바스크립트에 대해 어느 정도 이해할 수 있었기를 바랍니다."
}, 

{
"id": "-javascript-2020-04-12-javascript10",
"title": "1.9 사용자 입력 처리하기",
"author": null,
"tags": [],
"url": "/javascript/2020/04/12/javascript10/",
"date": "2020-04-12",
"content": "지금까지는 사용자의 입력을 전혀 받지 않은 채 프로그램을 실행했습니다.사용자가 원을 클릭할 수도 있지만, 아무 반응도 나타나지 않습니다.마찬가지로, 원을 드래그해봐도 아무 일도 일어나지 않습니다.원을 어디에 그릴지 사용자가 선택할 수 있게 해서 프로그램을 좀 더 대화형으로 바꿔봅시다.사용자 입력은 항상 비동기적이라는 사실에 익숙해져야 합니다.비동기적 이벤트란 이벤트가 언제 일어날지 프로그래머가 전혀 알 수 없는 이벤트를 말합니다.사용자의 마우스 클릭도 비동기적 이벤트의 일종입니다.사용자의 마음에 들어가지 않는 한 언제 클릭할지는 알 수 없습니다.사용자가 클릭하면 거기에 반응하는 건 물론 가능하지만, 언제 클릭할지, 클릭을 할지 말지는 사용자 마음대로입니다.**사용자의 입력에 따라 일어나는 비동기적 이벤트는 비교적 직관적이지만,책의 후반에서는 그다지 직관적이지 않은 비동기적 이벤트에 대해서드 공부하게 될겁니다. **Paper.js는 툴(tool) 객체를 통해 사용자 입력을 처리합니다.바둑판 모양으로 원을 그리는 코드를 다음 코드로 교체하십시오.$(document).ready(function () {    'use strict';    paper.install(window);    paper.setup(document.getElementById('mainCanvas'));    var tool = new Tool();    tool.onMouseDown = function (event) {        var c = Shape.Circle(event.point.x, event.point.y, 20);        c.fillColor = 'green';    }    paper.view.draw();})이 코드의 첫 행에서는 tool 객체를 만들었습니다.객체를 만들면 거기에 이벤트 핸들러를 연결할 수 있습니다.여기서는 onMouseDown 이벤트 핸들러를 연결했습니다.사용자가 마우스를 클릭할 때마다 이 핸들러에 연결한 함수가 호출됩니다.이 사실을 잘 이해해야 합니다.앞의 예제에서는 코드가 즉시 실행됐습니다.브라우저를 새로고침 하면 자동으로 녹색 원이 나타났습니다.여기서는 그렇게 하지 않습니다.그렇게 했다면 녹색 원 하나가 화면 어딘가에 나타났을 겁니다.대신, 사용자가 캔버스 어딘가를 마우스로 클릭해야만 function 다음에 있는 중괄호 사이의 코드가 실행됩니다.이벤트 핸들러는 두 가지 일을 합니다.  첫 번째는 마우스를 클릭할 때 코드를 실행하는 것이고,  두 번째는 어디를 클릭했는지 보고하는 겁니다.마우스로 클릭한 위치는 매개변수 event.point 프로퍼티에 저장됩니다.event.point의 x와 y 프로퍼티가 마우스로 클릭한 위치의 좌표입니다.x와 y 좌표를 각각 지정하지 않고 클릭한 위치를 바로 넘기면 좀 더 짧게 쓸 수 있습니다.var c = Shape.Circle(event.point, 20);이 코드는 자바스크립트에서 매우 중요한 측면을 잘 나타냅니다.자바스크립트는 넘겨받은 매개변수를 바탕으로 추론하는 능력이 있습니다.이전에 쓴 코드처럼 숫자 세 개를 연달아 넘기면 그 숫자들은 각각 x와 y 좌표, 반지름입니다.여기서처럼 매개변수 두 개를 넘기면 처음 것은 위치 객체이고, 두 번째 것은 반지름입니다.여기에 대해서는 6장과 9장에서 더 자세히 알아보겠습니다."
}, 

{
"id": "-javascript-2020-04-12-javascript09",
"title": "1.8 반복적인 작업 자동화하기",
"author": null,
"tags": [],
"url": "/javascript/2020/04/12/javascript09/",
"date": "2020-04-12",
"content": "원을 하나만 그리지 않고 캔버스 전체에 바둑판 모양으로 채우고 싶다고 해 봅시다.원의 크기를 줄이고 원의 중심이 서로 50px씩 떨어지게 하면 캔버스에 64개의 원을 그릴 수 있습니다.물론, 앞에서 만든 코드를 63번 복사해서 붙여넣고, 일일이 좌표를 수정해서 바둑판 모양으로 채워도 됩니다.하지만 너무 지겹겠지요?다행히 컴퓨터는 이런 반복적인 작업에 최적화되어 있습니다.원 64개를 동일한 간격으로 그리려면 어떻게 해야 하는지 살펴봅시다.원 하나를 그리는 코드를 다음과 같이 수정하십시오.$(document).ready(function () {    'use strict';    paper.install(window);    paper.setup(document.getElementById('mainCanvas'));    var c;    for (var x=25; x&lt;400; x+=50) {        for (var y=25; y&lt;400; y+=50) {            c = Shape.Circle(x, y, 20);            c.fillColor = 'green';        }    }    paper.view.draw();})브라우저를 새로고침하면 녹색 원 64개가 나타납니다.프로그래밍 경험이 없다면 앞의 코드가 좀 어렵게 느껴질 수도 있겠지만,128줄을 손으로 작성하는 것보다는 훨씬 낫다는 건 이해할 수 있을 겁니다.여기서 사용한 것은 for 루프입니다.for 루프는 4장에서 자세히 배울 흐름 제어 문법의 일부입니다.for 루프를 사용하려면 초기값(25), 제한 조건(400 미만), 증가분(50)이 필요합니다.x축과 y축에서 각각 반복해야 하므로 루프를 두 번 썼습니다.  NOTE_ 이 예제는 여러 가지 방법으로 만들 수 있습니다.여기서 사용한 방법은 x, y 좌표를 중요하게 취급했습니다.원이 어디서 시작하는지, 원 사이의 간격은 얼마가 되어야 하는지 명시적으로 지정했습니다.다른 방법을 쓸 수도 있습니다.예를 들어 좌표와 상관없이 원의 숫자(64)만 중요하다고 판단한다면, 프로그램에서 원을 캔버스 어디에 배치할지 정하게 만들 수도 있습니다.여기서 좌표를 지정하는 방법을 쓴 이유는 만약 루프를 사용하지 않고 코드를 63번 복사해서 붙여넣었다면 위와 비슷하게 원 사이의 간격을 지정했을 것으로 생각하기 때문입니다."
}, 

{
"id": "-javascript-2020-04-12-javascript08",
"title": "1.7 단순한 그래픽 그리기",
"author": null,
"tags": [],
"url": "/javascript/2020/04/12/javascript08/",
"date": "2020-04-12",
"content": "HTML5에서 발전한 것 중에는 표준화된 그래픽 인터페이스도 있습니다.HTML5 캔버스를 사용해서 그래픽 사각형이나 원, 다각형 같은 단순한 도형을 그릴 수 있습니다.캔버스를 직접 사용하는 건 매우 어렵고 손이 많이 가는 일이므로 그래픽 라이브러리 Paper.js(http://paperjs.org/)를 사용해서 HTML5 캔버스를 사용해 봅시다.  NOTE_ Paper.js가 유일한 캔버스 그래픽 라이브러리는 아닙니다.KineticJS(http://kineticjs.com/),Fabric.js(http://fabricjs.com/),EaselJS(http://www.createjs.com/easeljs)등은 모두 매우 인기 있고 잘 만들어진 라이브러리입니다. 필자는 이들 라이브러리를 모두 사용해 봤고 매우 만족했습니다.Paper.js로 그림을 그리기 전에 먼저 HTML 캔버스 요소를 준비해야 합니다.다음 행을 바디에 추가하십시오.위치는 어디든 상관없습니다.&lt;canvas id=\"mainCanvas\"&gt;&lt;/canvas&gt;캔버스에 사용한 id 속성은 자바스크립트와 CSS에서 이 요소를 쉽게 찾기 위한 것입니다.지금 당장 페이지를 확인하면 아무것도 달라지지 않았습니다.캔버스에 아무것도 그리지 않았을 뿐 아니라,흰 페이지 위의 흰 캔버스이고 너비와 높이도 지정하지 않았으니 당연히 차이를 발견할 수 없습니다.  NOTE_  모든 HTML 요소에 ID를 사용할 수 있고, HTML의 형식을 잘 지키려면 각 ID는 반드시 한번씩만 사용해야 합니다.즉, 캔버스의 id를 mainCanvas로 정했으므로 이 ID는 다시 사용할 수 없습니다.따라서 ID를 너무 남발하지는 않길 권합니다.여기서 ID를 사용한 이유는 초보자에게는 한 번에 하나씩 하는 게 배우기 쉽기 때문이고, ID는 원래 페이지 하나에 하나씩 쓰도록 정의되었기 때문입니다.캔버스가 페이지에서 잘 보이도록 main.css를 수정합시다.CSS에 익숙하지 않아도 괜찮습니다.여기서 수정할 내용은 단순히 HTML 요소에 너비와 높이를 설정하고 검은색 테두리를 추가하는 것뿐입니다.(CSS와 HTML에 대해 더 배우고 싶다면 코드 아카데미의 HTML &amp; CSS 무료 강좌를 보길 권합니다. https://www.codecademy.com/learn/web)#mainCanvas {    width: 400px;    height: 400px;    border: solid 1px black;}이제 페이지를 리로드하면 캔버스가 보입니다.이제 도형을 그릴 캔버스가 준비됐으니 그리는 작업을 도와줄 Paper.js 라이브러리를 링크합시다. 제이쿼리 링크 바로 다음, main.js 링크 바로 앞에 다음 행을 추가하십시오.&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.2/paper-full.min.js\"&gt;&lt;/script&gt;제이쿼리와 마찬가지로 이번에도 CDN을 통해 Paper.js를 불러왔습니다.  NOTE_ 이제 라이브러리를 링크하는 순서가 중요하다는 걸 깨달았을 겁니다.main.js에서 제이쿼리와 Paper.js를 모두 사용해야 하므로 이들을 먼저 링크해야 합니다.제이쿼리와 Paper.js는 서로 관계가 없으므로 이 두 라이브러리의 순서는 상관없지만,웹개발에서 제이쿼리가 빠지는 일은 거의 없으므로 항상 제이쿼리를 먼저 링크하는 습관을 들이길 권합니다.이제 Paper.js를 불러왔으니 설정 작업이 필요합니다.다음과 같이 어떤 일을 하기 전에 항상 먼저 실행해야 하는 코드를 보통 템플릿, 또는 보일러플레이트(boilerplate)라고 부릅니다.다음 코드를 mian.js의 use strict 바로 다음에 추가하십시오.(원한다면 console.log는 이제 제거해도 됩니다.)$(document).ready(function () {    'use strict';    paper.install(window);    paper.setup(document.getElementById('mainCanvas'));    // Todo    paper.view.draw();})첫 번째 행에서는 Paper.js를 전역 스코프에 설치했습니다.(스코프에 대해서는 7장에서 배웁니다.)두 번째 행에서는 Paper.js를 캔버스에 연결하고 Paper.js가 그림을 그릴 수 있도록 준비합니다.중앙의 Todo는 실제로 그림을 그리는 코드가 들어갈 자리입니다.마지막 행에서는 Paper.js가 실제로 화면에 그림을 그리라는 명령입니다.이제 템플릿이 준비됐으니 그림을 그려 봅시다.먼저 캔버스 중앙에 녹색 원을 그리겠습니다.Todo 주석을 다음 행으로 교체하십시오.$(document).ready(function () {    'use strict';    paper.install(window);    paper.setup(document.getElementById('mainCanvas'));    var c = Shape.Circle(200, 200, 50);    c.fillColor = 'green';    paper.view.draw();})브라우저를 새로고침 하니 녹색 원이 나타났습니다.\t\tvar c = Shape.Circle(200, 200, 50);    c.fillColor = 'green';사실 이 두 행에서는 아주 많은 일을 하고 있지만, 지금 알아야 할 것은 몇 가지뿐입니다.  첫 번째 행은 원 객체를 만들고, 객체를 만들기 위해 매개변수 세 가지를 받습니다.여기서 받은 매개변수는 원 중앙의 x, y 좌표와 원의 반지름입니다.캔버스 너비와 높이가 각각 400px이었으므로 캔버스의 중심은 (200, 200)입니다.반지름 50px은 캔버스의 너비와 높이의 1/8입니다.  두 번째 행에서는 채울 색깔(fill)을 정했습니다.이 색깔은 Paper.js에서 스트로크(stroke)라 부르는 외곽선 색깔과는 다릅니다.매개변수를 자유롭게 바꿔가면서 실험해봐도 괜찮습니다."
}, 

{
"id": "-javascript-2020-04-12-javascript07",
"title": "1.6 제이쿼리",
"author": null,
"tags": [],
"url": "/javascript/2020/04/12/javascript07/",
"date": "2020-04-12",
"content": "이제 대단히 인기있는 클라이언트 스크립트 라이브러리인 제이쿼리를 페이지에 불러올 겁니다.제이쿼리는 거의 어디에서나 쓰이는 라이브러리이며 웹 코드를 작성할 때 거의 항상 가장 먼저 불러오는 라이브러리이기도 합니다.지금 당장은 제이쿼리가 필요하지 않지만, 제이쿼리 코드에 빨리 익숙해질수록 좋습니다.바디 마지막, main.js를 불러온 행 바로 앞에 제이쿼리 링크를 삽입합시다.&lt;script src=\"https://code.jquery.com/jquery-3.4.1.min.js\"&gt;&lt;/script&gt;&lt;script src=\"main.js\"&gt;&lt;/script&gt;인터넷 URL을 통해 제이쿼리를 불러 왔으므로 인터넷에 연결되어 있지 않다면 페이지가 정확히 동작하지 않습니다.컨텐츠 전송 네트워크(CDN)에서 서비스하는 제이쿼리를 링크했습니다.이렇게 하면 불러오는 속도가 더 빨라집니다.오프라인으로 프로젝트를 만든다면 제이쿼리 파일을 내려받아 컴퓨터에서 불러와야 합니다.이제 제이쿼리의 장점을 활용하도록 main.js 파일을 수정합시다.$(document).ready(function () {    'use strict';    console.log('main.js loaded');})제이쿼리를 다뤄본 적이 없다면 이 코드는 괴상망측해 보일 겁니다.사실 이 코드는 대단히 많은 일을 하지만, 아직은 이 코드가 하는 일을 이해할 수 없을 겁니다.여기서 제이쿼리가 하는 일은 자바스크립트 코드를 실행하기 전에(비록 지금은 console.log 하나뿐이지만)브라우저가 HTML을 전부 불러왔는지 확인하는 겁니다.바른 습관을 들이기 위해, 브라우저 기반 자바스크립트를 만들 때마다 이렇게 할 겁니다.앞으로 만드는 자바스크립트 코드는 모두 $(document).ready(function() {}); 이 안에 들어갑니다.use strict; 라는 행도 있습니다.이 명령에 대해서는 나중에 더 자세히 배우지만, 간단히 말해 이 명령은 자바스크립트 인터프리터에서 코드를 더 엄격하게 처리하라는 뜻입니다.처음에는 엄격하다는 표현이 별로 좋지 않다고 생각하겠지만,코드를 엄격하게 처리하다 보면 더 나은 자바스크립트 코드를 쓸 수 있게 되고,자주 발생하기 어려운 문제를 방지할 수 있습니다.이 책에서는 매우 엄격한 자바스크립트를 배우게 될 겁니다."
}, 

{
"id": "-javascript-2020-04-12-javascript06",
"title": "1.5 자바스크립트 콘솔",
"author": null,
"tags": [],
"url": "/javascript/2020/04/12/javascript06/",
"date": "2020-04-12",
"content": "우리는 이미 자바스크립트 코드를 조금 썼습니다.console.log('main.js loaded');가 그것입니다.이 코드는 무슨 의미일까요?콘솔은 프로그램을 진단할 때 사용하는 텍스트 전용 도구입니다.이 책을 공부하는 동안 콘솔을 아주 많이 사용하게 될 겁니다.브라우저마다 콘솔에 접근하는 방법이 다릅니다.콘솔은 자주 사용하게 될 테니 키보드 단축키를 기억하는 것이 좋습니다.윈도우와 리눅스용 파이어폭스에서는 ctrl+shift+k를 누르면 되고, 맥용 파이어폭스에서는 Command+Option+K를 누르면 됩니다.index.html을 불러온 페이지에서 자바스크립트 콘솔을 열면 main.js loaded라는 텍스트가 보여야 합니다.만약 보이지 않으면 페이지를 리로드해 보십시오.console.log는 메서드입니다.  함수와 메서드의 차이에 대해서는 9장에서 자세히 설명합니다.이 메서드는 원하는 내용을 콘솔에 출력할 때 사용하며 디버깅에도 유용하고 언어를 배울 때도 유용합니다.콘솔에는 여러 가지 유용한 기능이 많은데, 프로그램의 출력 결과를 보는 것 외에도 자바스크립트 코드를 콘솔에 직접 입력할 수 있습니다.이를 통해 간단한 테스트를 하거나 자바스크립트 기능을 공부할 수 있고, 심지어 프로그램을 임시로 수정하는 것도 가능합니다."
}, 

{
"id": "-javascript-2020-04-12-javascript05",
"title": "1.4 시작하기",
"author": null,
"tags": [],
"url": "/javascript/2020/04/12/javascript05/",
"date": "2020-04-12",
"content": "먼저 HTML 파일과 CSS 파일, 자바스크립트 소스 파일 세 가지를 만들면서 시작하겠습니다.자바스크립트와 CSS는 HTML에 포함될 수 있으므로 HTML 파일 하나에서 모든 일을 다 할 수도 있지만,이들을 분리하면 뚜렷한 장점이 있습니다.프로그래밍이 처음이라면 여기서 설명하는 대로 한 단계씩 따라 하길 강력히 권합니다.이 장에서는 단계적으로 하나씩 알아보는 접근법을 택할 것이고 따라 하다 보면 기초가 확고해질 겁니다.언떳 보면 정말 간단한 목적인데도, 그런 간단함에 비해 지나치게 많은 일을 하는 듯 보일 수도 있습니다.그리고 어느 정도는 실제로 그렇기도 합니다.물론, 똑같은 일을 훨씬 간단히 하는 예제를 만들 수도 있습니다.하지만 그렇게 한다면 독자 여러분에게 나쁜 습관이 생길 수도 있습니다.여기서 볼 가외의 단계들은 앞으로 몇 번이고 반복해서 보게 될 겁니다.그리고 지금 지나치게 복잡하다고 느껴질 그 단계들을 반복함으로써, 일을 올바른 방법으로 하고 있다고 확신하게 될 겁니다.이 장에 대해 짚고 넘어갈 중요한 점이 하나 있습니다.이 장은 코드 예제에서 ES6 문법이 아니라 ES5 문법을 쓰는 유일한 장입니다.ES5 문법을 쓰는 이유는 ES6를 지원하지 않는 브라우저를 사용하더라도 코드 샘플이 동작하게 하기 위해서입니다.다음 2장부터는 ES6 코드를 어떻게 작성하는지, 그리고 구식 브라우저에서도 동작하도록 트랜스컴파일(transcompile)하는 방법을 배웁니다.그런 기초를 익히고 나면, 그 다음부터는 ES6 문법을 사용합니다.이 장의 코드샘플은 아주 단순하므로 ES5 문법을 사용해도 큰 차이는 없습니다.  NOTE_ 이 예제를 연습할 때는 모든 파일을 같은 디렉터리에 보관하는 게 좋습니다.다른 파일과 섞여서 찾기 힘들어지는 일이 없도록, 이 예제의 파일을 담을 디렉터리를 새로 만들길 권합니다.먼저 자바스크립트 파일로 시작합시다.텍스트 에디터를 열고 main.js 파일을 만드십시오.지금은 이 파일에 행 하나만 추가합니다.console.log('main.js loaded');다음에는 CSS 파일 main.css를 만드십시오.아직 이 파일에 쓸 내용이 없으므로, 주석만 한 줄 써서 빈 파일이 되지 않게 만듭니다./* 여기 스타일을 씁니다. */그리고 index.html 파일을 만듭니다.&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;link rel=\"stylesheet\" href=\"main.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My first application!&lt;/h1&gt;&lt;p&gt;Welcome to &lt;i&gt;Learning JavaScript, 3rd Edition&lt;/i&gt;.&lt;/p&gt;&lt;script src=\"main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;이 책은 HTML이나 웹 애플리케이션 개발에 관한 책은 아니지만,자바스크립트를 공부하는 독자들은 대개 그런 목적으로 공부하는 것일 테니HTML에서 자바스크립트 개발에 관련된 부분을 조금 짚고 넘어갑시다.HTML 문서는 크게 헤드(head)와 바디(body)로 나뉩니다.헤드에는 브라우저에 표시되는 내용과 관련이 있긴 하지만,   브라우저에 직접 표시되지는 않는 정보가 들어있습니다.바디에는 브라우저에 렌더링될 페이지 콘텐츠가 들어 있습니다.헤드에는 브라우저에 절대 나타나지 않는 요소가 들어 있고,바디의 요소는 보통 브라우저에 나타난다는 것을 이해하는 것이 중요합니다.물론 &lt;script&gt; 같은 특정 요소는 바디에 있더라도 브라우저에 나타나지 않고, CSS 스타일로 바디의 요소가 보이지 않게 감출 수 있긴 합니다.헤드에 있는 &lt;link rel=\"stylesheet\" href=\"main.css\"&gt;는 현재 비어 있는 CSS파일을 문서로 불러오는 링크입니다.바디 마지막에 있는 &lt;script src=\"main.js\"&gt;&lt;/script&gt;는 자바스크립트 파일을 문서로 불러오는 링크입니다.하나는 헤드에 있고 다른 하나는 바디 마지막에 있다는 사실이 조금 이상해 보일 수도 있습니다.&lt;script&gt; 태그를 헤드에 넣을 수도 있지만, 그렇게 하면 성능이 다소 떨어지고 헤드가 지나치게 복잡해지므로 바디 마지막에 놓습니다.바디에는 &lt;h1&gt;My first application!&lt;/h1&gt;가 있습니다.이 태그는 최상위 헤더 텍스트, 즉 페이지에서 가장 크고 중요한 텍스트입니다.그 다음에 있는 &lt;p&gt; (문단) 태그에는 텍스트가 들어있는데 그중 일부는 이탤릭체입니다.(&lt;i&gt; 태그로 둘러싸여 있습니다.)브라우저에서 index.html을 불러 보십시오.대부분의 시스템에서 가장 쉬운 방법은 파일 브라우저에서 파일을 더블클릭하는 겁니다.파일을 브라우저 창에 드래그해도 됩니다.HTML 파일의 바디 콘텐츠가 보일 겁니다.  NOTE_ 이 책에는 코드 샘플이 많습니다.HTML과 자바스크립트 파일은 매우 커질 수 있으므로 책에 매번 파일 전체를 싣지는 않겠습니다.코드 샘플을 파일의 어디에 넣어야 할지 본문에서 설명할 겁니다.이렇게 하면 초보 프로그래머에게는 조금 골치가 아플 수 있겠지만, 결국에는 코드가 어떻게 서로 어울리는지 이해해야 합니다.이걸 이해하지 않고 지나가기란 불가능합니다."
}, 

{
"id": "-javascript-2020-04-12-javascript04",
"title": "1.3 주석에 관해",
"author": null,
"tags": [],
"url": "/javascript/2020/04/12/javascript04/",
"date": "2020-04-12",
"content": "자바스크립트도 다른 프로그램이 언어와 마찬가지로 코드 안에 주석을 쓰는 문법이 있습니다.자바스크립트는 주석을 완전히 무시합니다.주석은 당신이나 동료 프로그래머가 보라고 만드는 겁니다.주석에는 코드만 봐서는 무슨 일이 일어나는지 분명히 알기 어려울 때 설명을 달아둡니다.이 책에서도 예제에 주석을 많이 사용해서 코드의 의미를 설명합니다.자바스크립트의 주석은 인라인 주석과 블록 주석 두 가지입니다.인라인 주석은 슬래시 두 개(//)로 시작해서 행 끝에서 끝납니다.// 인라인 주석블록 주석은 /*로 시작해서 */로 끝나며 여러 줄에 걸쳐 쓸 수 있습니다.다음 예제는 두 가지 주석을 어떻게 사용하는지 보여줍니다.console.log(\"echo\");   // 콘솔에 \"echo\"를 출력합니다.  /*  \t위 행에서 // 앞에 있는 것은 모두 자바스크립트 코드이며\t문법에 맞게 써야 합니다. // 뒤에 있는 것은 주석이고,\t자바스크립트는 주석을 무시합니다.\t이 텍스트는 블록 주석이며 이것 역시 무시됩니다. 가독성을\t생각해서 들여썼지만 꼭 들여써야 하는 건 아닙니다.*//* 들여쓰지 않아도 됩니다. */곧 알아볼 캐스케이딩 스타일시트(css)도 블록 주석에는 자바스크립트와 같은 문법을 씁니다.css는 인라인 주석은 지원하지 않습니다.HTML에도 인라인 주석은 없고, 블록 주석은 자바스크립트와 다른 문법을 사용합니다.&lt;!-- 이 부분 --&gt;위에 이 부분에 있는 내용은 모두 주석입니다.&lt;head&gt;\t&lt;title&gt;HTML and CSS Example&lt;/title&gt;\t&lt;!-- HTML 주석입니다.           여러 줄에 걸쳐서 써도 됩니다. --&gt;\t&lt;style&gt;\t\tbody: {color:red;}\t\t/* CSS 주석입니다.\t\t          역시 여러 줄에 걸쳐서 써도 됩니다. */\t&lt;/style&gt;\t&lt;script&gt;\t\tconsole.log(\"echo\"); // 다시 자바스크립트로 돌아왔습니다.\t\t/* 여기서는 인라인 주석과 블록 주석을\t\t         모두 쓸 수 있습니다. */\t&lt;/script&gt;&lt;/head&gt;"
}, 

{
"id": "-javascript-2020-04-11-javascript03",
"title": "1.2 사용할 프로그램",
"author": null,
"tags": [],
"url": "/javascript/2020/04/11/javascript03/",
"date": "2020-04-11",
"content": "목수는 톱이 있어야 책상을 만들 수 있고, 우리는 몇 가지 프로그램이 있어야 소프트웨어를 만들 수 있습니다.다행히 많은 준비가 필요하지는 않습니다.이번 장에서 우리에게 필요한 것은 브라우저와 텍스트 에디터뿐입니다.이 소식을 전하게 되어 무척 기쁩니다.현재 사용되는 브라우저는 모두 이 장의 예제를 잘 실행할 수 있습니다.심지어 오랫동안 프로그래머들을 괴롭혔던 인터넷 익스플로러도 충분히 발전해서이제는 크롬이나 파이어폭스, 사파리, 오페라에 뒤떨어지지 않습니다.필자는 파이어폭스를 선택했고, 프로그램을 배울 때 도움이 되는 파이어폭스의 기능을 설명할 겁니다.다른 브라우저에도 이런 기능이 있지만,이 책에서 브라우저의 기능을 설명할 때는 파이어폭스를 기준으로 설명합니다.따라서 이 책을 공부할 때는 파이어폭스를 사용하는 게 가장 쉽습니다.코드를 작성하려면 텍스트 에디터가 필요합니다.텍스트 에디터의 선택은 매우 논란이 많은 주제입니다.어떤 사람들은 종교적으로 보일 정도로 열띤 토론을 하기도 합니다.텍스트 에디터는 크게 [텍스트 모드 에디터]와 [창 모드 에디터] 두 가지로 나눌 수 있습니다.텍스트 모드 에디터 중 가장 널리 쓰이는 것은 vi/vim과 이맥스입니다.텍스트 모드 에디터에 익숙해지면 SSH 등으로 원격 컴퓨터에 접속한 상태에서도 익숙한 에디터로 파일을 편집할 수 있다는 장점이 있습니다.창 모드 에디터는 더 세련돼 보이고, 친숙하고 유용한 사용자 인터페이스를 갖추고 있습니다.하지만 가장 중요한 것은, 결국 텍스트를 편집하는 것이 목적이므로 창 모드 에디터가 텍스트 모드 에디터보다 본질에서 우수하다고 볼 수는 없습니다.창 모드 에디터 중에서는 아톰(Atom), 서브라임 텍스트(Sublime text), 코다(Coda), 비쥬얼스튜디오(Visual Studio), 노트패드++(Notepad++), 텍스트패드(TextPad), Xcode 등이 널리 쓰입니다.이들 에디터 중 하나에 익숙하다면 굳이 다른 에디터로 바꿀 필요는 없습니다.하지만 윈도우 메모장을 사용하고 있다면 바꾸길 강력히 권합니다.노트패드++은 무료이고 사용하기도 쉽습니다.에디터의 기능을 모두 이 책에서 설명할 수는 없지만, 다음 몇 가지 기능은 꼭 익혀야 합니다.      문법하이라이트 문법 하이라이트 기능은 프로그램의 문법적 요소를 색깔로 구별하는 기능입니다.   예를 들어 리터럴은 주황색으로, 변수는 하늘색으로 표시하는 등입니다(이들 용어의 의미는 곧 알게됩니다).   이 기능은 코드에서 문제가 있는 부분을 쉽게 찾도록 도와줍니다.   최신 텍스트 에디터는 대부분 문법 하이라이트 기능을 기본으로 활성화해 놓습니다.   만약 코드가 단색으로 표시된다면 에디터의 설명서를 읽어보십시오.        괄호 맞추기    프로그래밍 언어는 대부분 괄호를 아주 많이 사용합니다.   괄호로 둘러싼 내용이 여러 줄인 경우도 있고, 심지어 괄호 하나가 화면을 넘어갈 때도 있습니다.   괄호 안에 다른 괄호를 쓰는 일도 아주 많습니다.   괄호는 반드시 짝이 맞아야 하며, 짝이 맞지 않으면 프로그램이 정확히 동작하지 않습니다.   괄호 맞춤 기능은 괄호가 어디서 시작하고 어디서 끝나는지 알기 쉽게 표시해줍니다.   괄호의 짝이 맞지 않아서 생기는 문제를 해결하기도 쉽습니다.   괄호 맞춤 기능은 에디터마다 다릅니다.   보일 듯 말듯한 표시를 하는 에디터도 있고, 아주 분명히 표시하는 에디터도 있습니다.   초보자들은 괄호의 짝이 맞지 않아 생기는 문제를 많이 겪는 편이니 에디터의 괄호 맞춤 기능에 익숙해지길 강력히 권합니다.        코드 접기    코드 접기 기능은 괄호 맞춤 기능과 조금 관련이 있습니다.코드 접기는 지금 당장 하는 일과 무관한 코드를 임시로 숨겨서 지금 하는 일에 집중하도록 돕는 기능입니다.이 용어는 종이를 접어서 중요하지 않은 세부사항을 가린다는 의미에서 만들어졌습니다.괄호 맞춤처럼 코드 접기도 에디터마다 다른 형태로 일어납니다.        자동 완성     자동 완성은 단어 일부를 타이핑하기만 해도 어떤 단어를 타이핑하려 했는지 짐작해서 제시하는 간편한 기능입니다. 이 기능은 단어 완성(word completion)  또는 인텔리센스(마이크로 소프트에서 쓰는 용어)라고도 합니다. 자동 완성에는 두 가지 목적이 있습니다.    하나는 타이핑 시간을 줄이는 겁니다.예를 들어 encodeURIComponent를 타이핑하고 싶다면, enc까지만 타이핑해도 나타나는 리스트에서 encodeURIComponent를 선택할 수 있습니다.  두 번째 목적은 발견입니다.예를 들어 encodeURIComponent를 쓰고 싶어서 enc를 타이핑하면 리스트에서 encodeURI라는 함수를 발견하게 됩니다.에디터에 따라서는 두 함수의 차이에 대한 간단한 설명이 나타날 수도 있습니다.자바스크립트는 느슨한 타입을 사용하는 언어이고 스코프 규칙도 독특해서 다른 언어에 비해 자동 완성을 구현하기 어렵습니다.자동완성이 꼭 필요하다고 느낀다면 잠시 시간을 들여 어떤 에디터가 자신에게 가장 맞는지 알아보는 것도 좋습니다.일부 에디터는 자동 완성이 매우 잘 만들어져 있습니다.vim 같은 에디터는 매우 강력한 자동완성 기능을 제공하지만 사용자 설정이 필요합니다."
}, 

{
"id": "-javascript-2020-04-11-javascript02",
"title": "1.1 시작은 브라우저에서",
"author": null,
"tags": [],
"url": "/javascript/2020/04/11/javascript02/",
"date": "2020-04-11",
"content": "이 블로그에서는 서버 쪽, 스크립팅, 데스크톱, 브라우저에서의 활용 등 현재 자바스크립트가 쓰이는 모든 분야를 다루겠지만,전통적으로 그래 왔고 현실적이기도 한 이유로 브라우저 기반 프로그램부터 만들겠습니다.브라우저 기반 프로그램부터 만드는 이유 중에는 그래픽 라이브러리를 사용하기가 편리하다는 점도 있습니다.사람은 시각적인 동물이므로 프로그래밍 개념과 시각적 요소를 결합하면 배우기가 훨씬 쉬워집니다.이 책을 공부하는 동안 텍스트를 노려보며 보내는 시간이 많겠지만,처음에는 흥미로워 보이는 것들로 시작하겠습니다.이 예제를 선택한 배경에는 이벤트 주도 프로그래밍(event-driven programming) 같은아주 중요한 개념으로 자연스럽게 연결된다는 이유도 있습니다.이벤트 주도 프로그래밍은 이후 몇 장에서 설명할 겁니다."
}, 

{
"id": "-javascript-2020-04-11-javascript01",
"title": "Hello, World",
"author": null,
"tags": [],
"url": "/javascript/2020/04/11/javascript01/",
"date": "2020-04-11",
"content": "Hello, World프로그래밍 책은 대개 터미널에 “Hello, World” 를 출력하는 고전적인 예제로 시작합니다.이 예제는 벨 연구소에서 일하던 컴퓨터 과학자 브라이언 커니핸이 1972년 처음 사용 했고,책으로 인쇄된 건 1978년 출간된 C 언어 프로그래밍(제2판) (대영사, 2002) 이 처음입니다.최근 점점 복잡해지는 프로그래밍 환경에서 “Hello, World”는 구식이라고 생각할 수도 있겠지만,이 단순한 구절에 숨은 의미는 시간이 흘러도 퇴색되지 않습니다.이 구절은 당신이 신에게서 불을 훔쳐내 인간에게 선물한 프로메테우스가 될 수도,진흙 인형에 진정한 신의 이름을 새기던 랍비가 될 수도,자신의 피조물에 생명을 불어넣던 프랑켄슈타인 박사가 될 수도 있게 합니다.이것은 그런 위대한 창조와 신기원을 의미합니다.필자가 프로그래밍에 끌린 것도 이 구절의 울림 때문이었습니다.언젠가 훌륭한 프로그래머(당신일 수도 있겠죠)가 최초로 인공지능 생명체를 만들고,그 생명체가 처음으로 입을 열어 하는 말이 “Hello, World”일 수도 있습니다.1장에서는 브라이언 커니핸이 44년 전에 시작한 전통과 현재의 프로그래머가사용할 수 있는 최신 도구 사이에서 균형을 잡을 겁니다.쉽게 말해 화면에 “Hello, World”를 출력하는 건 마찬가지지만, 1972년의 프로그래머가 사용하던 고풍스러운 도구를 쓰지는 않을 겁니다."
}, 

{
"id": "-javascript-2020-04-11-javascript00",
"title": "컴퓨터적 사고방식 및 공부 마인드",
"author": null,
"tags": [],
"url": "/javascript/2020/04/11/javascript00/",
"date": "2020-04-11",
"content": "모든 걸 이해해야 한다는 강박관념에 빠지지 말자.공부할 때 흔히 하는 실수 같습니다.모든 것을 완벽하게 이해하고 넘어가려는 행동 말입니다.  물론 모든 것을 완벽하게 이해하고 넘어가는 것은 좋습니다. 이해할 수만 있다면 말입니다.  하지만 처음부터 모든 것을 완벽하게 소화해낼 순 없습니다.  무엇이든지 반복 학습이 중요합니다.해당 블로그 글을 끝까지 읽으신다면 자연스레 처음에 이해 안가던 부분이 이해가 되실 겁니다.컴퓨터적 사고방식프로그래밍 경험이 많지 않다면, 컴퓨터가 얼마나 곧이곧대로 행동하는지 깨닫게 되면서 절망에 빠질 일이 많을 겁니다.사람의 두뇌는 혼란스러운 일도 잘 처리할 수 있지만 컴퓨터는 이런 면에서는 빵점입니다.제가 이 글을 쓰면서 문법이 틀리더라도, 읽으시는 분들은 저의 작문 실력을 의심할지언정 제가 어떤 말을 하려는 지는 이해할 수 있을 겁니다. 하지만 자바스크립트는(모든 프로그래밍 언어가 그렇지만) 혼란스러운 코드를 이해하는 능력은 전혀 없습니다.  대소문자를 틀리건, 오타를 내건, 단어와 구두점의 순서가 조금 바뀌는 등의 작은 실수도 모두 에러 또는 예상치 못한 결과를 초래합니다.  문제가 생겼다면 글에 있는 코드를 전부 정확히 옮겨 썼는지 확인해 보십시오.  세미콜론과 콜론을 헷갈리면 안되고, 마침표를 쓸 자리에 쉼표를 써도 안됩니다.  큰 따옴표와 작은 따옴표를 뒤섞어도 안됩니다.  대소문자도 확인해야 합니다.경험이 쌓이면 어느 정도 자유롭게 써도 되는 부분과 한글자 한글자를 정확히 써야 하는 부분을 구별할 수 있게 되겠지만,일단 지금은 블로그에 있는 내용을 그대로 따라 해야 머리를 쥐어뜯을 일이 줄어들 겁니다."
}, 

{
"id": "-jekyll-2020-02-11-jekyll02",
"title": "Jekyll 설치 및 세팅",
"author": null,
"tags": [],
"url": "/jekyll/2020/02/11/jekyll02/",
"date": "2020-02-11",
"content": "Jekyll 설치 및 세팅하기gem install jekyll 명령어로 jekyll을 설치합니다.jekyll template 라는 검색어를 통해 마음에 드는 template을 다운받습니다.http://jekyllthemes.org/원하는 template를 다운받고 압축을 푼 후, gemfile을 제외한 나머지 파일을 모두 jekyll root 폴더로 복붙합니다.위 이미지는 다운받은 template의 gemfile 내용입니다.확인하면 필요 모듈이 적혀있습니다.해당 내용을 내 jekyll root 폴더에 있는 gemfile에 옮겨 적습니다.그리고 jekyll serve 란 명령어로 server를 작동시킵니다.그리고 localhost:4000 으로 접속합니다.그럼 위와 같은 template이 적용된 jekyll 블로그로 접속될 것입니다.admin 페이지로 접속하기 위해선gemfile 파일에 다음 문구를 추가합니다.gem 'jekyll-admin', group:jekyll_plugins그리고 jekyll serve 로 다시 서버를 실행시키고localhost:4000/admin 페이지로 접속합니다.그럼 이러한 admin 페이지로 접속이 가능해집니다."
}, 

{
"id": "-jekyll-2020-02-10-jekyll01",
"title": "Jekyll 사용환경 만들기",
"author": null,
"tags": [],
"url": "/jekyll/2020/02/10/jekyll01/",
"date": "2020-02-10",
"content": "Jekyll 사용환경 만들기1. Ruby 다운로드먼저 Ruby를 설치해 Jekyll 을 사용할 수 있는 환경을 만들어야합니다.https://rubyinstaller.org/위 사이트로 접속해 Ruby를 다운받으십시오.2. Ruby 설치UTF-8 엔코딩에 체크한 후설치를 진행합니다.그리고 Ruby가 제대로 설치되었는지 ruby -v 명령어를 통해 확인해봅니다.위는 git bash 창입니다. Ruby를 설치했어도 ruby -v 명령어가 ruby: command not found라는 오류가 발생하면서 실행이 안될 수도 있습니다.그럴 때는 git bash창 말고 cmd 창을 이용합니다.그러면 ruby -v 명령어를 제대로 인식할 수도 있습니다.cmd 창을 활용하는 경우는 해당 드라이브로 가는 명령어(드라이브이름:), 폴더 옮기는 명령어 cd (폴더명) 등을 이용해 Jekyll 모듈을 사용할 root 폴더로 직접 이동해야됩니다.위와 같이 ruby 설치와 ruby가 제대로 설치되었는지 확인 작업까지 마치면 Jekyll 사용환경이 완성된 겁니다."
}, 

{
"id": "-jekyll-2020-02-10-jekyll00",
"title": "Jekyll(지킬) 이란?",
"author": null,
"tags": [],
"url": "/jekyll/2020/02/10/jekyll00/",
"date": "2020-02-10",
"content": "Jekyll 이란?평범한 텍스트 파일을 정적 웹사이트 또는 블로그로 변신시켜 주는 모듈입니다.특징  심플함데이터베이스도 댓글 관리도, 성가신 업데이트도 없습니다. 오직 당신의 컨텐츠뿐입니다.  정적Markdown (또는 Textile), Liquid, HTML &amp; CSS 를 넣으면, 당장 게시할 수 있는 사이트가 완성됩니다.  블로그 지향적고유주소, 카테고리, 페이지, 포스트, 사용자 레이아웃 등의 기능이 기본적으로 포함되어 있습니다."
}

]
