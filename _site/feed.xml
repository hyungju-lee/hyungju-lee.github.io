<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-04-14T18:33:41+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">LHJ</title><subtitle>coding blog</subtitle><entry><title type="html">2.4 린트</title><link href="http://localhost:4000/javascript/2020/04/14/javascript24/" rel="alternate" type="text/html" title="2.4 린트" /><published>2020-04-14T18:24:00+09:00</published><updated>2020-04-14T18:24:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/14/javascript24</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/14/javascript24/">&lt;p&gt;인터뷰에 나가거나 파티에 참석할 때는 옷을 롤러로 문질러 &lt;strong&gt;보푸라기(lint)&lt;/strong&gt;를 제거하지 않습니까?&lt;br /&gt;
물론 그럴 테죠. 가능한 한 멋지게 보여야할 테니까요.&lt;br /&gt;
마찬가지로 코드를(그 코드를 만든 당신도) &lt;strong&gt;린트&lt;/strong&gt;해서 멋져 보이게 할 수 있습니다.&lt;br /&gt;
린트 프로그램은 당신의 코드를 세심히 검토해서 자주 일어나는 실수를 알려줍니다.&lt;br /&gt;
필자는 25년째 소프트웨어를 만들고 있지만,&lt;br /&gt;
아직도 실수를 저지르고 린트 프로그램이 찾아 준 다음에나 발견하곤 합니다.&lt;br /&gt;
&lt;strong&gt;초보자에게 린트 프로그램은 정말 비할 데 없이 중요한 도구입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;자바스크립트 린트 프로그램은 여러가지가 있지만, 필자는 그 중에서 니콜라스 자카스의 &lt;strong&gt;ESLint&lt;/strong&gt;를 추천하는 편입니다.&lt;br /&gt;
ESLint를 설치합시다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;npm intall &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; eslint
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">인터뷰에 나가거나 파티에 참석할 때는 옷을 롤러로 문질러 보푸라기(lint)를 제거하지 않습니까? 물론 그럴 테죠. 가능한 한 멋지게 보여야할 테니까요. 마찬가지로 코드를(그 코드를 만든 당신도) 린트해서 멋져 보이게 할 수 있습니다. 린트 프로그램은 당신의 코드를 세심히 검토해서 자주 일어나는 실수를 알려줍니다. 필자는 25년째 소프트웨어를 만들고 있지만, 아직도 실수를 저지르고 린트 프로그램이 찾아 준 다음에나 발견하곤 합니다. 초보자에게 린트 프로그램은 정말 비할 데 없이 중요한 도구입니다. 자바스크립트 린트 프로그램은 여러가지가 있지만, 필자는 그 중에서 니콜라스 자카스의 ESLint를 추천하는 편입니다. ESLint를 설치합시다. $ npm intall -g eslint</summary></entry><entry><title type="html">2.3.1 바벨을 걸프와 함께 사용하기</title><link href="http://localhost:4000/javascript/2020/04/14/javascript23/" rel="alternate" type="text/html" title="2.3.1 바벨을 걸프와 함께 사용하기" /><published>2020-04-14T01:14:00+09:00</published><updated>2020-04-14T01:14:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/14/javascript23</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/14/javascript23/">&lt;p&gt;이제 걸프가 유용한 일을 하게 할 수 있습니다.&lt;br /&gt;
우리가 작성할 ES6 코드를 ES5 코드로 바꾸는 일 말입니다.&lt;br /&gt;
es6와 public/es6에 있는 코드를 ES5 코드로 변환해서 dist와 public/dist에 저장할 겁니다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;npm install --save-dev gulp-babel&lt;/code&gt; 명령으로 &lt;strong&gt;gulp-babel&lt;/strong&gt; 패키지를 설치하고 &lt;strong&gt;gulpfile.js&lt;/strong&gt;를 다음과 같이 수정합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image17.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;parallel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;gulp&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;babel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;gulp-babel&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;node_babel&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;es6/**/*.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;babel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;dist&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;browser_babel&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;public/es6/**/*.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;babel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;public/dist&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;parallel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;node_babel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;browser_babel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;걸프는 &lt;strong&gt;파이프라인&lt;/strong&gt; 개념으로 작업을 처리합니다.&lt;br /&gt;
먼저 변환할 파일을(&lt;code class=&quot;highlighter-rouge&quot;&gt;src(&quot;es6/**/*.js&quot;)&lt;/code&gt;) 지정했습니다.&lt;br /&gt;
**는 “서브디렉터리를 포함해 모든 디렉터리”를 뜻하는 &lt;strong&gt;와일드카드&lt;/strong&gt;입니다.&lt;br /&gt;
따라서 이 소스 필터는 서브디렉터리 깊이에 관계없이 es6에 있는 모든 .js 파일을 선택합니다.&lt;br /&gt;
다음에는 이 소스 파일을 바벨에 &lt;strong&gt;파이프&lt;/strong&gt;로 연결합니다.&lt;br /&gt;
바벨은 ES6 코드를 ES5 코드로 변형합니다.&lt;br /&gt;
마지막 단계에서는 컴파일된 ES5 코드를 dist 디렉터리에 저장합니다.&lt;br /&gt;
&lt;strong&gt;걸프는 소스 파일 이름과 디렉터리 구조를 그대로 유지합니다.&lt;/strong&gt;&lt;br /&gt;
예를 들어 es6/a.js 파일은 dist/a.js 로 컴파일되고, es6/a/b/c.js 파일은 dist/a/b/c.js 로 컴파일되는 식입니다.&lt;br /&gt;
같은 과정을 public/es6 디렉터리의 파일에 대해서도 반복합니다.&lt;/p&gt;

&lt;p&gt;아직 ES6에 대해 배우지 않았지만, ES6 샘플 파일을 만들고 걸프 설정이 제대로 동작하는지 확인해 봅시다.&lt;br /&gt;
ES6의 새 기능을 사용하는 파일 es6/test.js을 만듭니다.&lt;br /&gt;
지금 이 파일을 이해할 수 없어도 상관없습니다.&lt;br /&gt;
이 책을 마칠 때쯤이면 이해할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;use strict&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// es6 기능 : 블록 스코프 변수 선언&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sentences&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;subject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;JavaScript&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;verb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;great&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;subject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Elephants&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;verb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;are&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;large&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// es6 기능 : 객체 분해&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;subject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;verb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// es6 기능 : 템플릿 문자열&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 아래 사용한 것은 따옴표가 아니라 백틱(`), 즉&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 키보드의 탭 키 바로 위에 있는 문자입니다.&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;subject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;verb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// es6 기능 : for..of&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sentences&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 이 파일을 public/es6에 복사합니다.&lt;br /&gt;
파일을 바꿔보고 싶다면 sentences 배열의 단어는 바꿔도 됩니다.&lt;br /&gt;
이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;gulp&lt;/code&gt; 명령을 내립니다.&lt;br /&gt;
작업이 끝나면 dist와 public/dist 디렉터리를 보십시오.&lt;br /&gt;
두 디렉터리에 모두 test.js 파일이 있을 겁니다.&lt;br /&gt;
파일을 열어서 ES6 파일과 다른 것을 확인하십시오.&lt;/p&gt;

&lt;p&gt;아래는 위의 ES6가 ES5로 컴파일된 모습입니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;use strict&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// es6 기능 : 블록 스코프 변수 선언&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sentences&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;subject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;JavaScript&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;verb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;is&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;great&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;subject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Elephants&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;verb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;are&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;large&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// es6 기능 : 객체 분해&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;subject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;subject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;verb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;verb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// es6 기능 : 템플릿 문자열&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 아래 사용한 것은 따옴표가 아니라 백틱(`), 즉&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 키보드의 탭 키 바로 위에 있는 문자입니다.&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;concat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;subject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;concat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;verb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; &lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;concat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// es6 기능 : for..of&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_sentences&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sentences&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_sentences&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_sentences&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 ES6 코드를 바로 실행해 봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image18.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;현재 책과 다른 모습을 볼 수 있습니다.&lt;br /&gt;
&lt;strong&gt;노드는 ES6 기능 지원을 점점 더 늘리고 있으니, 여러분이 이 책을 읽는 시점에 따라서는 완벽히 실행될 수도 있습니다.&lt;/strong&gt;&lt;br /&gt;
이제 ES5 코드를 실행합시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image19.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ES6 코드를 어디서든 사용할 수 있는 ES5 코드로 바꾸는 데 성공했습니다.&lt;br /&gt;
마지막으로, dist와 public/dist 디렉터리를 .gitignore 파일에 추가하십시오.&lt;br /&gt;
우리는 ES6 소스만 추적하고, 자동으로 생성되는 ES5 파일은 추적하지 않습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-gitignore&quot;&gt;# npm 디버그 기록
npm-debug.log*

# 프로젝트 의존성
node_modules

# macOS 폴더 속성
.DS_Store

# 임시 파일
*.tmp
*~

# 결과물
dist
public/dist
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><summary type="html">이제 걸프가 유용한 일을 하게 할 수 있습니다. 우리가 작성할 ES6 코드를 ES5 코드로 바꾸는 일 말입니다. es6와 public/es6에 있는 코드를 ES5 코드로 변환해서 dist와 public/dist에 저장할 겁니다. npm install --save-dev gulp-babel 명령으로 gulp-babel 패키지를 설치하고 gulpfile.js를 다음과 같이 수정합니다. const {src, dest, parallel} = require('gulp'); const babel = require('gulp-babel'); function node_babel () { return src(&quot;es6/**/*.js&quot;) .pipe(babel()) .pipe(dest(&quot;dist&quot;)); } function browser_babel () { return src(&quot;public/es6/**/*.js&quot;) .pipe(babel()) .pipe(dest(&quot;public/dist&quot;)) } exports.default = parallel(node_babel, browser_babel); 걸프는 파이프라인 개념으로 작업을 처리합니다. 먼저 변환할 파일을(src(&quot;es6/**/*.js&quot;)) 지정했습니다. **는 “서브디렉터리를 포함해 모든 디렉터리”를 뜻하는 와일드카드입니다. 따라서 이 소스 필터는 서브디렉터리 깊이에 관계없이 es6에 있는 모든 .js 파일을 선택합니다. 다음에는 이 소스 파일을 바벨에 파이프로 연결합니다. 바벨은 ES6 코드를 ES5 코드로 변형합니다. 마지막 단계에서는 컴파일된 ES5 코드를 dist 디렉터리에 저장합니다. 걸프는 소스 파일 이름과 디렉터리 구조를 그대로 유지합니다. 예를 들어 es6/a.js 파일은 dist/a.js 로 컴파일되고, es6/a/b/c.js 파일은 dist/a/b/c.js 로 컴파일되는 식입니다. 같은 과정을 public/es6 디렉터리의 파일에 대해서도 반복합니다. 아직 ES6에 대해 배우지 않았지만, ES6 샘플 파일을 만들고 걸프 설정이 제대로 동작하는지 확인해 봅시다. ES6의 새 기능을 사용하는 파일 es6/test.js을 만듭니다. 지금 이 파일을 이해할 수 없어도 상관없습니다. 이 책을 마칠 때쯤이면 이해할 수 있습니다. 'use strict'; // es6 기능 : 블록 스코프 변수 선언 const sentences = [ {subject: 'JavaScript', verb: 'is', object: 'great'}, {subject: 'Elephants', verb: 'are', object: 'large'}, ]; // es6 기능 : 객체 분해 function say({subject, verb, object}) { // es6 기능 : 템플릿 문자열 // 아래 사용한 것은 따옴표가 아니라 백틱(`), 즉 // 키보드의 탭 키 바로 위에 있는 문자입니다. console.log(`${subject} ${verb} ${object}`); } // es6 기능 : for..of for (let s of sentences) { say(s); } 그리고 이 파일을 public/es6에 복사합니다. 파일을 바꿔보고 싶다면 sentences 배열의 단어는 바꿔도 됩니다. 이제 gulp 명령을 내립니다. 작업이 끝나면 dist와 public/dist 디렉터리를 보십시오. 두 디렉터리에 모두 test.js 파일이 있을 겁니다. 파일을 열어서 ES6 파일과 다른 것을 확인하십시오. 아래는 위의 ES6가 ES5로 컴파일된 모습입니다. 'use strict'; // es6 기능 : 블록 스코프 변수 선언 var sentences = [{ subject: 'JavaScript', verb: 'is', object: 'great' }, { subject: 'Elephants', verb: 'are', object: 'large' }]; // es6 기능 : 객체 분해 function say(_ref) { var subject = _ref.subject, verb = _ref.verb, object = _ref.object; // es6 기능 : 템플릿 문자열 // 아래 사용한 것은 따옴표가 아니라 백틱(`), 즉 // 키보드의 탭 키 바로 위에 있는 문자입니다. console.log(&quot;&quot;.concat(subject, &quot; &quot;).concat(verb, &quot; &quot;).concat(object)); } // es6 기능 : for..of for (var _i = 0, _sentences = sentences; _i &amp;lt; _sentences.length; _i++) { var s = _sentences[_i]; say(s); } 이제 ES6 코드를 바로 실행해 봅시다. 현재 책과 다른 모습을 볼 수 있습니다. 노드는 ES6 기능 지원을 점점 더 늘리고 있으니, 여러분이 이 책을 읽는 시점에 따라서는 완벽히 실행될 수도 있습니다. 이제 ES5 코드를 실행합시다. ES6 코드를 어디서든 사용할 수 있는 ES5 코드로 바꾸는 데 성공했습니다. 마지막으로, dist와 public/dist 디렉터리를 .gitignore 파일에 추가하십시오. 우리는 ES6 소스만 추적하고, 자동으로 생성되는 ES5 파일은 추적하지 않습니다. # npm 디버그 기록 npm-debug.log* # 프로젝트 의존성 node_modules # macOS 폴더 속성 .DS_Store # 임시 파일 *.tmp *~ # 결과물 dist public/dist</summary></entry><entry><title type="html">2.3 트랜스컴파일러</title><link href="http://localhost:4000/javascript/2020/04/14/javascript22/" rel="alternate" type="text/html" title="2.3 트랜스컴파일러" /><published>2020-04-14T00:04:00+09:00</published><updated>2020-04-14T00:04:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/14/javascript22</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/14/javascript22/">&lt;p&gt;이 책을 쓰는 시점에서 가장 널리 쓰이는 트랜스컴파일러는 &lt;a href=&quot;https://babeljs.io/&quot;&gt;바벨&lt;/a&gt;과 &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;트레이서&lt;/a&gt;입니다.&lt;br /&gt;
필자는 두 트랜스컴파일러를 모두 사용해 봤는데, 둘 다 기능이 충실하고 사용하기 쉬웠습니다.&lt;br /&gt;
이 책에서는 트랜스컴파일러로 &lt;strong&gt;바벨&lt;/strong&gt;을 사용합니다.&lt;br /&gt;
이제 시작합시다.&lt;/p&gt;

&lt;p&gt;바벨은 ES5를 ES6로 바꾸는 트랜스컴파일러로 시작했고, 프로젝트가 성장하면서 ES6와 리액트(React), ES7 등 여러 가지를 지원하는 범용 트랜스컴파일러가 됐습니다.&lt;br /&gt;
&lt;strong&gt;바벨 버전 6부터는 ES5를 ES6로 변환하려면 ES6 변환 프리셋을 설치하고 바벨이 해당 프리셋을 사용하게끔 설정해야 합니다.&lt;/strong&gt;&lt;br /&gt;
어떤 프로젝트에서는 ES6를, 어떤 프로젝트에서는 리액트를 쓰게 될 수도 있으므로 이번 설정은 이 프로젝트에만 적용되게 만들 겁니다.&lt;br /&gt;
먼저 ES6 프리셋, 코어, 레지스터를 설치합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i &lt;span class=&quot;nt&quot;&gt;-D&lt;/span&gt; @babel/register @babel/core @babel/preset-env
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로젝트 루트에 &lt;strong&gt;.babelrc&lt;/strong&gt; 파일을 만듭니다.(파일 이름 없이 확장자만 쓰면 숨긴 파일이 됩니다.)&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;touch&lt;/span&gt; .babelrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image16.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 파일의 내용은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;presets&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;@babel/preset-env&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 파일이 있으면 프로젝트에서 바벨을 사용할 때 ES6를 사용한다는 것을 인식하게 됩니다.&lt;br /&gt;
&lt;strong&gt;(babel-preset-env는 babel-preset-latest (또는 babel-preset-es2015, babel-preset-es2016 및 babel-preset-es2017과 동일)와 정확히 동일하게 작동합니다.)&lt;/strong&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">이 책을 쓰는 시점에서 가장 널리 쓰이는 트랜스컴파일러는 바벨과 트레이서입니다. 필자는 두 트랜스컴파일러를 모두 사용해 봤는데, 둘 다 기능이 충실하고 사용하기 쉬웠습니다. 이 책에서는 트랜스컴파일러로 바벨을 사용합니다. 이제 시작합시다. 바벨은 ES5를 ES6로 바꾸는 트랜스컴파일러로 시작했고, 프로젝트가 성장하면서 ES6와 리액트(React), ES7 등 여러 가지를 지원하는 범용 트랜스컴파일러가 됐습니다. 바벨 버전 6부터는 ES5를 ES6로 변환하려면 ES6 변환 프리셋을 설치하고 바벨이 해당 프리셋을 사용하게끔 설정해야 합니다. 어떤 프로젝트에서는 ES6를, 어떤 프로젝트에서는 리액트를 쓰게 될 수도 있으므로 이번 설정은 이 프로젝트에만 적용되게 만들 겁니다. 먼저 ES6 프리셋, 코어, 레지스터를 설치합니다. npm i -D @babel/register @babel/core @babel/preset-env 프로젝트 루트에 .babelrc 파일을 만듭니다.(파일 이름 없이 확장자만 쓰면 숨긴 파일이 됩니다.) touch .babelrc 이 파일의 내용은 다음과 같습니다. { &quot;presets&quot;: [ &quot;@babel/preset-env&quot; ] } 이 파일이 있으면 프로젝트에서 바벨을 사용할 때 ES6를 사용한다는 것을 인식하게 됩니다. (babel-preset-env는 babel-preset-latest (또는 babel-preset-es2015, babel-preset-es2016 및 babel-preset-es2017과 동일)와 정확히 동일하게 작동합니다.)</summary></entry><entry><title type="html">2.2.7 프로젝트 구조</title><link href="http://localhost:4000/javascript/2020/04/13/javascript21/" rel="alternate" type="text/html" title="2.2.7 프로젝트 구조" /><published>2020-04-13T23:27:00+09:00</published><updated>2020-04-13T23:27:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/13/javascript21</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/13/javascript21/">&lt;p&gt;걸프와 바벨을 써서 ES6 코드를 ES5 코드로 바꾸기 전에 코드를 어디에 저장할지 생각해야 합니다.&lt;br /&gt;
자바스크립트 개발에서 프로젝트 레이아웃을 어떻게 구성하는지 정한 국제 표준 같은 건 없습니다.&lt;br /&gt;
표준을 정하기엔 생태계가 너무 다양합니다.&lt;br /&gt;
소스 코드를 &lt;strong&gt;src&lt;/strong&gt;나 &lt;strong&gt;js&lt;/strong&gt; 디렉터리에 저장하는 경우가 매우 많습니다.&lt;br /&gt;
우리는 소스 코드를 &lt;strong&gt;es6&lt;/strong&gt; 디렉터리에 저장할 겁니다.&lt;br /&gt;
이렇게 하면 소스 코드를 ES6 코드로 만들었음을 명확히 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;서버 쪽(노드) 코드와 클라이언트 쪽(브라우저) 코드를 모두 포함하는 프로젝트가 많으므로 우리 코드도 양쪽 카테고리를 모두 만듭니다.&lt;br /&gt;
서버쪽 코드는 프로젝트 루트의 &lt;strong&gt;es6&lt;/strong&gt; 디렉터리에 저장합니다.&lt;br /&gt;
브라우저 코드는 &lt;strong&gt;public/es6&lt;/strong&gt; 디렉터리에 저장합니다.&lt;br /&gt;
브라우저에 보내는 자바스크립트는 원래 공개된(public) 것이고, 이런 식으로 저장하는 프로젝트가 아주 많습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;다음 섹션에서는 ES6 코드를 ES5 코드로 변환합니다.&lt;/strong&gt;&lt;br /&gt;
ES6 코드와 ES5 코드를 섞어 놓을 수는 없으므로 ES5 코드를 저장할 장소가 필요합니다.&lt;br /&gt;
이런 코드는 &lt;strong&gt;distribution의 약자인 dist&lt;/strong&gt; 디렉터리에 저장하는 경우가 많습니다.&lt;/p&gt;

&lt;p&gt;준비가 끝나면 프로젝트 루트는 다음과 같은 모양이 될 겁니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image15.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">걸프와 바벨을 써서 ES6 코드를 ES5 코드로 바꾸기 전에 코드를 어디에 저장할지 생각해야 합니다. 자바스크립트 개발에서 프로젝트 레이아웃을 어떻게 구성하는지 정한 국제 표준 같은 건 없습니다. 표준을 정하기엔 생태계가 너무 다양합니다. 소스 코드를 src나 js 디렉터리에 저장하는 경우가 매우 많습니다. 우리는 소스 코드를 es6 디렉터리에 저장할 겁니다. 이렇게 하면 소스 코드를 ES6 코드로 만들었음을 명확히 알 수 있습니다. 서버 쪽(노드) 코드와 클라이언트 쪽(브라우저) 코드를 모두 포함하는 프로젝트가 많으므로 우리 코드도 양쪽 카테고리를 모두 만듭니다. 서버쪽 코드는 프로젝트 루트의 es6 디렉터리에 저장합니다. 브라우저 코드는 public/es6 디렉터리에 저장합니다. 브라우저에 보내는 자바스크립트는 원래 공개된(public) 것이고, 이런 식으로 저장하는 프로젝트가 아주 많습니다. 다음 섹션에서는 ES6 코드를 ES5 코드로 변환합니다. ES6 코드와 ES5 코드를 섞어 놓을 수는 없으므로 ES5 코드를 저장할 장소가 필요합니다. 이런 코드는 distribution의 약자인 dist 디렉터리에 저장하는 경우가 많습니다. 준비가 끝나면 프로젝트 루트는 다음과 같은 모양이 될 겁니다.</summary></entry><entry><title type="html">2.2.6 빌드 도구 : 걸프와 그런트</title><link href="http://localhost:4000/javascript/2020/04/13/javascript20/" rel="alternate" type="text/html" title="2.2.6 빌드 도구 : 걸프와 그런트" /><published>2020-04-13T23:09:00+09:00</published><updated>2020-04-13T23:09:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/13/javascript20</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/13/javascript20/">&lt;p&gt;개발 과정에서 피할 수 없는 반복 작업을 자동화하는 빌드 도구가 필요합니다.&lt;br /&gt;
현재 자바스크립트에서 가장 널리 쓰이는 빌드 도구는 &lt;a href=&quot;http://gruntjs.com/&quot;&gt;그런트(Grunt)&lt;/a&gt;와 &lt;a href=&quot;http://gulpjs.com/&quot;&gt;걸프(Gulp)&lt;/a&gt;입니다.&lt;br /&gt;
이 둘은 모두 훌륭한 빌드 시스템입니다.&lt;br /&gt;
그런트는 걸프보다 몇 해 먼저 등장했기에 커뮤니티도 더 크지만, 걸프는 그 차이를 빠르게 좁히고 있습니다.&lt;br /&gt;
자바스크립트 개발을 시작하는 프로그래머들이 걸프를 선택하는 경우가 점점 더 늘어나고 있으므로 이 책에서는 걸프를 사용합니다.&lt;br /&gt;
물론 어느 쪽이 더 낫다고 말하는 것은 아닙니다.&lt;/p&gt;

&lt;p&gt;먼저 걸프를 전역으로 설치합시다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;npm intall &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; gulp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;CAUTION_&lt;/strong&gt; 리눅스나 macOS를 사용한다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;-g&lt;/code&gt;(전역) npm에서 플래그를 사용하기 위해 &lt;strong&gt;관리자 권한&lt;/strong&gt;이 필요할 수도 있습니다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo npm intall -g gulp&lt;/code&gt; 명령을 내리면, 슈퍼유저 비밀번호를 묻는 프롬프트가 나타나고 이 명령어에 한해서 슈퍼유저 권한을 받게 됩니다.&lt;br /&gt;
다른 사람이 관리하는 시스템을 사용한다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudoers&lt;/code&gt; 파일에 여러분을 추가해 달라고 요청할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;걸프를 전역으로 설치하는 것은 개발에 사용할 컴퓨터에 한 번만 하면 됩니다.&lt;br /&gt;
그리고 프로젝트마다 로컬 걸프가 필요하므로, 프로젝트 루트에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm i -D gulp&lt;/code&gt; 명령을 실행합니다.&lt;br /&gt;
걸프는 최종 사용자에게는 필요 없지만, 개발 과정에서 도움이 되는 &lt;strong&gt;개발 의존성&lt;/strong&gt;에 속합니다.&lt;br /&gt;
걸프가 없어도 앱은 잘 동작하지만, 개발할 때 걸프가 있으면 작업이 편해집니다.&lt;br /&gt;
걸프가 설치되면 다음과 같이 &lt;strong&gt;gulpfile.js&lt;/strong&gt;를 만듭니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;gulp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;gulp&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 걸프 의존성을 여기 씁니다.&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;first_function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 걸프 작업을 여기 씁니다.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;걸프실행&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;first_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아직 걸프가 할 일을 지정하지는 않았지만, 성공적으로 설치됐는지 확인하는 건 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image14.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;CAUTION_&lt;/strong&gt; 윈도우 사용자라면 “The build tools for Visual Studio 2010 (Platform Toolset = v100) cannot be found.” 라는 에러가 표시될 수 있습니다.&lt;br /&gt;
npm 패키지 중 상당수가 비쥬얼 스튜디오의 빌드 도구가 있어야 동작합니다.&lt;br /&gt;
&lt;a href=&quot;https://www.visualstudio.com/en-us/visual-studio-homepage-vs.aspx&quot;&gt;비쥬얼 스튜디오 다운로드 페이지&lt;/a&gt;에서 무료 버전을 내려받을 수 있습니다.&lt;br /&gt;
비쥬얼 스튜디오 설치가 끝나면 시작 메뉴에서 “VS2015용 MSBuild 명령 프롬프트”를 찾아보십시오.&lt;br /&gt;
이 명령어 프롬프트에서 프로젝트 루트로 이동하고 걸프를 다시 설치해 보면 잘 실행될 겁니다.&lt;br /&gt;
비쥬얼 스튜디오의 명령어 프롬프트를 계속 사용할 필요는 없지만,  비쥬얼 스튜디오에 의존하는 npm 모듈을 설치할 때는 이 프롬프트를 사용하는 것이 가장 쉬운 방법입니다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">개발 과정에서 피할 수 없는 반복 작업을 자동화하는 빌드 도구가 필요합니다. 현재 자바스크립트에서 가장 널리 쓰이는 빌드 도구는 그런트(Grunt)와 걸프(Gulp)입니다. 이 둘은 모두 훌륭한 빌드 시스템입니다. 그런트는 걸프보다 몇 해 먼저 등장했기에 커뮤니티도 더 크지만, 걸프는 그 차이를 빠르게 좁히고 있습니다. 자바스크립트 개발을 시작하는 프로그래머들이 걸프를 선택하는 경우가 점점 더 늘어나고 있으므로 이 책에서는 걸프를 사용합니다. 물론 어느 쪽이 더 낫다고 말하는 것은 아닙니다. 먼저 걸프를 전역으로 설치합시다. $ npm intall -g gulp CAUTION_ 리눅스나 macOS를 사용한다면 -g(전역) npm에서 플래그를 사용하기 위해 관리자 권한이 필요할 수도 있습니다. sudo npm intall -g gulp 명령을 내리면, 슈퍼유저 비밀번호를 묻는 프롬프트가 나타나고 이 명령어에 한해서 슈퍼유저 권한을 받게 됩니다. 다른 사람이 관리하는 시스템을 사용한다면 sudoers 파일에 여러분을 추가해 달라고 요청할 수 있습니다. 걸프를 전역으로 설치하는 것은 개발에 사용할 컴퓨터에 한 번만 하면 됩니다. 그리고 프로젝트마다 로컬 걸프가 필요하므로, 프로젝트 루트에서 npm i -D gulp 명령을 실행합니다. 걸프는 최종 사용자에게는 필요 없지만, 개발 과정에서 도움이 되는 개발 의존성에 속합니다. 걸프가 없어도 앱은 잘 동작하지만, 개발할 때 걸프가 있으면 작업이 편해집니다. 걸프가 설치되면 다음과 같이 gulpfile.js를 만듭니다. const gulp = require('gulp'); // 걸프 의존성을 여기 씁니다. function first_function () { // 걸프 작업을 여기 씁니다. return console.log('걸프실행'); } exports.default = first_function; 아직 걸프가 할 일을 지정하지는 않았지만, 성공적으로 설치됐는지 확인하는 건 가능합니다. CAUTION_ 윈도우 사용자라면 “The build tools for Visual Studio 2010 (Platform Toolset = v100) cannot be found.” 라는 에러가 표시될 수 있습니다. npm 패키지 중 상당수가 비쥬얼 스튜디오의 빌드 도구가 있어야 동작합니다. 비쥬얼 스튜디오 다운로드 페이지에서 무료 버전을 내려받을 수 있습니다. 비쥬얼 스튜디오 설치가 끝나면 시작 메뉴에서 “VS2015용 MSBuild 명령 프롬프트”를 찾아보십시오. 이 명령어 프롬프트에서 프로젝트 루트로 이동하고 걸프를 다시 설치해 보면 잘 실행될 겁니다. 비쥬얼 스튜디오의 명령어 프롬프트를 계속 사용할 필요는 없지만, 비쥬얼 스튜디오에 의존하는 npm 모듈을 설치할 때는 이 프롬프트를 사용하는 것이 가장 쉬운 방법입니다.</summary></entry><entry><title type="html">2.2.5 npm 패키지 관리</title><link href="http://localhost:4000/javascript/2020/04/13/javascript19/" rel="alternate" type="text/html" title="2.2.5 npm 패키지 관리" /><published>2020-04-13T21:57:34+09:00</published><updated>2020-04-13T21:57:34+09:00</updated><id>http://localhost:4000/javascript/2020/04/13/javascript19</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/13/javascript19/">&lt;p&gt;꼭 npm을 알아야만 자바스크립트 개발이 가능한 건 아니지만,&lt;br /&gt;
패키지 관리 도구로 npm을 사용하는 사람이 점점 늘어나고 있습니다.&lt;br /&gt;
노드 개발에서는 npm이 필수라고 해도 과언이 아닙니다.&lt;br /&gt;
실제로 노드 앱을 개발하든, 아니면 브라우저 앱만 개발하든, npm을 사용하면 일이 훨씬 쉬워집니다.&lt;br /&gt;
여기서는 npm을 통해 빌드 도구와 &lt;strong&gt;트랜스컴파일러&lt;/strong&gt;를 설치하겠습니다.&lt;/p&gt;

&lt;p&gt;npm은 노드를 설치할 때 함께 설치됩니다.&lt;br /&gt;
따라서 아직 노드를 설치하지 않았따면 노드.js 홈페이지(&lt;a href=&quot;https://nodejs.org/&quot;&gt;https://nodejs.org/&lt;/a&gt;)에 가서 녹색 INSTALL 버튼을 클릭하십시오.&lt;br /&gt;
이때 안정 버전과 최신 버전을 선택해 내려받을 수 있는데, 필자는 안정 버전을 설치하길 권합니다.&lt;br /&gt;
설치가 끝나면 노드와 npm이 잘 동작하는지 다음 명령으로 확인하십시오.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;node &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;npm &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;노드와 npm은 계속 업데이트되므로 버전 번호는 다 다를 수 있습니다.&lt;br /&gt;
&lt;strong&gt;npm의 목적은 간단히 말해 설치된 패키지 관리입니다.&lt;/strong&gt;&lt;br /&gt;
‘패키지’는 완전한 애플리케이션일 수도 있고, 코드 샘플일 수도 있고, 프로젝트에서 사용할 모듈 또는 라이브러리일 수도 있습니다.&lt;/p&gt;

&lt;p&gt;npm은 패키지를 설치할 때 전역으로(globally), 또는 로컬로(locally) 설치할 수 있습니다.&lt;br /&gt;
전역으로 설치하는 패키지는 보통 개발 과정에서 사용하는, 터미널에서 실행하는 도구들입니다.&lt;br /&gt;
로컬 패키지는 각 프로젝트에 종속되는 패키지입니다.&lt;br /&gt;
패키지를 설치할 때는 &lt;strong&gt;npm install&lt;/strong&gt; 명령어를 사용합니다.&lt;br /&gt;
인기 있는 페키지 &lt;strong&gt;언더스코어(underscore)&lt;/strong&gt; 를 설치하면서 어떻게 동작하는지 알아봅시다.&lt;/p&gt;

&lt;p&gt;프로젝트 루트에서 다음 명령을 실행하십시오.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;npm &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;underscore
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image09.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;언더스코어 최신 버전을 설치했다는 메시지가 보입니다.&lt;br /&gt;
&lt;strong&gt;위에 경고 메시지는 package.json 파일이 없다는 경고입니다.&lt;br /&gt;
없어도 경고문구만 뜨지 딱히 오류는 안 생깁니다.&lt;br /&gt;
노드 예전 버전에선 경고문구가 안뜨지만 최신버전에서는 뜹니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;버전 번호는 다르게 표시될 수 있습니다.&lt;br /&gt;
&lt;strong&gt;언더스코어는 의존성이 없는 모듈이므로 npm의 출력 결과도 간단합니다.&lt;/strong&gt;&lt;br /&gt;
복잡한 모듈이라면 출력 결과가 한 페이지를 넘을 때도 있습니다.&lt;br /&gt;
특정 버전을 설치하고 싶다면 다음과 같이 버전 번호를 명시적으로 지정해도 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;npm &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;underscore@1.8.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러면 이 모듈이 실제 설치된 위치는 어디일까요?&lt;br /&gt;
프로젝트 루트를 보면 새 서브디렉터리 &lt;strong&gt;node_modules&lt;/strong&gt;가 생겼습니다.&lt;br /&gt;
로컬 모듈은 이 디렉터리에 설치됩니다.&lt;br /&gt;
일단 &lt;strong&gt;node_modules&lt;/strong&gt; 디렉터리를 삭제하십시오.&lt;br /&gt;
이 디렉터리는 곧 다시 만들겁니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image10.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;설치하는 모듈이 늘어나면 모듈을 추적하고 관리할 방법이 필요해집니다.&lt;br /&gt;
프로젝트에 설치하고 사용하는 모듈을 &lt;strong&gt;의존성(dependency)&lt;/strong&gt; 이라 부릅니다.&lt;br /&gt;
프로젝트가 성장하면서 늘어날 필요 패키지를 간결하게 정리할 방법이 있으면 좋을 겁니다.&lt;br /&gt;
npm은 &lt;strong&gt;package.json&lt;/strong&gt; 파일을 통해 의존성을 관리합니다.&lt;br /&gt;
&lt;strong&gt;package.json&lt;/strong&gt;을 직접 만들 필요는 없습니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;npm init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;명령을 내리고 몇 가지 질문에 답하면 됩니다.&lt;br /&gt;
그냥 모든 질문에 엔터를 눌러서 기본값을 사용하고 나중에 파일을 수정해도 됩니다.&lt;br /&gt;
지금 바로 &lt;strong&gt;npm init&lt;/strong&gt; 명령을 내리고, &lt;strong&gt;package.json&lt;/strong&gt; 파일을 열어 보십시오.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image11.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;의존성은 &lt;strong&gt;일반 의존성&lt;/strong&gt;과 &lt;strong&gt;개발 의존성&lt;/strong&gt;으로 나뉩니다.&lt;br /&gt;
개발 의존성은 앱을 실행할 때는 필요 없지만, 프로젝트를 개발할 때 필요하거나 도움이 되는 패키지를 말합니다.&lt;br /&gt;
곧 예제를 볼 겁니다.&lt;br /&gt;
지금부터는 로컬 패키지를 설치할 때 –save(또는 -S 또는 미입력) 또는 –save-dev(또는 -D) 플래그를 사용합니다.&lt;br /&gt;
이 플래그를 쓰지 않아도 패키지가 설치되긴 하지만, &lt;strong&gt;package.json&lt;/strong&gt; 파일에는 등록되지 않습니다.&lt;br /&gt;
&lt;strong&gt;(노드 최신버전은 플래그를 입력하지 않아도 자동으로 package.json 파일에 등록됩니다.)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;–save 플래그를 써서 언더스코어를 다시 설치해 봅시다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--save&lt;/span&gt; underscore
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image12.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 경고 문구는 패키지 구성 요소가 빠져있다는 경고입니다.&lt;br /&gt;
이 책을 공부할 때는 이 경고를 무시해도 됩니다.&lt;br /&gt;
npm을 통해 패키지를 배포하려 한다면 이 경고에 신경을 써야 하지만,&lt;br /&gt;
이 책에서는 배포에 관해 설명하지 않습니다.&lt;/p&gt;

&lt;p&gt;이제 &lt;strong&gt;package.json&lt;/strong&gt; 파일을 보면 &lt;strong&gt;의존성 리스트&lt;/strong&gt;에 언더스코어가 있습니다.&lt;br /&gt;
의존성 관리가 가능한 것은, &lt;strong&gt;package.json&lt;/strong&gt; 파일에서 패키지 이름과 버전 번호를 읽고 필요 패키지를 다시 내려받아 설치할 수 있기 때문입니다.&lt;br /&gt;
지금 해봅시다.&lt;br /&gt;
&lt;strong&gt;node_modules&lt;/strong&gt; 디렉터리를 다시 삭제하고, &lt;strong&gt;npm install&lt;/strong&gt; 명령을 내립니다.&lt;br /&gt;
네, 패키지 이름을 쓰지 않는 것이 맞습니다.&lt;br /&gt;
npm은 &lt;strong&gt;package.json&lt;/strong&gt; 파일을 읽고 필요한 패키지를 자동으로 설치합니다.&lt;br /&gt;
새로 만들어진 &lt;strong&gt;node_modules&lt;/strong&gt; 디렉터리를 보면 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image13.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">꼭 npm을 알아야만 자바스크립트 개발이 가능한 건 아니지만, 패키지 관리 도구로 npm을 사용하는 사람이 점점 늘어나고 있습니다. 노드 개발에서는 npm이 필수라고 해도 과언이 아닙니다. 실제로 노드 앱을 개발하든, 아니면 브라우저 앱만 개발하든, npm을 사용하면 일이 훨씬 쉬워집니다. 여기서는 npm을 통해 빌드 도구와 트랜스컴파일러를 설치하겠습니다. npm은 노드를 설치할 때 함께 설치됩니다. 따라서 아직 노드를 설치하지 않았따면 노드.js 홈페이지(https://nodejs.org/)에 가서 녹색 INSTALL 버튼을 클릭하십시오. 이때 안정 버전과 최신 버전을 선택해 내려받을 수 있는데, 필자는 안정 버전을 설치하길 권합니다. 설치가 끝나면 노드와 npm이 잘 동작하는지 다음 명령으로 확인하십시오. $ node -v $ npm -v 노드와 npm은 계속 업데이트되므로 버전 번호는 다 다를 수 있습니다. npm의 목적은 간단히 말해 설치된 패키지 관리입니다. ‘패키지’는 완전한 애플리케이션일 수도 있고, 코드 샘플일 수도 있고, 프로젝트에서 사용할 모듈 또는 라이브러리일 수도 있습니다. npm은 패키지를 설치할 때 전역으로(globally), 또는 로컬로(locally) 설치할 수 있습니다. 전역으로 설치하는 패키지는 보통 개발 과정에서 사용하는, 터미널에서 실행하는 도구들입니다. 로컬 패키지는 각 프로젝트에 종속되는 패키지입니다. 패키지를 설치할 때는 npm install 명령어를 사용합니다. 인기 있는 페키지 언더스코어(underscore) 를 설치하면서 어떻게 동작하는지 알아봅시다. 프로젝트 루트에서 다음 명령을 실행하십시오. $ npm install underscore 언더스코어 최신 버전을 설치했다는 메시지가 보입니다. 위에 경고 메시지는 package.json 파일이 없다는 경고입니다. 없어도 경고문구만 뜨지 딱히 오류는 안 생깁니다. 노드 예전 버전에선 경고문구가 안뜨지만 최신버전에서는 뜹니다. 버전 번호는 다르게 표시될 수 있습니다. 언더스코어는 의존성이 없는 모듈이므로 npm의 출력 결과도 간단합니다. 복잡한 모듈이라면 출력 결과가 한 페이지를 넘을 때도 있습니다. 특정 버전을 설치하고 싶다면 다음과 같이 버전 번호를 명시적으로 지정해도 됩니다. $ npm install underscore@1.8.0 그러면 이 모듈이 실제 설치된 위치는 어디일까요? 프로젝트 루트를 보면 새 서브디렉터리 node_modules가 생겼습니다. 로컬 모듈은 이 디렉터리에 설치됩니다. 일단 node_modules 디렉터리를 삭제하십시오. 이 디렉터리는 곧 다시 만들겁니다. 설치하는 모듈이 늘어나면 모듈을 추적하고 관리할 방법이 필요해집니다. 프로젝트에 설치하고 사용하는 모듈을 의존성(dependency) 이라 부릅니다. 프로젝트가 성장하면서 늘어날 필요 패키지를 간결하게 정리할 방법이 있으면 좋을 겁니다. npm은 package.json 파일을 통해 의존성을 관리합니다. package.json을 직접 만들 필요는 없습니다. $ npm init 명령을 내리고 몇 가지 질문에 답하면 됩니다. 그냥 모든 질문에 엔터를 눌러서 기본값을 사용하고 나중에 파일을 수정해도 됩니다. 지금 바로 npm init 명령을 내리고, package.json 파일을 열어 보십시오. 의존성은 일반 의존성과 개발 의존성으로 나뉩니다. 개발 의존성은 앱을 실행할 때는 필요 없지만, 프로젝트를 개발할 때 필요하거나 도움이 되는 패키지를 말합니다. 곧 예제를 볼 겁니다. 지금부터는 로컬 패키지를 설치할 때 –save(또는 -S 또는 미입력) 또는 –save-dev(또는 -D) 플래그를 사용합니다. 이 플래그를 쓰지 않아도 패키지가 설치되긴 하지만, package.json 파일에는 등록되지 않습니다. (노드 최신버전은 플래그를 입력하지 않아도 자동으로 package.json 파일에 등록됩니다.) –save 플래그를 써서 언더스코어를 다시 설치해 봅시다. $ npm install --save underscore 위의 경고 문구는 패키지 구성 요소가 빠져있다는 경고입니다. 이 책을 공부할 때는 이 경고를 무시해도 됩니다. npm을 통해 패키지를 배포하려 한다면 이 경고에 신경을 써야 하지만, 이 책에서는 배포에 관해 설명하지 않습니다. 이제 package.json 파일을 보면 의존성 리스트에 언더스코어가 있습니다. 의존성 관리가 가능한 것은, package.json 파일에서 패키지 이름과 버전 번호를 읽고 필요 패키지를 다시 내려받아 설치할 수 있기 때문입니다. 지금 해봅시다. node_modules 디렉터리를 다시 삭제하고, npm install 명령을 내립니다. 네, 패키지 이름을 쓰지 않는 것이 맞습니다. npm은 package.json 파일을 읽고 필요한 패키지를 자동으로 설치합니다. 새로 만들어진 node_modules 디렉터리를 보면 확인할 수 있습니다.</summary></entry><entry><title type="html">2.2.4 깃과 버전 컨트롤</title><link href="http://localhost:4000/javascript/2020/04/12/javascript18/" rel="alternate" type="text/html" title="2.2.4 깃과 버전 컨트롤" /><published>2020-04-12T20:35:00+09:00</published><updated>2020-04-12T20:35:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/12/javascript18</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/12/javascript18/">&lt;p&gt;이 책에서 버전 컨트롤에 대해 자세히 설명하지는 않지만, 혹시 버전 컨트롤을 사용하지 않았다면 지금부터라도 사용하십시오.&lt;br /&gt;
아직 깃에 익숙하지 않다면 이 책을 통해 기회가 있으니 꼭 익숙해지기 바랍니다.&lt;/p&gt;

&lt;p&gt;먼저 프로젝트 루트에서 저장소를 초기화합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 명령은 프로젝트 저장소를 만드는 명령입니다.&lt;br /&gt;
이제 프로젝트 루트에 숨김 디렉터리 &lt;strong&gt;.git&lt;/strong&gt;이 생겼습니다.&lt;/p&gt;

&lt;p&gt;버전 컨트롤을 사용하다 보면 깃에서 추적하지 않았으면 하는 파일이 분명 생길 겁니다.&lt;br /&gt;
빌드 과정에서 생기는 파일, 임시 파일 같은 것들입니니다.&lt;br /&gt;
&lt;strong&gt;.gitignore&lt;/strong&gt; 파일을 만드십시오.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-gitignore&quot;&gt;# npm 디버그 기록
npm-debug.log*

# 프로젝트 의존성
node_modules

# macOS 폴더 속성
.DS_Store

# 임시 파일
*.tmp
*~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 밖에도 쓸모없는 파일이 있어서 제외하고 싶다면 여기 추가하면 됩니다.&lt;br /&gt;
예를 들어 에디터에서 파일을 저장할 때마다 &lt;code class=&quot;highlighter-rouge&quot;&gt;.bak&lt;/code&gt; 파일을 만든다면 이 리스트에 &lt;code class=&quot;highlighter-rouge&quot;&gt;*.bak&lt;/code&gt;을 추가하면 됩니다.&lt;/p&gt;

&lt;p&gt;깃을 사용하다 보면 &lt;strong&gt;git status&lt;/strong&gt; 명령을 아주 많이 사용하게 될 겁니다.&lt;br /&gt;
이 명령은 저장소의 현재 상태를 출력하는 명령입니다.&lt;br /&gt;
지금 해 보십시오.&lt;br /&gt;
다음과 같은 내용이 보여야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git status
On branch master

Initial commit

Untracked files:
	&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to include &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;what will be committed&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	.gitignore
	
nothing added to commit but untracked files present &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add&quot;&lt;/span&gt; to track&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 눈여겨볼 점은 깃이 디렉터리에 새 파일(&lt;strong&gt;.gitignore&lt;/strong&gt;)이 있지만, 추적하고 있지 않다(untracked)고 보고하는 겁니다.&lt;/p&gt;

&lt;p&gt;깃 저장소를 사용하는 작업의 기본 단위는 &lt;strong&gt;커밋&lt;/strong&gt;입니다.&lt;br /&gt;
현재 저장소에는 커밋이 없습니다.&lt;br /&gt;
저장소를 초기화하고 파일을 하나 만들었지만, 깃에 등록한 것은 아무것도 없습니다.&lt;br /&gt;
깃은 어떤 파일을 추적해야 하는지 짐작하지 않으므로 &lt;strong&gt;.gitignore&lt;/strong&gt; 파일을 명시적으로 저장소에 추가해야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git add .gitignore
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아직 커밋은 하지 않았습니다.&lt;br /&gt;
다음 커밋에서 &lt;strong&gt;.gitignore&lt;/strong&gt; 파일을 커밋하게끔 &lt;strong&gt;대기(stage)&lt;/strong&gt; 시키기만 했습니다.&lt;br /&gt;
&lt;strong&gt;git status&lt;/strong&gt; 명령을 다시 실행하면 달라진 것이 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git status
On branch master

Initial commit

Changes to be committed:
	&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git rm --cached &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to unstage&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	
		new file: .gitignore
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 &lt;strong&gt;.gitignore&lt;/strong&gt;를 커밋할 준비가 됐습니다.&lt;br /&gt;
아직 커밋은 하지 않았지만, 다음에 커밋할 때는 &lt;strong&gt;.gitignore&lt;/strong&gt;를 변경한 내용이 포함될 겁니다.&lt;br /&gt;
파일을 더 추가할 수 있지만, 일단 커밋을 해 봅시다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Initial commit: added .gitignore.&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 명령에서 &lt;strong&gt;-m&lt;/strong&gt; 다음에 있는 것은 &lt;strong&gt;커밋 메시지&lt;/strong&gt;입니다.&lt;br /&gt;
커밋할 때마다 간단한 설명을 붙일 수 있습니다.&lt;br /&gt;
커밋 메시지를 읽어보면 프로젝트를 어떻게 바꿔 왔는지 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;커밋을 일종의 프로젝트 스냅샷이라 생각해도 됩니다.&lt;br /&gt;
지금 찍은 스냅샷에는 &lt;strong&gt;.gitignore&lt;/strong&gt; 파일 하나만 있고, 필요하다면 언제든 이 상태로 돌아올 수 있습니다.&lt;br /&gt;
&lt;strong&gt;git status&lt;/strong&gt; 명령을 다시 내리면 다음과 같은 화면을 볼 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;On branch master
nothing to commit, working directory clean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로젝트를 조금 더 바꿔봅시다.&lt;br /&gt;
&lt;strong&gt;npm debug.log&lt;/strong&gt; 파일을 무시하도록 &lt;strong&gt;.gitignore&lt;/strong&gt; 파일을 설정 했는데, 확장자가 &lt;strong&gt;.log&lt;/strong&gt;인 파일은 모두 무시하도록 바꿔 봅시다.&lt;br /&gt;
&lt;strong&gt;.gitignore&lt;/strong&gt; 파일을 열고 &lt;strong&gt;npm-debug.log&lt;/strong&gt;*를 &lt;strong&gt;*.log&lt;/strong&gt;로 바꿉니다.&lt;br /&gt;
프로젝트 설명을 마크다운 형식으로 제공하는 것이 일반적이니 &lt;strong&gt;README.md&lt;/strong&gt; 파일도 하나 만듭시다.&lt;/p&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gh&quot;&gt;# Learning JavaScript, 3rd Edition&lt;/span&gt;
&lt;span class=&quot;gu&quot;&gt;## Chapter 2: JavaScript Development Tools&lt;/span&gt;

In this chapter we're learning about Git and other development tools.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다시 &lt;strong&gt;git status&lt;/strong&gt; 명령을 내리면 다음과 같은 화면을 볼 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git status
On branch master
Changes not staged &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;commit:
	&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to update what will be committed&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git checkout -- &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to discard changes &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;working directory&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	
		modified: .gitignore
		
Untracked files:
	&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to include &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;what will be committed&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	
		README.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;바뀐 것이 두 가지 있습니다.&lt;br /&gt;
하나는 추적 중인 파일 &lt;strong&gt;.gitignore&lt;/strong&gt;이고 다른 하나는 새 파일 &lt;strong&gt;README.md&lt;/strong&gt;입니다.&lt;br /&gt;
앞서 &lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt; 명령을 내렸던 것과 똑같이 할 수도 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git add .gitignore
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git add README.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 이번에는 와일드카드를 써서 바뀐 사항을 모두 추가하게 한 다음 한꺼번에 커밋해 봅시다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git add &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Ignored all .log files and added README.md.&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로젝트를 만들다 보면 이 작업, 즉 바뀐 것을 추가하고 커밋하는 작업을 아주 자주 하게 될 겁니다.&lt;br /&gt;
커밋 메시지는 짧고 논리적으로 일관되게 만들어야 합니다.&lt;br /&gt;
당신이 생각하는 내용을 다른 사람에게 설명한다고 생각하고 커밋 메시지를 만드십시오.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git add &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;[brief description of the changes you just made]&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;TIP&lt;/strong&gt; 초보자들은 &lt;strong&gt;git add&lt;/strong&gt;라는 명령을 보고 저장소에 ‘파일을 추가한다’고 착각하곤 합니다.&lt;br /&gt;
물론 새 파일을 추가하는 경우도 있겠지만, 저장소에 이미 있는 파일을 수정하는 경우도 많습니다.&lt;br /&gt;
다시 말해, 파일이 아니라 &lt;strong&gt;변경사항&lt;/strong&gt;을 추가하는 겁니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기서 설명한 것은 깃으로 하는 작업 중 가장 간단한 것입니다.&lt;br /&gt;
깃에 대해 더 자세히 알고 싶다면 깃허브의 &lt;a href=&quot;https://try.github.io/levels/1/challenges/1&quot;&gt;초보자용 자료&lt;/a&gt;를 보거나, 존 롤리거와 매튜 맥컬로프가 쓴 &lt;strong&gt;Version Control with Git, 2nd ed. (O’reilly, 2012)&lt;/strong&gt;을 보십시오.&lt;br /&gt;
&lt;a href=&quot;https://git-scm.com/book/ko/v2&quot;&gt;https://git-scm.com/book/ko/v2&lt;/a&gt;에 한글로 번역된 문서가 있으므로 필요할 때마다 찾아보면 도움이 될겁니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">이 책에서 버전 컨트롤에 대해 자세히 설명하지는 않지만, 혹시 버전 컨트롤을 사용하지 않았다면 지금부터라도 사용하십시오. 아직 깃에 익숙하지 않다면 이 책을 통해 기회가 있으니 꼭 익숙해지기 바랍니다. 먼저 프로젝트 루트에서 저장소를 초기화합니다. $ git init 이 명령은 프로젝트 저장소를 만드는 명령입니다. 이제 프로젝트 루트에 숨김 디렉터리 .git이 생겼습니다. 버전 컨트롤을 사용하다 보면 깃에서 추적하지 않았으면 하는 파일이 분명 생길 겁니다. 빌드 과정에서 생기는 파일, 임시 파일 같은 것들입니니다. .gitignore 파일을 만드십시오. # npm 디버그 기록 npm-debug.log* # 프로젝트 의존성 node_modules # macOS 폴더 속성 .DS_Store # 임시 파일 *.tmp *~ 이 밖에도 쓸모없는 파일이 있어서 제외하고 싶다면 여기 추가하면 됩니다. 예를 들어 에디터에서 파일을 저장할 때마다 .bak 파일을 만든다면 이 리스트에 *.bak을 추가하면 됩니다. 깃을 사용하다 보면 git status 명령을 아주 많이 사용하게 될 겁니다. 이 명령은 저장소의 현재 상태를 출력하는 명령입니다. 지금 해 보십시오. 다음과 같은 내용이 보여야 합니다. $ git status On branch master Initial commit Untracked files: (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed) .gitignore nothing added to commit but untracked files present (use &quot;git add&quot; to track) 여기서 눈여겨볼 점은 깃이 디렉터리에 새 파일(.gitignore)이 있지만, 추적하고 있지 않다(untracked)고 보고하는 겁니다. 깃 저장소를 사용하는 작업의 기본 단위는 커밋입니다. 현재 저장소에는 커밋이 없습니다. 저장소를 초기화하고 파일을 하나 만들었지만, 깃에 등록한 것은 아무것도 없습니다. 깃은 어떤 파일을 추적해야 하는지 짐작하지 않으므로 .gitignore 파일을 명시적으로 저장소에 추가해야 합니다. $ git add .gitignore 아직 커밋은 하지 않았습니다. 다음 커밋에서 .gitignore 파일을 커밋하게끔 대기(stage) 시키기만 했습니다. git status 명령을 다시 실행하면 달라진 것이 있습니다. $ git status On branch master Initial commit Changes to be committed: (use &quot;git rm --cached &amp;lt;file&amp;gt;...&quot; to unstage) new file: .gitignore 이제 .gitignore를 커밋할 준비가 됐습니다. 아직 커밋은 하지 않았지만, 다음에 커밋할 때는 .gitignore를 변경한 내용이 포함될 겁니다. 파일을 더 추가할 수 있지만, 일단 커밋을 해 봅시다. $ git commit -m &quot;Initial commit: added .gitignore.&quot; 이 명령에서 -m 다음에 있는 것은 커밋 메시지입니다. 커밋할 때마다 간단한 설명을 붙일 수 있습니다. 커밋 메시지를 읽어보면 프로젝트를 어떻게 바꿔 왔는지 알 수 있습니다. 커밋을 일종의 프로젝트 스냅샷이라 생각해도 됩니다. 지금 찍은 스냅샷에는 .gitignore 파일 하나만 있고, 필요하다면 언제든 이 상태로 돌아올 수 있습니다. git status 명령을 다시 내리면 다음과 같은 화면을 볼 수 있습니다. On branch master nothing to commit, working directory clean 프로젝트를 조금 더 바꿔봅시다. npm debug.log 파일을 무시하도록 .gitignore 파일을 설정 했는데, 확장자가 .log인 파일은 모두 무시하도록 바꿔 봅시다. .gitignore 파일을 열고 npm-debug.log*를 *.log로 바꿉니다. 프로젝트 설명을 마크다운 형식으로 제공하는 것이 일반적이니 README.md 파일도 하나 만듭시다. # Learning JavaScript, 3rd Edition ## Chapter 2: JavaScript Development Tools In this chapter we're learning about Git and other development tools. 다시 git status 명령을 내리면 다음과 같은 화면을 볼 수 있습니다. $ git status On branch master Changes not staged for commit: (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed) (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory) modified: .gitignore Untracked files: (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed) README.md 바뀐 것이 두 가지 있습니다. 하나는 추적 중인 파일 .gitignore이고 다른 하나는 새 파일 README.md입니다. 앞서 git add 명령을 내렸던 것과 똑같이 할 수도 있습니다. $ git add .gitignore $ git add README.md 하지만 이번에는 와일드카드를 써서 바뀐 사항을 모두 추가하게 한 다음 한꺼번에 커밋해 봅시다. $ git add -A $ git commit -m &quot;Ignored all .log files and added README.md.&quot; 프로젝트를 만들다 보면 이 작업, 즉 바뀐 것을 추가하고 커밋하는 작업을 아주 자주 하게 될 겁니다. 커밋 메시지는 짧고 논리적으로 일관되게 만들어야 합니다. 당신이 생각하는 내용을 다른 사람에게 설명한다고 생각하고 커밋 메시지를 만드십시오. $ git add -A $ git commit -m &quot;[brief description of the changes you just made]&quot; TIP 초보자들은 git add라는 명령을 보고 저장소에 ‘파일을 추가한다’고 착각하곤 합니다. 물론 새 파일을 추가하는 경우도 있겠지만, 저장소에 이미 있는 파일을 수정하는 경우도 많습니다. 다시 말해, 파일이 아니라 변경사항을 추가하는 겁니다. 여기서 설명한 것은 깃으로 하는 작업 중 가장 간단한 것입니다. 깃에 대해 더 자세히 알고 싶다면 깃허브의 초보자용 자료를 보거나, 존 롤리거와 매튜 맥컬로프가 쓴 Version Control with Git, 2nd ed. (O’reilly, 2012)을 보십시오. https://git-scm.com/book/ko/v2에 한글로 번역된 문서가 있으므로 필요할 때마다 찾아보면 도움이 될겁니다.</summary></entry><entry><title type="html">2.2.3 프로젝트 루트</title><link href="http://localhost:4000/javascript/2020/04/12/javascript17/" rel="alternate" type="text/html" title="2.2.3 프로젝트 루트" /><published>2020-04-12T20:31:00+09:00</published><updated>2020-04-12T20:31:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/12/javascript17</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/12/javascript17/">&lt;p&gt;프로젝트마다 디렉터리를 따로 만드는 게 좋습니다.&lt;br /&gt;
이 디렉터리를 &lt;strong&gt;프로젝트 루트&lt;/strong&gt;라고 부를 겁니다.&lt;br /&gt;
예를 들어 이 책의 예제를 lj 디렉터리에 저장한다면 그 디렉터리가 프로젝트 루트입니다.&lt;br /&gt;
이 책의 모든 터미널 예제는 당신이 프로젝트 루트에 있다고 가정하고 만들었습니다.&lt;br /&gt;
예제를 따라 했는데 뭔가 잘 안 되면, 가장 먼저 프로젝트 루트에서 명령을 내렸는지 확인하십시오.&lt;br /&gt;
우리가 만들 파일은 모두 프로젝트 루트를 기준으로 한 상대 경로입니다.&lt;br /&gt;
예를 들어 프로젝트 루트가 home/joe/work/lj 인데 책에서 public/js/test.js 파일을 만들라고 지시한다면, 그 파일의 전체 경로는 home/joe/work/lj/public/js/test.js 입니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">프로젝트마다 디렉터리를 따로 만드는 게 좋습니다. 이 디렉터리를 프로젝트 루트라고 부를 겁니다. 예를 들어 이 책의 예제를 lj 디렉터리에 저장한다면 그 디렉터리가 프로젝트 루트입니다. 이 책의 모든 터미널 예제는 당신이 프로젝트 루트에 있다고 가정하고 만들었습니다. 예제를 따라 했는데 뭔가 잘 안 되면, 가장 먼저 프로젝트 루트에서 명령을 내렸는지 확인하십시오. 우리가 만들 파일은 모두 프로젝트 루트를 기준으로 한 상대 경로입니다. 예를 들어 프로젝트 루트가 home/joe/work/lj 인데 책에서 public/js/test.js 파일을 만들라고 지시한다면, 그 파일의 전체 경로는 home/joe/work/lj/public/js/test.js 입니다.</summary></entry><entry><title type="html">2.2.2 터미널</title><link href="http://localhost:4000/javascript/2020/04/12/javascript16/" rel="alternate" type="text/html" title="2.2.2 터미널" /><published>2020-04-12T16:56:00+09:00</published><updated>2020-04-12T16:56:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/12/javascript16</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/12/javascript16/">&lt;p&gt;이 장을 따라 하는 동안에는 &lt;strong&gt;터미널(명령줄 또는 명령어 프롬프트라고도 합니다.)&lt;/strong&gt; 에서 작업하게 됩니다.&lt;br /&gt;
터미널은 텍스트 명령으로 컴퓨터를 조작하는 방법으로 프로그래머들은 터미널을 즐겨 사용합니다.&lt;br /&gt;
물론 터미널을 사용하지 않아도 필요한 일은 다 할 수 있지만,&lt;br /&gt;
필자는 터미널 사용법을 꼭 익히는 게 중요하다고 생각합니다.&lt;br /&gt;
상당히 많은 책과 교재들이 터미널을 사용하도록 쓰여 있고, 터미널에서 사용하도록 설계된 도구들도 많기 때문입니다.&lt;/p&gt;

&lt;p&gt;가장 많이 쓰이는 터미널은 &lt;strong&gt;배시(bash)&lt;/strong&gt; 라 불리는 셸입니다.&lt;br /&gt;
리눅스와 macOS 컴퓨터에서는 기본적으로 배시를 사용합니다.&lt;br /&gt;
윈도우에도 터미널이 있지만, 곧 설치할 깃에서는 따로 배시 터미널을 제공합니다.&lt;br /&gt;
필자는 이 터미널을 사용하길 권합니다.&lt;br /&gt;
이 책에서는 계속 배시를 사용합니다.&lt;/p&gt;

&lt;p&gt;리눅스나 macOS를 사용한다면 &lt;strong&gt;터미널&lt;/strong&gt; 프로그램을 찾아보십시오.&lt;br /&gt;
윈도우를 사용한다면 깃을 설치한 후 &lt;strong&gt;Git bash&lt;/strong&gt; 프로그램을 찾아보십시오.&lt;/p&gt;

&lt;p&gt;터미널을 시작하면 커서가 깜박이는 프롬프트를 볼 수 있습니다.&lt;br /&gt;
여기에 명령어를 입력합니다.&lt;br /&gt;
기본 프롬프트에는 컴퓨터 이름이나 현재 디렉터리 이름이 들어가 있는 경우가 많고,&lt;br /&gt;
일반적으로 달러 기호($)로 끝납니다.&lt;br /&gt;
&lt;strong&gt;따라서 이 장의 코드 샘플에 달러 기호가 있으면 터미널이라고 생각하면 됩니다.&lt;/strong&gt;&lt;br /&gt;
달러 기호 다음에 있는 내용은 직접 입력해야 합니다.&lt;br /&gt;
예를 들어 현재 디렉터리의 파일 리스트를 보려면 프롬프트에서 ls를 입력합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image06.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배시에서는 디렉터리 이름을 슬래시(/)로 구분합니다.&lt;br /&gt;
윈도우에서는 디렉터리 이름을 역슬레시()로 구분하지만, 깃 배시에서는 역슬래시를 슬래시로 바꿔 표현합니다.&lt;br /&gt;
배시에서는 홈 디렉터리(일반적으로 파일을 저장하는 디렉터리)를 ~로 표시합니다.&lt;/p&gt;

&lt;p&gt;이 장을 진행하려면 다른 디렉터리로 이동하는 명령(&lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt;)과 새 디렉터리를 만드는 명령(&lt;code class=&quot;highlighter-rouge&quot;&gt;mkdir&lt;/code&gt;)을 알고 있어야 합니다.&lt;br /&gt;
예를 들어 홈 디렉터리로 이동하려면 다음과 같이 입력합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image07.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;pwd 명령어는 현재 디렉터리 경로를 출력합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image08.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;현재 디렉터리에 서브디렉터리 &lt;strong&gt;test&lt;/strong&gt;를 만들려면 다음과 같이 입력합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;새로 만든 디렉터리로 이동하려면 다음과 같이 입력합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마침표 두 개(..)는 부모 디렉터리입니다.&lt;br /&gt;
즉, 한 단계 위 디렉터리로 이동하려면 다음과 같이 입력합니다.&lt;br /&gt;
앞의 명령어를 따라 했다면 홈 디렉터리로 돌아가게 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ..
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;터미널에서 사용할 수 있는 명령어는 아주 많지만, 2장을 진행하기 위해서는 이들 명령어만 알아도 충분합니다.&lt;br /&gt;
터미널에 대해 더 알고 싶다면 &lt;a href=&quot;http://teamtreehouse.com/library/console-foundations&quot;&gt;콘솔 기초 강의&lt;/a&gt;를 보십시오.&lt;/p&gt;</content><author><name></name></author><summary type="html">이 장을 따라 하는 동안에는 터미널(명령줄 또는 명령어 프롬프트라고도 합니다.) 에서 작업하게 됩니다. 터미널은 텍스트 명령으로 컴퓨터를 조작하는 방법으로 프로그래머들은 터미널을 즐겨 사용합니다. 물론 터미널을 사용하지 않아도 필요한 일은 다 할 수 있지만, 필자는 터미널 사용법을 꼭 익히는 게 중요하다고 생각합니다. 상당히 많은 책과 교재들이 터미널을 사용하도록 쓰여 있고, 터미널에서 사용하도록 설계된 도구들도 많기 때문입니다. 가장 많이 쓰이는 터미널은 배시(bash) 라 불리는 셸입니다. 리눅스와 macOS 컴퓨터에서는 기본적으로 배시를 사용합니다. 윈도우에도 터미널이 있지만, 곧 설치할 깃에서는 따로 배시 터미널을 제공합니다. 필자는 이 터미널을 사용하길 권합니다. 이 책에서는 계속 배시를 사용합니다. 리눅스나 macOS를 사용한다면 터미널 프로그램을 찾아보십시오. 윈도우를 사용한다면 깃을 설치한 후 Git bash 프로그램을 찾아보십시오. 터미널을 시작하면 커서가 깜박이는 프롬프트를 볼 수 있습니다. 여기에 명령어를 입력합니다. 기본 프롬프트에는 컴퓨터 이름이나 현재 디렉터리 이름이 들어가 있는 경우가 많고, 일반적으로 달러 기호($)로 끝납니다. 따라서 이 장의 코드 샘플에 달러 기호가 있으면 터미널이라고 생각하면 됩니다. 달러 기호 다음에 있는 내용은 직접 입력해야 합니다. 예를 들어 현재 디렉터리의 파일 리스트를 보려면 프롬프트에서 ls를 입력합니다. $ ls 배시에서는 디렉터리 이름을 슬래시(/)로 구분합니다. 윈도우에서는 디렉터리 이름을 역슬레시()로 구분하지만, 깃 배시에서는 역슬래시를 슬래시로 바꿔 표현합니다. 배시에서는 홈 디렉터리(일반적으로 파일을 저장하는 디렉터리)를 ~로 표시합니다. 이 장을 진행하려면 다른 디렉터리로 이동하는 명령(cd)과 새 디렉터리를 만드는 명령(mkdir)을 알고 있어야 합니다. 예를 들어 홈 디렉터리로 이동하려면 다음과 같이 입력합니다. $ cd ~ pwd 명령어는 현재 디렉터리 경로를 출력합니다. $ pwd 현재 디렉터리에 서브디렉터리 test를 만들려면 다음과 같이 입력합니다. $ mkdir test 새로 만든 디렉터리로 이동하려면 다음과 같이 입력합니다. $ cd test 마침표 두 개(..)는 부모 디렉터리입니다. 즉, 한 단계 위 디렉터리로 이동하려면 다음과 같이 입력합니다. 앞의 명령어를 따라 했다면 홈 디렉터리로 돌아가게 됩니다. $ cd .. 터미널에서 사용할 수 있는 명령어는 아주 많지만, 2장을 진행하기 위해서는 이들 명령어만 알아도 충분합니다. 터미널에 대해 더 알고 싶다면 콘솔 기초 강의를 보십시오.</summary></entry><entry><title type="html">2.2.1 깃 설치</title><link href="http://localhost:4000/javascript/2020/04/12/javascript15/" rel="alternate" type="text/html" title="2.2.1 깃 설치" /><published>2020-04-12T16:54:00+09:00</published><updated>2020-04-12T16:54:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/12/javascript15</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/12/javascript15/">&lt;p&gt;아직 시스템에 깃을 설치하지 않았다면 깃 홈페이지(&lt;a href=&quot;https://git-scm.com/&quot;&gt;https://git-scm.com/&lt;/a&gt;)에서 운영체제에 맞는 설치 파일과 설치방법을 찾을 수 있습니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">아직 시스템에 깃을 설치하지 않았다면 깃 홈페이지(https://git-scm.com/)에서 운영체제에 맞는 설치 파일과 설치방법을 찾을 수 있습니다.</summary></entry></feed>