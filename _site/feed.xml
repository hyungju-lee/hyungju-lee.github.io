<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-04-12T21:08:00+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">LHJ</title><subtitle>coding blog</subtitle><entry><title type="html">2.2.4 깃과 버전 컨트롤</title><link href="http://localhost:4000/javascript/2020/04/12/javascript18/" rel="alternate" type="text/html" title="2.2.4 깃과 버전 컨트롤" /><published>2020-04-12T20:35:00+09:00</published><updated>2020-04-12T20:35:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/12/javascript18</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/12/javascript18/">&lt;p&gt;이 책에서 버전 컨트롤에 대해 자세히 설명하지는 않지만, 혹시 버전 컨트롤을 사용하지 않았다면 지금부터라도 사용하십시오.&lt;br /&gt;
아직 깃에 익숙하지 않다면 이 책을 통해 기회가 있으니 꼭 익숙해지기 바랍니다.&lt;/p&gt;

&lt;p&gt;먼저 프로젝트 루트에서 저장소를 초기화합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 명령은 프로젝트 저장소를 만드는 명령입니다.&lt;br /&gt;
이제 프로젝트 루트에 숨김 디렉터리 &lt;strong&gt;.git&lt;/strong&gt;이 생겼습니다.&lt;/p&gt;

&lt;p&gt;버전 컨트롤을 사용하다 보면 깃에서 추적하지 않았으면 하는 파일이 분명 생길 겁니다.&lt;br /&gt;
빌드 과정에서 생기는 파일, 임시 파일 같은 것들입니니다.&lt;br /&gt;
&lt;strong&gt;.gitignore&lt;/strong&gt; 파일을 만드십시오.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-gitignore&quot;&gt;# npm 디버그 기록
npm-debug.log*

# 프로젝트 의존성
node_modules

# macOS 폴더 속성
.DS_Store

# 임시 파일
*.tmp
*~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 밖에도 쓸모없는 파일이 있어서 제외하고 싶다면 여기 추가하면 됩니다.&lt;br /&gt;
예를 들어 에디터에서 파일을 저장할 때마다 &lt;code class=&quot;highlighter-rouge&quot;&gt;.bak&lt;/code&gt; 파일을 만든다면 이 리스트에 &lt;code class=&quot;highlighter-rouge&quot;&gt;*.bak&lt;/code&gt;을 추가하면 됩니다.&lt;/p&gt;

&lt;p&gt;깃을 사용하다 보면 &lt;strong&gt;git status&lt;/strong&gt; 명령을 아주 많이 사용하게 될 겁니다.&lt;br /&gt;
이 명령은 저장소의 현재 상태를 출력하는 명령입니다.&lt;br /&gt;
지금 해 보십시오.&lt;br /&gt;
다음과 같은 내용이 보여야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git status
On branch master

Initial commit

Untracked files:
	&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to include &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;what will be committed&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	.gitignore
	
nothing added to commit but untracked files present &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add&quot;&lt;/span&gt; to track&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 눈여겨볼 점은 깃이 디렉터리에 새 파일(&lt;strong&gt;.gitignore&lt;/strong&gt;)이 있지만, 추적하고 있지 않다(untracked)고 보고하는 겁니다.&lt;/p&gt;

&lt;p&gt;깃 저장소를 사용하는 작업의 기본 단위는 &lt;strong&gt;커밋&lt;/strong&gt;입니다.&lt;br /&gt;
현재 저장소에는 커밋이 없습니다.&lt;br /&gt;
저장소를 초기화하고 파일을 하나 만들었지만, 깃에 등록한 것은 아무것도 없습니다.&lt;br /&gt;
깃은 어떤 파일을 추적해야 하는지 짐작하지 않으므로 &lt;strong&gt;.gitignore&lt;/strong&gt; 파일을 명시적으로 저장소에 추가해야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git add .gitignore
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아직 커밋은 하지 않았습니다.&lt;br /&gt;
다음 커밋에서 &lt;strong&gt;.gitignore&lt;/strong&gt; 파일을 커밋하게끔 &lt;strong&gt;대기(stage)&lt;/strong&gt; 시키기만 했습니다.&lt;br /&gt;
&lt;strong&gt;git status&lt;/strong&gt; 명령을 다시 실행하면 달라진 것이 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git status
On branch master

Initial commit

Changes to be committed:
	&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git rm --cached &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to unstage&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	
		new file: .gitignore
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 &lt;strong&gt;.gitignore&lt;/strong&gt;를 커밋할 준비가 됐습니다.&lt;br /&gt;
아직 커밋은 하지 않았지만, 다음에 커밋할 때는 &lt;strong&gt;.gitignore&lt;/strong&gt;를 변경한 내용이 포함될 겁니다.&lt;br /&gt;
파일을 더 추가할 수 있지만, 일단 커밋을 해 봅시다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Initial commit: added .gitignore.&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 명령에서 &lt;strong&gt;-m&lt;/strong&gt; 다음에 있는 것은 &lt;strong&gt;커밋 메시지&lt;/strong&gt;입니다.&lt;br /&gt;
커밋할 때마다 간단한 설명을 붙일 수 있습니다.&lt;br /&gt;
커밋 메시지를 읽어보면 프로젝트를 어떻게 바꿔 왔는지 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;커밋을 일종의 프로젝트 스냅샷이라 생각해도 됩니다.&lt;br /&gt;
지금 찍은 스냅샷에는 &lt;strong&gt;.gitignore&lt;/strong&gt; 파일 하나만 있고, 필요하다면 언제든 이 상태로 돌아올 수 있습니다.&lt;br /&gt;
&lt;strong&gt;git status&lt;/strong&gt; 명령을 다시 내리면 다음과 같은 화면을 볼 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;On branch master
nothing to commit, working directory clean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로젝트를 조금 더 바꿔봅시다.&lt;br /&gt;
&lt;strong&gt;npm debug.log&lt;/strong&gt; 파일을 무시하도록 &lt;strong&gt;.gitignore&lt;/strong&gt; 파일을 설정 했는데, 확장자가 &lt;strong&gt;.log&lt;/strong&gt;인 파일은 모두 무시하도록 바꿔 봅시다.&lt;br /&gt;
&lt;strong&gt;.gitignore&lt;/strong&gt; 파일을 열고 &lt;strong&gt;npm-debug.log&lt;/strong&gt;*를 &lt;strong&gt;*.log&lt;/strong&gt;로 바꿉니다.&lt;br /&gt;
프로젝트 설명을 마크다운 형식으로 제공하는 것이 일반적이니 &lt;strong&gt;README.md&lt;/strong&gt; 파일도 하나 만듭시다.&lt;/p&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gh&quot;&gt;# Learning JavaScript, 3rd Edition&lt;/span&gt;
&lt;span class=&quot;gu&quot;&gt;## Chapter 2: JavaScript Development Tools&lt;/span&gt;

In this chapter we're learning about Git and other development tools.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다시 &lt;strong&gt;git status&lt;/strong&gt; 명령을 내리면 다음과 같은 화면을 볼 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git status
On branch master
Changes not staged &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;commit:
	&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to update what will be committed&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git checkout -- &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to discard changes &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;working directory&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	
		modified: .gitignore
		
Untracked files:
	&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to include &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;what will be committed&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	
		README.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;바뀐 것이 두 가지 있습니다.&lt;br /&gt;
하나는 추적 중인 파일 &lt;strong&gt;.gitignore&lt;/strong&gt;이고 다른 하나는 새 파일 &lt;strong&gt;README.md&lt;/strong&gt;입니다.&lt;br /&gt;
앞서 &lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt; 명령을 내렸던 것과 똑같이 할 수도 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git add .gitignore
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git add README.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 이번에는 와일드카드를 써서 바뀐 사항을 모두 추가하게 한 다음 한꺼번에 커밋해 봅시다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git add &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Ignored all .log files and added README.md.&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로젝트를 만들다 보면 이 작업, 즉 바뀐 것을 추가하고 커밋하는 작업을 아주 자주 하게 될 겁니다.&lt;br /&gt;
커밋 메시지는 짧고 논리적으로 일관되게 만들어야 합니다.&lt;br /&gt;
당신이 생각하는 내용을 다른 사람에게 설명한다고 생각하고 커밋 메시지를 만드십시오.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git add &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;[brief description of the changes you just made]&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;TIP&lt;/strong&gt; 초보자들은 &lt;strong&gt;git add&lt;/strong&gt;라는 명령을 보고 저장소에 ‘파일을 추가한다’고 착각하곤 합니다.&lt;br /&gt;
물론 새 파일을 추가하는 경우도 있겠지만, 저장소에 이미 있는 파일을 수정하는 경우도 많습니다.&lt;br /&gt;
다시 말해, 파일이 아니라 &lt;strong&gt;변경사항&lt;/strong&gt;을 추가하는 겁니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기서 설명한 것은 깃으로 하는 작업 중 가장 간단한 것입니다.&lt;br /&gt;
깃에 대해 더 자세히 알고 싶다면 깃허브의 &lt;a href=&quot;https://try.github.io/levels/1/challenges/1&quot;&gt;초보자용 자료&lt;/a&gt;를 보거나, 존 롤리거와 매튜 맥컬로프가 쓴 &lt;strong&gt;Version Control with Git, 2nd ed. (O’reilly, 2012)&lt;/strong&gt;을 보십시오.&lt;br /&gt;
&lt;a href=&quot;https://git-scm.com/book/ko/v2&quot;&gt;https://git-scm.com/book/ko/v2&lt;/a&gt;에 한글로 번역된 문서가 있으므로 필요할 때마다 찾아보면 도움이 될겁니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">이 책에서 버전 컨트롤에 대해 자세히 설명하지는 않지만, 혹시 버전 컨트롤을 사용하지 않았다면 지금부터라도 사용하십시오. 아직 깃에 익숙하지 않다면 이 책을 통해 기회가 있으니 꼭 익숙해지기 바랍니다. 먼저 프로젝트 루트에서 저장소를 초기화합니다. $ git init 이 명령은 프로젝트 저장소를 만드는 명령입니다. 이제 프로젝트 루트에 숨김 디렉터리 .git이 생겼습니다. 버전 컨트롤을 사용하다 보면 깃에서 추적하지 않았으면 하는 파일이 분명 생길 겁니다. 빌드 과정에서 생기는 파일, 임시 파일 같은 것들입니니다. .gitignore 파일을 만드십시오. # npm 디버그 기록 npm-debug.log* # 프로젝트 의존성 node_modules # macOS 폴더 속성 .DS_Store # 임시 파일 *.tmp *~ 이 밖에도 쓸모없는 파일이 있어서 제외하고 싶다면 여기 추가하면 됩니다. 예를 들어 에디터에서 파일을 저장할 때마다 .bak 파일을 만든다면 이 리스트에 *.bak을 추가하면 됩니다. 깃을 사용하다 보면 git status 명령을 아주 많이 사용하게 될 겁니다. 이 명령은 저장소의 현재 상태를 출력하는 명령입니다. 지금 해 보십시오. 다음과 같은 내용이 보여야 합니다. $ git status On branch master Initial commit Untracked files: (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed) .gitignore nothing added to commit but untracked files present (use &quot;git add&quot; to track) 여기서 눈여겨볼 점은 깃이 디렉터리에 새 파일(.gitignore)이 있지만, 추적하고 있지 않다(untracked)고 보고하는 겁니다. 깃 저장소를 사용하는 작업의 기본 단위는 커밋입니다. 현재 저장소에는 커밋이 없습니다. 저장소를 초기화하고 파일을 하나 만들었지만, 깃에 등록한 것은 아무것도 없습니다. 깃은 어떤 파일을 추적해야 하는지 짐작하지 않으므로 .gitignore 파일을 명시적으로 저장소에 추가해야 합니다. $ git add .gitignore 아직 커밋은 하지 않았습니다. 다음 커밋에서 .gitignore 파일을 커밋하게끔 대기(stage) 시키기만 했습니다. git status 명령을 다시 실행하면 달라진 것이 있습니다. $ git status On branch master Initial commit Changes to be committed: (use &quot;git rm --cached &amp;lt;file&amp;gt;...&quot; to unstage) new file: .gitignore 이제 .gitignore를 커밋할 준비가 됐습니다. 아직 커밋은 하지 않았지만, 다음에 커밋할 때는 .gitignore를 변경한 내용이 포함될 겁니다. 파일을 더 추가할 수 있지만, 일단 커밋을 해 봅시다. $ git commit -m &quot;Initial commit: added .gitignore.&quot; 이 명령에서 -m 다음에 있는 것은 커밋 메시지입니다. 커밋할 때마다 간단한 설명을 붙일 수 있습니다. 커밋 메시지를 읽어보면 프로젝트를 어떻게 바꿔 왔는지 알 수 있습니다. 커밋을 일종의 프로젝트 스냅샷이라 생각해도 됩니다. 지금 찍은 스냅샷에는 .gitignore 파일 하나만 있고, 필요하다면 언제든 이 상태로 돌아올 수 있습니다. git status 명령을 다시 내리면 다음과 같은 화면을 볼 수 있습니다. On branch master nothing to commit, working directory clean 프로젝트를 조금 더 바꿔봅시다. npm debug.log 파일을 무시하도록 .gitignore 파일을 설정 했는데, 확장자가 .log인 파일은 모두 무시하도록 바꿔 봅시다. .gitignore 파일을 열고 npm-debug.log*를 *.log로 바꿉니다. 프로젝트 설명을 마크다운 형식으로 제공하는 것이 일반적이니 README.md 파일도 하나 만듭시다. # Learning JavaScript, 3rd Edition ## Chapter 2: JavaScript Development Tools In this chapter we're learning about Git and other development tools. 다시 git status 명령을 내리면 다음과 같은 화면을 볼 수 있습니다. $ git status On branch master Changes not staged for commit: (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed) (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory) modified: .gitignore Untracked files: (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed) README.md 바뀐 것이 두 가지 있습니다. 하나는 추적 중인 파일 .gitignore이고 다른 하나는 새 파일 README.md입니다. 앞서 git add 명령을 내렸던 것과 똑같이 할 수도 있습니다. $ git add .gitignore $ git add README.md 하지만 이번에는 와일드카드를 써서 바뀐 사항을 모두 추가하게 한 다음 한꺼번에 커밋해 봅시다. $ git add -A $ git commit -m &quot;Ignored all .log files and added README.md.&quot; 프로젝트를 만들다 보면 이 작업, 즉 바뀐 것을 추가하고 커밋하는 작업을 아주 자주 하게 될 겁니다. 커밋 메시지는 짧고 논리적으로 일관되게 만들어야 합니다. 당신이 생각하는 내용을 다른 사람에게 설명한다고 생각하고 커밋 메시지를 만드십시오. $ git add -A $ git commit -m &quot;[brief description of the changes you just made]&quot; TIP 초보자들은 git add라는 명령을 보고 저장소에 ‘파일을 추가한다’고 착각하곤 합니다. 물론 새 파일을 추가하는 경우도 있겠지만, 저장소에 이미 있는 파일을 수정하는 경우도 많습니다. 다시 말해, 파일이 아니라 변경사항을 추가하는 겁니다. 여기서 설명한 것은 깃으로 하는 작업 중 가장 간단한 것입니다. 깃에 대해 더 자세히 알고 싶다면 깃허브의 초보자용 자료를 보거나, 존 롤리거와 매튜 맥컬로프가 쓴 Version Control with Git, 2nd ed. (O’reilly, 2012)을 보십시오. https://git-scm.com/book/ko/v2에 한글로 번역된 문서가 있으므로 필요할 때마다 찾아보면 도움이 될겁니다.</summary></entry><entry><title type="html">2.2.3 프로젝트 루트</title><link href="http://localhost:4000/javascript/2020/04/12/javascript17/" rel="alternate" type="text/html" title="2.2.3 프로젝트 루트" /><published>2020-04-12T20:31:00+09:00</published><updated>2020-04-12T20:31:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/12/javascript17</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/12/javascript17/">&lt;p&gt;프로젝트마다 디렉터리를 따로 만드는 게 좋습니다.&lt;br /&gt;
이 디렉터리를 &lt;strong&gt;프로젝트 루트&lt;/strong&gt;라고 부를 겁니다.&lt;br /&gt;
예를 들어 이 책의 예제를 lj 디렉터리에 저장한다면 그 디렉터리가 프로젝트 루트입니다.&lt;br /&gt;
이 책의 모든 터미널 예제는 당신이 프로젝트 루트에 있다고 가정하고 만들었습니다.&lt;br /&gt;
예제를 따라 했는데 뭔가 잘 안 되면, 가장 먼저 프로젝트 루트에서 명령을 내렸는지 확인하십시오.&lt;br /&gt;
우리가 만들 파일은 모두 프로젝트 루트를 기준으로 한 상대 경로입니다.&lt;br /&gt;
예를 들어 프로젝트 루트가 home/joe/work/lj 인데 책에서 public/js/test.js 파일을 만들라고 지시한다면, 그 파일의 전체 경로는 home/joe/work/lj/public/js/test.js 입니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">프로젝트마다 디렉터리를 따로 만드는 게 좋습니다. 이 디렉터리를 프로젝트 루트라고 부를 겁니다. 예를 들어 이 책의 예제를 lj 디렉터리에 저장한다면 그 디렉터리가 프로젝트 루트입니다. 이 책의 모든 터미널 예제는 당신이 프로젝트 루트에 있다고 가정하고 만들었습니다. 예제를 따라 했는데 뭔가 잘 안 되면, 가장 먼저 프로젝트 루트에서 명령을 내렸는지 확인하십시오. 우리가 만들 파일은 모두 프로젝트 루트를 기준으로 한 상대 경로입니다. 예를 들어 프로젝트 루트가 home/joe/work/lj 인데 책에서 public/js/test.js 파일을 만들라고 지시한다면, 그 파일의 전체 경로는 home/joe/work/lj/public/js/test.js 입니다.</summary></entry><entry><title type="html">2.2.2 터미널</title><link href="http://localhost:4000/javascript/2020/04/12/javascript16/" rel="alternate" type="text/html" title="2.2.2 터미널" /><published>2020-04-12T16:56:00+09:00</published><updated>2020-04-12T16:56:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/12/javascript16</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/12/javascript16/">&lt;p&gt;이 장을 따라 하는 동안에는 &lt;strong&gt;터미널(명령줄 또는 명령어 프롬프트라고도 합니다.)&lt;/strong&gt; 에서 작업하게 됩니다.&lt;br /&gt;
터미널은 텍스트 명령으로 컴퓨터를 조작하는 방법으로 프로그래머들은 터미널을 즐겨 사용합니다.&lt;br /&gt;
물론 터미널을 사용하지 않아도 필요한 일은 다 할 수 있지만,&lt;br /&gt;
필자는 터미널 사용법을 꼭 익히는 게 중요하다고 생각합니다.&lt;br /&gt;
상당히 많은 책과 교재들이 터미널을 사용하도록 쓰여 있고, 터미널에서 사용하도록 설계된 도구들도 많기 때문입니다.&lt;/p&gt;

&lt;p&gt;가장 많이 쓰이는 터미널은 &lt;strong&gt;배시(bash)&lt;/strong&gt; 라 불리는 셸입니다.&lt;br /&gt;
리눅스와 macOS 컴퓨터에서는 기본적으로 배시를 사용합니다.&lt;br /&gt;
윈도우에도 터미널이 있지만, 곧 설치할 깃에서는 따로 배시 터미널을 제공합니다.&lt;br /&gt;
필자는 이 터미널을 사용하길 권합니다.&lt;br /&gt;
이 책에서는 계속 배시를 사용합니다.&lt;/p&gt;

&lt;p&gt;리눅스나 macOS를 사용한다면 &lt;strong&gt;터미널&lt;/strong&gt; 프로그램을 찾아보십시오.&lt;br /&gt;
윈도우를 사용한다면 깃을 설치한 후 &lt;strong&gt;Git bash&lt;/strong&gt; 프로그램을 찾아보십시오.&lt;/p&gt;

&lt;p&gt;터미널을 시작하면 커서가 깜박이는 프롬프트를 볼 수 있습니다.&lt;br /&gt;
여기에 명령어를 입력합니다.&lt;br /&gt;
기본 프롬프트에는 컴퓨터 이름이나 현재 디렉터리 이름이 들어가 있는 경우가 많고,&lt;br /&gt;
일반적으로 달러 기호($)로 끝납니다.&lt;br /&gt;
&lt;strong&gt;따라서 이 장의 코드 샘플에 달러 기호가 있으면 터미널이라고 생각하면 됩니다.&lt;/strong&gt;&lt;br /&gt;
달러 기호 다음에 있는 내용은 직접 입력해야 합니다.&lt;br /&gt;
예를 들어 현재 디렉터리의 파일 리스트를 보려면 프롬프트에서 ls를 입력합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image06.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;배시에서는 디렉터리 이름을 슬래시(/)로 구분합니다.&lt;br /&gt;
윈도우에서는 디렉터리 이름을 역슬레시()로 구분하지만, 깃 배시에서는 역슬래시를 슬래시로 바꿔 표현합니다.&lt;br /&gt;
배시에서는 홈 디렉터리(일반적으로 파일을 저장하는 디렉터리)를 ~로 표시합니다.&lt;/p&gt;

&lt;p&gt;이 장을 진행하려면 다른 디렉터리로 이동하는 명령(&lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt;)과 새 디렉터리를 만드는 명령(&lt;code class=&quot;highlighter-rouge&quot;&gt;mkdir&lt;/code&gt;)을 알고 있어야 합니다.&lt;br /&gt;
예를 들어 홈 디렉터리로 이동하려면 다음과 같이 입력합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image07.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;pwd 명령어는 현재 디렉터리 경로를 출력합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image08.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;현재 디렉터리에 서브디렉터리 &lt;strong&gt;test&lt;/strong&gt;를 만들려면 다음과 같이 입력합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;새로 만든 디렉터리로 이동하려면 다음과 같이 입력합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마침표 두 개(..)는 부모 디렉터리입니다.&lt;br /&gt;
즉, 한 단계 위 디렉터리로 이동하려면 다음과 같이 입력합니다.&lt;br /&gt;
앞의 명령어를 따라 했다면 홈 디렉터리로 돌아가게 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ..
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;터미널에서 사용할 수 있는 명령어는 아주 많지만, 2장을 진행하기 위해서는 이들 명령어만 알아도 충분합니다.&lt;br /&gt;
터미널에 대해 더 알고 싶다면 &lt;a href=&quot;http://teamtreehouse.com/library/console-foundations&quot;&gt;콘솔 기초 강의&lt;/a&gt;를 보십시오.&lt;/p&gt;</content><author><name></name></author><summary type="html">이 장을 따라 하는 동안에는 터미널(명령줄 또는 명령어 프롬프트라고도 합니다.) 에서 작업하게 됩니다. 터미널은 텍스트 명령으로 컴퓨터를 조작하는 방법으로 프로그래머들은 터미널을 즐겨 사용합니다. 물론 터미널을 사용하지 않아도 필요한 일은 다 할 수 있지만, 필자는 터미널 사용법을 꼭 익히는 게 중요하다고 생각합니다. 상당히 많은 책과 교재들이 터미널을 사용하도록 쓰여 있고, 터미널에서 사용하도록 설계된 도구들도 많기 때문입니다. 가장 많이 쓰이는 터미널은 배시(bash) 라 불리는 셸입니다. 리눅스와 macOS 컴퓨터에서는 기본적으로 배시를 사용합니다. 윈도우에도 터미널이 있지만, 곧 설치할 깃에서는 따로 배시 터미널을 제공합니다. 필자는 이 터미널을 사용하길 권합니다. 이 책에서는 계속 배시를 사용합니다. 리눅스나 macOS를 사용한다면 터미널 프로그램을 찾아보십시오. 윈도우를 사용한다면 깃을 설치한 후 Git bash 프로그램을 찾아보십시오. 터미널을 시작하면 커서가 깜박이는 프롬프트를 볼 수 있습니다. 여기에 명령어를 입력합니다. 기본 프롬프트에는 컴퓨터 이름이나 현재 디렉터리 이름이 들어가 있는 경우가 많고, 일반적으로 달러 기호($)로 끝납니다. 따라서 이 장의 코드 샘플에 달러 기호가 있으면 터미널이라고 생각하면 됩니다. 달러 기호 다음에 있는 내용은 직접 입력해야 합니다. 예를 들어 현재 디렉터리의 파일 리스트를 보려면 프롬프트에서 ls를 입력합니다. $ ls 배시에서는 디렉터리 이름을 슬래시(/)로 구분합니다. 윈도우에서는 디렉터리 이름을 역슬레시()로 구분하지만, 깃 배시에서는 역슬래시를 슬래시로 바꿔 표현합니다. 배시에서는 홈 디렉터리(일반적으로 파일을 저장하는 디렉터리)를 ~로 표시합니다. 이 장을 진행하려면 다른 디렉터리로 이동하는 명령(cd)과 새 디렉터리를 만드는 명령(mkdir)을 알고 있어야 합니다. 예를 들어 홈 디렉터리로 이동하려면 다음과 같이 입력합니다. $ cd ~ pwd 명령어는 현재 디렉터리 경로를 출력합니다. $ pwd 현재 디렉터리에 서브디렉터리 test를 만들려면 다음과 같이 입력합니다. $ mkdir test 새로 만든 디렉터리로 이동하려면 다음과 같이 입력합니다. $ cd test 마침표 두 개(..)는 부모 디렉터리입니다. 즉, 한 단계 위 디렉터리로 이동하려면 다음과 같이 입력합니다. 앞의 명령어를 따라 했다면 홈 디렉터리로 돌아가게 됩니다. $ cd .. 터미널에서 사용할 수 있는 명령어는 아주 많지만, 2장을 진행하기 위해서는 이들 명령어만 알아도 충분합니다. 터미널에 대해 더 알고 싶다면 콘솔 기초 강의를 보십시오.</summary></entry><entry><title type="html">2.2.1 깃 설치</title><link href="http://localhost:4000/javascript/2020/04/12/javascript15/" rel="alternate" type="text/html" title="2.2.1 깃 설치" /><published>2020-04-12T16:54:00+09:00</published><updated>2020-04-12T16:54:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/12/javascript15</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/12/javascript15/">&lt;p&gt;아직 시스템에 깃을 설치하지 않았다면 깃 홈페이지(&lt;a href=&quot;https://git-scm.com/&quot;&gt;https://git-scm.com/&lt;/a&gt;)에서 운영체제에 맞는 설치 파일과 설치방법을 찾을 수 있습니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">아직 시스템에 깃을 설치하지 않았다면 깃 홈페이지(https://git-scm.com/)에서 운영체제에 맞는 설치 파일과 설치방법을 찾을 수 있습니다.</summary></entry><entry><title type="html">2.2 ES6 기능</title><link href="http://localhost:4000/javascript/2020/04/12/javascript14/" rel="alternate" type="text/html" title="2.2 ES6 기능" /><published>2020-04-12T16:48:00+09:00</published><updated>2020-04-12T16:48:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/12/javascript14</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/12/javascript14/">&lt;p&gt;ES6에는 새 기능이 너무 많아서 트랜스컴파일러조차 전부 지원하지 못할 정도입니다.&lt;br /&gt;
뉴욕에사는 개발자 &lt;a href=&quot;https://twitter.com/kangax&quot;&gt;&lt;strong&gt;캉각스&lt;/strong&gt;&lt;/a&gt;는 이 혼란을 타개하기 위해 ES6(와 ES7)의 기능별 &lt;a href=&quot;https://kangax.github.io/compat-table/es6/&quot;&gt;호환성 테이블&lt;/a&gt;을 운영하고 있습니다.&lt;br /&gt;
&lt;strong&gt;2015년 8월 기준으로&lt;/strong&gt;, 가장 많은 기능을 지원하는 &lt;strong&gt;바벨(Babel)&lt;/strong&gt; 조차 72%에 불과합니다.&lt;br /&gt;
힘 빠지는 말일 수도 있지만, 바벨은 가장 중요한 기능부터 차례로 지원하고 잇으며, 이 책에서 설명하는 기능은 모두 지원합니다.&lt;/p&gt;

&lt;p&gt;트랜스컴파일을 시작하기 전에 약간의 준비 작업이 필요합니다.&lt;br /&gt;
필요한 도구를 모두 갖춰야 하고, 새 프로젝트에서 이들 도구를 사용하도록 설정하는 방법을 배워햐 합니다.&lt;br /&gt;
새 프로젝트를 설정하는 방법은 몇 번만 해보면 무의식적으로 하게 될 겁니다.&lt;br /&gt;
그때까지는, 새프로젝트를 시작할 때 이 장을 참고하십시오.&lt;/p&gt;</content><author><name></name></author><summary type="html">ES6에는 새 기능이 너무 많아서 트랜스컴파일러조차 전부 지원하지 못할 정도입니다. 뉴욕에사는 개발자 캉각스는 이 혼란을 타개하기 위해 ES6(와 ES7)의 기능별 호환성 테이블을 운영하고 있습니다. 2015년 8월 기준으로, 가장 많은 기능을 지원하는 바벨(Babel) 조차 72%에 불과합니다. 힘 빠지는 말일 수도 있지만, 바벨은 가장 중요한 기능부터 차례로 지원하고 잇으며, 이 책에서 설명하는 기능은 모두 지원합니다. 트랜스컴파일을 시작하기 전에 약간의 준비 작업이 필요합니다. 필요한 도구를 모두 갖춰야 하고, 새 프로젝트에서 이들 도구를 사용하도록 설정하는 방법을 배워햐 합니다. 새 프로젝트를 설정하는 방법은 몇 번만 해보면 무의식적으로 하게 될 겁니다. 그때까지는, 새프로젝트를 시작할 때 이 장을 참고하십시오.</summary></entry><entry><title type="html">2.1 ES6 사용하기</title><link href="http://localhost:4000/javascript/2020/04/12/javascript13/" rel="alternate" type="text/html" title="2.1 ES6 사용하기" /><published>2020-04-12T16:32:00+09:00</published><updated>2020-04-12T16:32:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/12/javascript13</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/12/javascript13/">&lt;p&gt;좋은 소식과 나쁜 소식이 있습니다.&lt;br /&gt;
좋은 소식은 ES6가 자바스크립트를 즐겁고 흥미롭게 진화시켰다는 겁니다.&lt;br /&gt;
나쁜 소식은 아직 ES6를 실무에서 쓰긴 좀 이르다는 겁니다.&lt;br /&gt;
ES6를 전혀 사용할 수 없다는 뜻이 아닙니다.&lt;br /&gt;
단지, 프로그래머가 ES6 코드를 어디에서든 쓸 수 있는 &lt;strong&gt;‘안전한’&lt;/strong&gt; ES5 코드로 트랜스컴파일하는 수고를 좀 더 해야 한다는 뜻입니다.&lt;/p&gt;

&lt;p&gt;프로그래밍을 오래 해 왔다면 이렇게 생각할 수도 있습니다.&lt;br /&gt;
“와, 믿을 수 없는데? 컴파일과 링크가 필요 없는 언어라니, 생각해 본 적도 없어.”&lt;br /&gt;
필자도 꽤 오랫동안 프로그래밍을 해 왔고, 컴파일과 링크가 필요한 프로그램을 작성하곤 했지만 과거에 대한 향수 같은 것은 느끼지 않습니다.&lt;br /&gt;
&lt;strong&gt;자바스크립트는 인터프리팅 언어이고 번거로운 부대작업이 필요 없다는 장점이 있습니다.&lt;/strong&gt;&lt;br /&gt;
(노드 같은 자바스크립트 엔진은 분명 자바스크립트를 컴파일하긴 하지만, 프로그래머가 개입할 필요 없이 자동으로 이루어집니다.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;자바스크립트의 장점은 어디서든 쓰인다는 겁니다.&lt;/strong&gt;&lt;br /&gt;
자바스크립트는 거의 항상 브라우저 스크립트 언어의 표준이었고, 노드의 등장으로 이제 브라우저 바깥으로 영역을 확대하고 있습니다.&lt;br /&gt;
그런 배경이 있으니, 브라우저가 지원하지 않을 수도 있다는 걱정 없이 ES6 코드를 사용하려면 아직 몇 년은 기다려야 할 수도 있다는 사실에 당혹감을 느낄 수도 있습니다.&lt;br /&gt;
노드 개발자라면 상황이 조금 낫습니다.&lt;br /&gt;
신경 써야 할 자바스크립트 엔진이 하나뿐이므로 노드의 ES6 지원을 지켜보면서 그에 맞게 대응하면 되니까요.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;NOTE_&lt;/strong&gt; 이 책의 ES6 예제는 파이어폭스에서 작동하며, ES6 피들(&lt;a href=&quot;http://www.es6fiddle.net/&quot;&gt;http://www.es6fiddle.net/&lt;/a&gt;) 같은 웹 사이트에서도 동작합니다.&lt;br /&gt;
하지만 실무에 사용하려면 이 장에서 소개하는 도구와 테크닉이 필요합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자바스크립트가 ES5에서 ES6로 넘어가는 과정은 &lt;strong&gt;점진적&lt;/strong&gt;입니다.&lt;br /&gt;
다른 언어에서는 볼 수 없었던 부분이죠.&lt;br /&gt;
즉, 지금 사용하는 브라우저가 ES6의 기능을 일부 지원하지만 전체를 지원하지는 못할 수도 있습니다.&lt;br /&gt;
&lt;strong&gt;자바스크립트가 점진적으로 변화할 수 있는 까닭은 자바스크립트의 동적 성격 때문이기도 하고,&lt;br /&gt;
최근 브라우저 업데이트 방식 때문이기도 합니다.&lt;/strong&gt;&lt;br /&gt;
최근의 브라우저를 가리키는 &lt;strong&gt;에버그린(evergreen)&lt;/strong&gt; 이라는 용어를 들어봤을 겁니다.&lt;br /&gt;
&lt;strong&gt;브라우저 제작자들은 사용자가 직접 업데이트해야 하는 뚜렷한 버전 번호라는 개념에서 벗어나고 있습니다.&lt;/strong&gt;&lt;br /&gt;
브라우저가 제대로 동작하려면 항상 인터넷에 연결되어 있어야 하므로,&lt;br /&gt;
항상 최신 버전을 유지할 수 있습니다.&lt;br /&gt;
물론 버전은 여전히 존재하지만, 에버그린 브라우저들은 사용자가 업그레이드를 &lt;strong&gt;거부할 수 없게&lt;/strong&gt; 하므로 최신 버전을 사용할 가능성이 큽니다.&lt;/p&gt;

&lt;p&gt;물론 에버그린 브라우저라도 ES6의 훌륭한 기능을 모두 지원할 때까지는 시간이 걸릴 겁니다.&lt;br /&gt;
따라서 그때까지는 트랜스컴파일을 피할 수 없습니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">좋은 소식과 나쁜 소식이 있습니다. 좋은 소식은 ES6가 자바스크립트를 즐겁고 흥미롭게 진화시켰다는 겁니다. 나쁜 소식은 아직 ES6를 실무에서 쓰긴 좀 이르다는 겁니다. ES6를 전혀 사용할 수 없다는 뜻이 아닙니다. 단지, 프로그래머가 ES6 코드를 어디에서든 쓸 수 있는 ‘안전한’ ES5 코드로 트랜스컴파일하는 수고를 좀 더 해야 한다는 뜻입니다. 프로그래밍을 오래 해 왔다면 이렇게 생각할 수도 있습니다. “와, 믿을 수 없는데? 컴파일과 링크가 필요 없는 언어라니, 생각해 본 적도 없어.” 필자도 꽤 오랫동안 프로그래밍을 해 왔고, 컴파일과 링크가 필요한 프로그램을 작성하곤 했지만 과거에 대한 향수 같은 것은 느끼지 않습니다. 자바스크립트는 인터프리팅 언어이고 번거로운 부대작업이 필요 없다는 장점이 있습니다. (노드 같은 자바스크립트 엔진은 분명 자바스크립트를 컴파일하긴 하지만, 프로그래머가 개입할 필요 없이 자동으로 이루어집니다.) 자바스크립트의 장점은 어디서든 쓰인다는 겁니다. 자바스크립트는 거의 항상 브라우저 스크립트 언어의 표준이었고, 노드의 등장으로 이제 브라우저 바깥으로 영역을 확대하고 있습니다. 그런 배경이 있으니, 브라우저가 지원하지 않을 수도 있다는 걱정 없이 ES6 코드를 사용하려면 아직 몇 년은 기다려야 할 수도 있다는 사실에 당혹감을 느낄 수도 있습니다. 노드 개발자라면 상황이 조금 낫습니다. 신경 써야 할 자바스크립트 엔진이 하나뿐이므로 노드의 ES6 지원을 지켜보면서 그에 맞게 대응하면 되니까요. NOTE_ 이 책의 ES6 예제는 파이어폭스에서 작동하며, ES6 피들(http://www.es6fiddle.net/) 같은 웹 사이트에서도 동작합니다. 하지만 실무에 사용하려면 이 장에서 소개하는 도구와 테크닉이 필요합니다. 자바스크립트가 ES5에서 ES6로 넘어가는 과정은 점진적입니다. 다른 언어에서는 볼 수 없었던 부분이죠. 즉, 지금 사용하는 브라우저가 ES6의 기능을 일부 지원하지만 전체를 지원하지는 못할 수도 있습니다. 자바스크립트가 점진적으로 변화할 수 있는 까닭은 자바스크립트의 동적 성격 때문이기도 하고, 최근 브라우저 업데이트 방식 때문이기도 합니다. 최근의 브라우저를 가리키는 에버그린(evergreen) 이라는 용어를 들어봤을 겁니다. 브라우저 제작자들은 사용자가 직접 업데이트해야 하는 뚜렷한 버전 번호라는 개념에서 벗어나고 있습니다. 브라우저가 제대로 동작하려면 항상 인터넷에 연결되어 있어야 하므로, 항상 최신 버전을 유지할 수 있습니다. 물론 버전은 여전히 존재하지만, 에버그린 브라우저들은 사용자가 업그레이드를 거부할 수 없게 하므로 최신 버전을 사용할 가능성이 큽니다. 물론 에버그린 브라우저라도 ES6의 훌륭한 기능을 모두 지원할 때까지는 시간이 걸릴 겁니다. 따라서 그때까지는 트랜스컴파일을 피할 수 없습니다.</summary></entry><entry><title type="html">2. 자바스크립트 개발 도구</title><link href="http://localhost:4000/javascript/2020/04/12/javascript12/" rel="alternate" type="text/html" title="2. 자바스크립트 개발 도구" /><published>2020-04-12T16:24:00+09:00</published><updated>2020-04-12T16:24:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/12/javascript12</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/12/javascript12/">&lt;p&gt;1장에서 본 것처럼 텍스트 에디터와 브라우저만 있어도 자바스크립트를 작성할 수 있지만, 유용한 개발 도구도 많이 있습니다.&lt;br /&gt;
그리고 앞으로는 &lt;strong&gt;ES6&lt;/strong&gt;만 사용할 것이므로 ES6 코드를 ES5 코드로 바꿀 방법도 필요합니다.&lt;br /&gt;
이 장에서 설명하는 도구들은 매우 널리 쓰이므로, 오픈 소스 프로젝트나 소프트웨어 개발 팀에 참여하면 거의 반드시 사용하게 될 겁니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;깃(git)&lt;/strong&gt; : 프로젝트가 커져도 쉽게 관리할 수 있고 다른 개발자와 협력할 수 있게 돕는 버전 컨트롤 도구입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;노드(Node)&lt;/strong&gt; : 브라우저 밖에서 자바스크립트를 실행할 수 있게 하는 도구입니다. 노드와 함께 설치되는 npm은 이 리스트의 다른 도구를 설치할 때 필요합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;걸프(Gulp)&lt;/strong&gt; : 반복적인 개발 작업을 자동화하는 빌드 도구입니다. &lt;strong&gt;그런트(Grunt)&lt;/strong&gt;도 널리 쓰입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;바벨(Babel)&lt;/strong&gt; : ES6 코드를 ES5 코드로 변환하는 트랜스컴파일러입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ES린트(ESLint)&lt;/strong&gt; : 자주 하는 실수를 피하고 더 나은 프로그래머가 되도록 돕는 린트 프로그램입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2장은 우리의 주제인 자바스크립트에서 멀어지는 장이 아닙니다.&lt;br /&gt;
자바스크립트 개발에 널리 쓰이는 중요한 도구와 테크닉을 소개하는 장입니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">1장에서 본 것처럼 텍스트 에디터와 브라우저만 있어도 자바스크립트를 작성할 수 있지만, 유용한 개발 도구도 많이 있습니다. 그리고 앞으로는 ES6만 사용할 것이므로 ES6 코드를 ES5 코드로 바꿀 방법도 필요합니다. 이 장에서 설명하는 도구들은 매우 널리 쓰이므로, 오픈 소스 프로젝트나 소프트웨어 개발 팀에 참여하면 거의 반드시 사용하게 될 겁니다. 깃(git) : 프로젝트가 커져도 쉽게 관리할 수 있고 다른 개발자와 협력할 수 있게 돕는 버전 컨트롤 도구입니다. 노드(Node) : 브라우저 밖에서 자바스크립트를 실행할 수 있게 하는 도구입니다. 노드와 함께 설치되는 npm은 이 리스트의 다른 도구를 설치할 때 필요합니다. 걸프(Gulp) : 반복적인 개발 작업을 자동화하는 빌드 도구입니다. 그런트(Grunt)도 널리 쓰입니다. 바벨(Babel) : ES6 코드를 ES5 코드로 변환하는 트랜스컴파일러입니다. ES린트(ESLint) : 자주 하는 실수를 피하고 더 나은 프로그래머가 되도록 돕는 린트 프로그램입니다. 2장은 우리의 주제인 자바스크립트에서 멀어지는 장이 아닙니다. 자바스크립트 개발에 널리 쓰이는 중요한 도구와 테크닉을 소개하는 장입니다.</summary></entry><entry><title type="html">1.10 Hello, World</title><link href="http://localhost:4000/javascript/2020/04/12/javascript11/" rel="alternate" type="text/html" title="1.10 Hello, World" /><published>2020-04-12T16:15:00+09:00</published><updated>2020-04-12T16:15:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/12/javascript11</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/12/javascript11/">&lt;p&gt;브라이언 커니핸의 예제로 이 장의 마지막을 장식하도록 합시다.&lt;br /&gt;
어려운 부분은 이미 다 했습니다.&lt;br /&gt;
이제 할 일은 텍스트를 추가하는 것뿐입니다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;onMouseDown&lt;/code&gt; 핸들러 앞에 다음 코드를 추가하십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;use strict&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;paper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;install&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;paper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;mainCanvas&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Circle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fillColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;black&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;PointText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;justification&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fillColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fontSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;hello world&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tool&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;tool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onMouseDown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Circle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fillColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;green&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;paper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 추가한 내용은 매우 단순합니다.&lt;br /&gt;
텍스트의 배경으로 쓸 다른 원을 하나 더 만들고, 텍스트 객체 &lt;code class=&quot;highlighter-rouge&quot;&gt;PointText&lt;/code&gt;를 만들었습니다.&lt;br /&gt;
텍스트가 캔버스의 중앙에 위치하도록 하고, 정렬 방식과 색깔, 크기 같은 몇 가지 속성을 지정했습니다.&lt;br /&gt;
마지막으로 실제 텍스트 컨텐츠인 “hello world”를 지정했습니다.&lt;/p&gt;

&lt;p&gt;자바스크립트로 텍스트를 출력한 것이 이번이 처음은 아닙니다.&lt;br /&gt;
이 장 초반의 &lt;code class=&quot;highlighter-rouge&quot;&gt;console.log&lt;/code&gt; 예제에서도 이미 텍스트를 출력했습니다.&lt;br /&gt;
물론 그 예제에서도 “hello world” 텍스트를 출력하는 것이 1972년에 했을 방법과 더 비슷할 겁니다.&lt;br /&gt;
하지만 중요한 것은 텍스트의 내용이나 어떻게 출력되는지가 아닙니다.&lt;br /&gt;
&lt;strong&gt;중요한 것은 자동으로 실행되는 것을 만들었다는 점, 그리고 눈으로 볼 수 있는 효과가 있다는 점입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;브라우저를 새로고침하면 거룩한 “hello, world”의 전통에 동참하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image05.gif&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“hello world”를 출력해본 것이 처음이라면, 프로그래밍의 세계에 오신 것을 환영합니다.&lt;br /&gt;
그렇지 않다면, 이 예제를 통해 자바스크립트에 대해 어느 정도 이해할 수 있었기를 바랍니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">브라이언 커니핸의 예제로 이 장의 마지막을 장식하도록 합시다. 어려운 부분은 이미 다 했습니다. 이제 할 일은 텍스트를 추가하는 것뿐입니다. onMouseDown 핸들러 앞에 다음 코드를 추가하십시오. $(document).ready(function () { 'use strict'; paper.install(window); paper.setup(document.getElementById('mainCanvas')); var c = Shape.Circle(200, 200, 80); c.fillColor = 'black'; var text = new PointText(200, 200); text.justification = 'center'; text.fillColor = 'white'; text.fontSize = 20; text.content = 'hello world'; var tool = new Tool(); tool.onMouseDown = function (event) { var c = Shape.Circle(event.point.x, event.point.y, 20); c.fillColor = 'green'; } paper.view.draw(); }) 여기서 추가한 내용은 매우 단순합니다. 텍스트의 배경으로 쓸 다른 원을 하나 더 만들고, 텍스트 객체 PointText를 만들었습니다. 텍스트가 캔버스의 중앙에 위치하도록 하고, 정렬 방식과 색깔, 크기 같은 몇 가지 속성을 지정했습니다. 마지막으로 실제 텍스트 컨텐츠인 “hello world”를 지정했습니다. 자바스크립트로 텍스트를 출력한 것이 이번이 처음은 아닙니다. 이 장 초반의 console.log 예제에서도 이미 텍스트를 출력했습니다. 물론 그 예제에서도 “hello world” 텍스트를 출력하는 것이 1972년에 했을 방법과 더 비슷할 겁니다. 하지만 중요한 것은 텍스트의 내용이나 어떻게 출력되는지가 아닙니다. 중요한 것은 자동으로 실행되는 것을 만들었다는 점, 그리고 눈으로 볼 수 있는 효과가 있다는 점입니다. 브라우저를 새로고침하면 거룩한 “hello, world”의 전통에 동참하게 됩니다. “hello world”를 출력해본 것이 처음이라면, 프로그래밍의 세계에 오신 것을 환영합니다. 그렇지 않다면, 이 예제를 통해 자바스크립트에 대해 어느 정도 이해할 수 있었기를 바랍니다.</summary></entry><entry><title type="html">1.9 사용자 입력 처리하기</title><link href="http://localhost:4000/javascript/2020/04/12/javascript10/" rel="alternate" type="text/html" title="1.9 사용자 입력 처리하기" /><published>2020-04-12T15:44:00+09:00</published><updated>2020-04-12T15:44:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/12/javascript10</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/12/javascript10/">&lt;p&gt;지금까지는 사용자의 입력을 전혀 받지 않은 채 프로그램을 실행했습니다.&lt;br /&gt;
사용자가 원을 클릭할 수도 있지만, 아무 반응도 나타나지 않습니다.&lt;br /&gt;
마찬가지로, 원을 드래그해봐도 아무 일도 일어나지 않습니다.&lt;br /&gt;
원을 어디에 그릴지 사용자가 선택할 수 있게 해서 프로그램을 좀 더 대화형으로 바꿔봅시다.&lt;/p&gt;

&lt;p&gt;사용자 입력은 항상 &lt;strong&gt;비동기적&lt;/strong&gt;이라는 사실에 익숙해져야 합니다.&lt;br /&gt;
&lt;strong&gt;비동기적 이벤트&lt;/strong&gt;란 이벤트가 언제 일어날지 프로그래머가 전혀 알 수 없는 이벤트를 말합니다.&lt;br /&gt;
사용자의 마우스 클릭도 비동기적 이벤트의 일종입니다.&lt;br /&gt;
사용자의 마음에 들어가지 않는 한 언제 클릭할지는 알 수 없습니다.&lt;br /&gt;
사용자가 클릭하면 거기에 반응하는 건 물론 가능하지만, 언제 클릭할지, 클릭을 할지 말지는 사용자 마음대로입니다.&lt;br /&gt;
**사용자의 입력에 따라 일어나는 비동기적 이벤트는 비교적 직관적이지만,&lt;br /&gt;
책의 후반에서는 그다지 직관적이지 않은 비동기적 이벤트에 대해서드 공부하게 될겁니다. **&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Paper.js&lt;/strong&gt;는 &lt;strong&gt;툴(tool)&lt;/strong&gt; 객체를 통해 사용자 입력을 처리합니다.&lt;br /&gt;
바둑판 모양으로 원을 그리는 코드를 다음 코드로 교체하십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;use strict&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;paper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;install&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;paper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;mainCanvas&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tool&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;tool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onMouseDown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Circle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fillColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;green&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;paper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image04.gif&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 코드의 첫 행에서는 tool 객체를 만들었습니다.&lt;br /&gt;
객체를 만들면 거기에 &lt;strong&gt;이벤트 핸들러&lt;/strong&gt;를 연결할 수 있습니다.&lt;br /&gt;
여기서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;onMouseDown&lt;/code&gt; 이벤트 핸들러를 연결했습니다.&lt;br /&gt;
사용자가 마우스를 클릭할 때마다 이 핸들러에 연결한 함수가 호출됩니다.&lt;br /&gt;
이 사실을 잘 이해해야 합니다.&lt;br /&gt;
앞의 예제에서는 코드가 즉시 실행됐습니다.&lt;br /&gt;
브라우저를 새로고침 하면 자동으로 녹색 원이 나타났습니다.&lt;br /&gt;
여기서는 그렇게 하지 않습니다.&lt;br /&gt;
그렇게 했다면 녹색 원 하나가 화면 어딘가에 나타났을 겁니다.&lt;br /&gt;
대신, &lt;strong&gt;사용자가 캔버스 어딘가를 마우스로 클릭해야만&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;function&lt;/code&gt; 다음에 있는 중괄호 사이의 코드가 실행됩니다.&lt;/p&gt;

&lt;p&gt;이벤트 핸들러는 두 가지 일을 합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;첫 번째는 마우스를 클릭할 때 코드를 실행하는 것이고,&lt;/li&gt;
  &lt;li&gt;두 번째는 어디를 클릭했는지 보고하는 겁니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;마우스로 클릭한 위치는 매개변수 &lt;code class=&quot;highlighter-rouge&quot;&gt;event.point&lt;/code&gt; 프로퍼티에 저장됩니다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;event.point&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; 프로퍼티가 마우스로 클릭한 위치의 좌표입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; 좌표를 각각 지정하지 않고 클릭한 위치를 바로 넘기면 좀 더 짧게 쓸 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Circle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드는 자바스크립트에서 매우 중요한 측면을 잘 나타냅니다.&lt;br /&gt;
자바스크립트는 넘겨받은 매개변수를 바탕으로 추론하는 능력이 있습니다.&lt;br /&gt;
이전에 쓴 코드처럼 숫자 세 개를 연달아 넘기면 그 숫자들은 각각 &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; 좌표, 반지름입니다.&lt;br /&gt;
여기서처럼 매개변수 두 개를 넘기면 처음 것은 &lt;strong&gt;위치&lt;/strong&gt; 객체이고, 두 번째 것은 &lt;strong&gt;반지름&lt;/strong&gt;입니다.&lt;br /&gt;
여기에 대해서는 6장과 9장에서 더 자세히 알아보겠습니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">지금까지는 사용자의 입력을 전혀 받지 않은 채 프로그램을 실행했습니다. 사용자가 원을 클릭할 수도 있지만, 아무 반응도 나타나지 않습니다. 마찬가지로, 원을 드래그해봐도 아무 일도 일어나지 않습니다. 원을 어디에 그릴지 사용자가 선택할 수 있게 해서 프로그램을 좀 더 대화형으로 바꿔봅시다. 사용자 입력은 항상 비동기적이라는 사실에 익숙해져야 합니다. 비동기적 이벤트란 이벤트가 언제 일어날지 프로그래머가 전혀 알 수 없는 이벤트를 말합니다. 사용자의 마우스 클릭도 비동기적 이벤트의 일종입니다. 사용자의 마음에 들어가지 않는 한 언제 클릭할지는 알 수 없습니다. 사용자가 클릭하면 거기에 반응하는 건 물론 가능하지만, 언제 클릭할지, 클릭을 할지 말지는 사용자 마음대로입니다. **사용자의 입력에 따라 일어나는 비동기적 이벤트는 비교적 직관적이지만, 책의 후반에서는 그다지 직관적이지 않은 비동기적 이벤트에 대해서드 공부하게 될겁니다. ** Paper.js는 툴(tool) 객체를 통해 사용자 입력을 처리합니다. 바둑판 모양으로 원을 그리는 코드를 다음 코드로 교체하십시오. $(document).ready(function () { 'use strict'; paper.install(window); paper.setup(document.getElementById('mainCanvas')); var tool = new Tool(); tool.onMouseDown = function (event) { var c = Shape.Circle(event.point.x, event.point.y, 20); c.fillColor = 'green'; } paper.view.draw(); }) 이 코드의 첫 행에서는 tool 객체를 만들었습니다. 객체를 만들면 거기에 이벤트 핸들러를 연결할 수 있습니다. 여기서는 onMouseDown 이벤트 핸들러를 연결했습니다. 사용자가 마우스를 클릭할 때마다 이 핸들러에 연결한 함수가 호출됩니다. 이 사실을 잘 이해해야 합니다. 앞의 예제에서는 코드가 즉시 실행됐습니다. 브라우저를 새로고침 하면 자동으로 녹색 원이 나타났습니다. 여기서는 그렇게 하지 않습니다. 그렇게 했다면 녹색 원 하나가 화면 어딘가에 나타났을 겁니다. 대신, 사용자가 캔버스 어딘가를 마우스로 클릭해야만 function 다음에 있는 중괄호 사이의 코드가 실행됩니다. 이벤트 핸들러는 두 가지 일을 합니다. 첫 번째는 마우스를 클릭할 때 코드를 실행하는 것이고, 두 번째는 어디를 클릭했는지 보고하는 겁니다. 마우스로 클릭한 위치는 매개변수 event.point 프로퍼티에 저장됩니다. event.point의 x와 y 프로퍼티가 마우스로 클릭한 위치의 좌표입니다. x와 y 좌표를 각각 지정하지 않고 클릭한 위치를 바로 넘기면 좀 더 짧게 쓸 수 있습니다. var c = Shape.Circle(event.point, 20); 이 코드는 자바스크립트에서 매우 중요한 측면을 잘 나타냅니다. 자바스크립트는 넘겨받은 매개변수를 바탕으로 추론하는 능력이 있습니다. 이전에 쓴 코드처럼 숫자 세 개를 연달아 넘기면 그 숫자들은 각각 x와 y 좌표, 반지름입니다. 여기서처럼 매개변수 두 개를 넘기면 처음 것은 위치 객체이고, 두 번째 것은 반지름입니다. 여기에 대해서는 6장과 9장에서 더 자세히 알아보겠습니다.</summary></entry><entry><title type="html">1.8 반복적인 작업 자동화하기</title><link href="http://localhost:4000/javascript/2020/04/12/javascript09/" rel="alternate" type="text/html" title="1.8 반복적인 작업 자동화하기" /><published>2020-04-12T14:37:00+09:00</published><updated>2020-04-12T14:37:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/12/javascript09</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/12/javascript09/">&lt;p&gt;원을 하나만 그리지 않고 캔버스 전체에 바둑판 모양으로 채우고 싶다고 해 봅시다.&lt;br /&gt;
원의 크기를 줄이고 원의 중심이 서로 50px씩 떨어지게 하면 캔버스에 64개의 원을 그릴 수 있습니다.&lt;br /&gt;
물론, 앞에서 만든 코드를 63번 복사해서 붙여넣고, 일일이 좌표를 수정해서 바둑판 모양으로 채워도 됩니다.&lt;br /&gt;
하지만 너무 지겹겠지요?&lt;br /&gt;
다행히 컴퓨터는 이런 반복적인 작업에 최적화되어 있습니다.&lt;br /&gt;
원 64개를 동일한 간격으로 그리려면 어떻게 해야 하는지 살펴봅시다.&lt;br /&gt;
원 하나를 그리는 코드를 다음과 같이 수정하십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;use strict&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;paper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;install&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;paper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;mainCanvas&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;400&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;400&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Circle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fillColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;green&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;paper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;브라우저를 새로고침하면 녹색 원 64개가 나타납니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image03.jpg&quot; alt=&quot;이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로그래밍 경험이 없다면 앞의 코드가 좀 어렵게 느껴질 수도 있겠지만,&lt;br /&gt;
128줄을 손으로 작성하는 것보다는 훨씬 낫다는 건 이해할 수 있을 겁니다.&lt;/p&gt;

&lt;p&gt;여기서 사용한 것은 &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; 루프입니다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; 루프는 4장에서 자세히 배울 흐름 제어 문법의 일부입니다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; 루프를 사용하려면 초기값(25), 제한 조건(400 미만), 증가분(50)이 필요합니다.&lt;br /&gt;
x축과 y축에서 각각 반복해야 하므로 루프를 두 번 썼습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;NOTE_&lt;/strong&gt; 이 예제는 여러 가지 방법으로 만들 수 있습니다.&lt;br /&gt;
여기서 사용한 방법은 x, y 좌표를 중요하게 취급했습니다.&lt;br /&gt;
원이 어디서 시작하는지, 원 사이의 간격은 얼마가 되어야 하는지 명시적으로 지정했습니다.&lt;br /&gt;
다른 방법을 쓸 수도 있습니다.&lt;br /&gt;
예를 들어 좌표와 상관없이 원의 숫자(64)만 중요하다고 판단한다면, 프로그램에서 원을 캔버스 어디에 배치할지 정하게 만들 수도 있습니다.&lt;br /&gt;
여기서 좌표를 지정하는 방법을 쓴 이유는 만약 루프를 사용하지 않고 코드를 63번 복사해서 붙여넣었다면 위와 비슷하게 원 사이의 간격을 지정했을 것으로 생각하기 때문입니다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">원을 하나만 그리지 않고 캔버스 전체에 바둑판 모양으로 채우고 싶다고 해 봅시다. 원의 크기를 줄이고 원의 중심이 서로 50px씩 떨어지게 하면 캔버스에 64개의 원을 그릴 수 있습니다. 물론, 앞에서 만든 코드를 63번 복사해서 붙여넣고, 일일이 좌표를 수정해서 바둑판 모양으로 채워도 됩니다. 하지만 너무 지겹겠지요? 다행히 컴퓨터는 이런 반복적인 작업에 최적화되어 있습니다. 원 64개를 동일한 간격으로 그리려면 어떻게 해야 하는지 살펴봅시다. 원 하나를 그리는 코드를 다음과 같이 수정하십시오. $(document).ready(function () { 'use strict'; paper.install(window); paper.setup(document.getElementById('mainCanvas')); var c; for (var x=25; x&amp;lt;400; x+=50) { for (var y=25; y&amp;lt;400; y+=50) { c = Shape.Circle(x, y, 20); c.fillColor = 'green'; } } paper.view.draw(); }) 브라우저를 새로고침하면 녹색 원 64개가 나타납니다. 프로그래밍 경험이 없다면 앞의 코드가 좀 어렵게 느껴질 수도 있겠지만, 128줄을 손으로 작성하는 것보다는 훨씬 낫다는 건 이해할 수 있을 겁니다. 여기서 사용한 것은 for 루프입니다. for 루프는 4장에서 자세히 배울 흐름 제어 문법의 일부입니다. for 루프를 사용하려면 초기값(25), 제한 조건(400 미만), 증가분(50)이 필요합니다. x축과 y축에서 각각 반복해야 하므로 루프를 두 번 썼습니다. NOTE_ 이 예제는 여러 가지 방법으로 만들 수 있습니다. 여기서 사용한 방법은 x, y 좌표를 중요하게 취급했습니다. 원이 어디서 시작하는지, 원 사이의 간격은 얼마가 되어야 하는지 명시적으로 지정했습니다. 다른 방법을 쓸 수도 있습니다. 예를 들어 좌표와 상관없이 원의 숫자(64)만 중요하다고 판단한다면, 프로그램에서 원을 캔버스 어디에 배치할지 정하게 만들 수도 있습니다. 여기서 좌표를 지정하는 방법을 쓴 이유는 만약 루프를 사용하지 않고 코드를 63번 복사해서 붙여넣었다면 위와 비슷하게 원 사이의 간격을 지정했을 것으로 생각하기 때문입니다.</summary></entry></feed>