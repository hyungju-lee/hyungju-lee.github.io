<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-05-08T11:27:35+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">LHJ</title><subtitle>coding blog</subtitle><entry><title type="html">php 파일 gulp 실행하기</title><link href="http://localhost:4000/issue/2020/05/08/issue08/" rel="alternate" type="text/html" title="php 파일 gulp 실행하기" /><published>2020-05-08T11:21:12+09:00</published><updated>2020-05-08T11:21:12+09:00</updated><id>http://localhost:4000/issue/2020/05/08/issue08</id><content type="html" xml:base="http://localhost:4000/issue/2020/05/08/issue08/">&lt;p&gt;11번가 gulp 세팅하면서 알게된 점입니다.
11번가는 html 파일들이 php 문법으로 되어있었습니다.
때문에 일반적으로 마크업에서 하듯이 걸프의 browser-sync 모듈로 로컬서버를 열게되면 php 문법이 해석되지않아 페이지들이 제대로 안 보이는 문제점이 있습니다.&lt;/p&gt;

&lt;p&gt;이 문제를 해결하기 위해선 browser-sync 모듈이 php 문법을 해석하고 컴파일할 수 있도록 기존 php 서버와 연결을 해줘야됩니다.&lt;/p&gt;

&lt;p&gt;저희 회사엔 기본적으로 로컬서버가 제공되므로 로컬서버 기준으로 예시를 보여드리도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;방법 1.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;우선 &lt;code class=&quot;highlighter-rouge&quot;&gt;gulp-connect-php&lt;/code&gt; 모듈과 &lt;code class=&quot;highlighter-rouge&quot;&gt;browser-sync&lt;/code&gt; 모듈이 필요합니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;npm i -D gulp-connect-php browser-sync&lt;/code&gt; 
해당 모듈을 설치해줍니다.&lt;/p&gt;

&lt;p&gt;그리고 로컬 서버의 포트번호를 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/issue/issue06.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 식을 작성해줍니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// php 서버&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;phpServer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;phpConnect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// browsersync가 프록시를 통해 연결되는 독립형 PHP 서버&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 웹 서버에 액세스하려는 포트입니다. 포트가 이미 사용 중이면 작업이 실패합니다.&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;keepalive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;../&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;browserSync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// php 서버 포트번호와 동일해야됩니다.&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;proxy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;localhost:80&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;watch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;../html/**/*.html&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;browserSyncReload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;watch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sprites&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s2&quot;&gt;`!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sprites&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;series&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cleanImg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sprites&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sassBuild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;browserSyncReload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;watch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;
        &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;../sass/**/**/*&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;!../sass/**/sprites/*&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;series&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sassBuild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;browserSyncReload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에서 핵심은 php 파일을 해석하고 컴파일 할 수 있는 서버의 포트번호와 위 소스의 포트번호를 일치시켜야 된다는 겁니다.&lt;/p&gt;

&lt;p&gt;위와 같이 작성하면 gulp로도 php 파일을 확인하며 작업할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;만약 회사가 아닌 다른 PC에서 gulp를 활용하여 php파일을 작업해야될 경우일 땐, 다음과 같이 하시면 됩니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;방법2.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mac을 사용하시는 분이라면 &lt;a href=&quot;https://www.mamp.info/en/downloads/?m=1581611990&amp;amp;&quot;&gt;https://www.mamp.info/en/downloads/?m=1581611990&amp;amp;&lt;/a&gt; 왼쪽 사이트에 접속하셔서&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/issue/issue07.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당 프로그램을 다운받으시면 됩니다.&lt;/p&gt;

&lt;p&gt;윈도우라면 &lt;a href=&quot;https://www.apachefriends.org/index.html&quot;&gt;https://www.apachefriends.org/index.html&lt;/a&gt; 왼쪽 사이트에 접속하셔서&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/issue/issue08.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당 프로그램을 다운받으시면 됩니다.&lt;/p&gt;

&lt;p&gt;위 프로그램들이 하는 역할은 PHP 파일을 해석할 수 있는 로컬서버를 쉽게 만들 수 있도록 도와줍니다.
위 프로그램들에 관한 설명은 여러 블로그에 많아 생략하도록 하겠습니다.
&lt;strong&gt;위 프로그램들의 로컬서버 포트번호와 gulpfile 소스의 포트번호를 마찬가지로 일치시켜주면 됩니다.&lt;/strong&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">11번가 gulp 세팅하면서 알게된 점입니다. 11번가는 html 파일들이 php 문법으로 되어있었습니다. 때문에 일반적으로 마크업에서 하듯이 걸프의 browser-sync 모듈로 로컬서버를 열게되면 php 문법이 해석되지않아 페이지들이 제대로 안 보이는 문제점이 있습니다. 이 문제를 해결하기 위해선 browser-sync 모듈이 php 문법을 해석하고 컴파일할 수 있도록 기존 php 서버와 연결을 해줘야됩니다. 저희 회사엔 기본적으로 로컬서버가 제공되므로 로컬서버 기준으로 예시를 보여드리도록 하겠습니다. 방법 1. 우선 gulp-connect-php 모듈과 browser-sync 모듈이 필요합니다. npm i -D gulp-connect-php browser-sync 해당 모듈을 설치해줍니다. 그리고 로컬 서버의 포트번호를 확인합니다. 그리고 식을 작성해줍니다. // php 서버 const phpServer = () =&amp;gt; { phpConnect.server({ // browsersync가 프록시를 통해 연결되는 독립형 PHP 서버 // 웹 서버에 액세스하려는 포트입니다. 포트가 이미 사용 중이면 작업이 실패합니다. port: 80, keepalive: true, base: &quot;../&quot; }, function () { browserSync({ // php 서버 포트번호와 동일해야됩니다. proxy: 'localhost:80' }) }) watch(&quot;../html/**/*.html&quot;, browserSyncReload) watch([ config.path.sprites.src, `!${config.path.sprites.dest}` ], series(cleanImg, sprites, sassBuild, browserSyncReload)) watch([ &quot;../sass/**/**/*&quot;, &quot;!../sass/**/sprites/*&quot; ], series(sassBuild, browserSyncReload)) } 위에서 핵심은 php 파일을 해석하고 컴파일 할 수 있는 서버의 포트번호와 위 소스의 포트번호를 일치시켜야 된다는 겁니다. 위와 같이 작성하면 gulp로도 php 파일을 확인하며 작업할 수 있습니다. 만약 회사가 아닌 다른 PC에서 gulp를 활용하여 php파일을 작업해야될 경우일 땐, 다음과 같이 하시면 됩니다. 방법2. Mac을 사용하시는 분이라면 https://www.mamp.info/en/downloads/?m=1581611990&amp;amp; 왼쪽 사이트에 접속하셔서 해당 프로그램을 다운받으시면 됩니다. 윈도우라면 https://www.apachefriends.org/index.html 왼쪽 사이트에 접속하셔서 해당 프로그램을 다운받으시면 됩니다. 위 프로그램들이 하는 역할은 PHP 파일을 해석할 수 있는 로컬서버를 쉽게 만들 수 있도록 도와줍니다. 위 프로그램들에 관한 설명은 여러 블로그에 많아 생략하도록 하겠습니다. 위 프로그램들의 로컬서버 포트번호와 gulpfile 소스의 포트번호를 마찬가지로 일치시켜주면 됩니다.</summary></entry><entry><title type="html">8.2.3 slice 배열 일부 가져오기 - 사본</title><link href="http://localhost:4000/javascript/2020/05/08/javascript134/" rel="alternate" type="text/html" title="8.2.3 slice 배열 일부 가져오기 - 사본" /><published>2020-05-08T00:23:00+09:00</published><updated>2020-05-08T00:23:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/08/javascript134</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/08/javascript134/">&lt;p&gt;배열의 일부만 가져올 때는 slice 메서드를 사용합니다.&lt;br /&gt;
slice 메서드는 &lt;strong&gt;매개변수 두 개&lt;/strong&gt;를 받습니다.&lt;br /&gt;
첫 번째 매개변수는 어디서부터 가져올지를,&lt;br /&gt;
두 번째 매개변수는 어디까지 가져올지를 &lt;strong&gt;(바로 앞 인덱스까지 가져옵니다)&lt;/strong&gt; 지정합니다.&lt;br /&gt;
두 번째 매개변수를 생략하면 배열의 마지막까지 반환합니다.&lt;br /&gt;
이 메서드에서는 음수 인덱스를 쓸 수 있고, 음수 인덱스를 쓰면 배열의 끝에서부터 요소를 셉니다.&lt;br /&gt;
예제를 봅시다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [4, 5]. arr은 바뀌지 않았습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [3, 4]. arr은 바뀌지 않았습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [4, 5]. arr은 바뀌지 않았습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [2, 3]. arr은 바뀌지 않았습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [4]. arr은 바뀌지 않았습니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">배열의 일부만 가져올 때는 slice 메서드를 사용합니다. slice 메서드는 매개변수 두 개를 받습니다. 첫 번째 매개변수는 어디서부터 가져올지를, 두 번째 매개변수는 어디까지 가져올지를 (바로 앞 인덱스까지 가져옵니다) 지정합니다. 두 번째 매개변수를 생략하면 배열의 마지막까지 반환합니다. 이 메서드에서는 음수 인덱스를 쓸 수 있고, 음수 인덱스를 쓰면 배열의 끝에서부터 요소를 셉니다. 예제를 봅시다. const arr = [1, 2, 3, 4, 5]; arr.slice(3); // [4, 5]. arr은 바뀌지 않았습니다. arr.slice(2, 4); // [3, 4]. arr은 바뀌지 않았습니다. arr.slice(-2); // [4, 5]. arr은 바뀌지 않았습니다. arr.slice(1, -2); // [2, 3]. arr은 바뀌지 않았습니다. arr.slice(-2, -1); // [4]. arr은 바뀌지 않았습니다.</summary></entry><entry><title type="html">8.2.2 concat 배열의 끝에 여러 요소 추가하기 - 사본</title><link href="http://localhost:4000/javascript/2020/05/08/javascript133/" rel="alternate" type="text/html" title="8.2.2 concat 배열의 끝에 여러 요소 추가하기 - 사본" /><published>2020-05-08T00:06:00+09:00</published><updated>2020-05-08T00:06:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/08/javascript133</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/08/javascript133/">&lt;p&gt;concat 메서드는 배열의 끝에 여러 요소를 추가한 사본을 반환합니다.&lt;br /&gt;
concat 에 배열을 넘기면 이 메서드는 배열을 분해해서 원래 배열에 추가한 사본을 반환합니다.&lt;br /&gt;
예제를 보십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;concat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// [1, 2, 3, 4, 5, 6]. arr은 바뀌지 않습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;concat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [1, 2, 3, 4, 5, 6]. arr은 바뀌지 않습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;concat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// [1, 2, 3, 4, 5, 6]. arr은 바뀌지 않습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;concat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [1, 2, 3, 4, [5, 6]]. arr은 바뀌지 않습니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image52.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;concat 은 제공받은 배열을 &lt;strong&gt;한 번만&lt;/strong&gt; 분해합니다.&lt;br /&gt;
배열 안에 있는 배열을 다시 분해하지는 않습니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">concat 메서드는 배열의 끝에 여러 요소를 추가한 사본을 반환합니다. concat 에 배열을 넘기면 이 메서드는 배열을 분해해서 원래 배열에 추가한 사본을 반환합니다. 예제를 보십시오. const arr = [1, 2, 3]; arr.concat(4, 5, 6); // [1, 2, 3, 4, 5, 6]. arr은 바뀌지 않습니다. arr.concat([4, 5, 6]); // [1, 2, 3, 4, 5, 6]. arr은 바뀌지 않습니다. arr.concat([4, 5], 6); // [1, 2, 3, 4, 5, 6]. arr은 바뀌지 않습니다. arr.concat([4, [5, 6]]); // [1, 2, 3, 4, [5, 6]]. arr은 바뀌지 않습니다. concat 은 제공받은 배열을 한 번만 분해합니다. 배열 안에 있는 배열을 다시 분해하지는 않습니다.</summary></entry><entry><title type="html">8.2.1 push, pop, shift, unshift 배열의 처음이나 끝에서 요소 하나를 추가하거나 제거하기 - 수정</title><link href="http://localhost:4000/javascript/2020/05/06/javascript132/" rel="alternate" type="text/html" title="8.2.1 push, pop, shift, unshift 배열의 처음이나 끝에서 요소 하나를 추가하거나 제거하기 - 수정" /><published>2020-05-06T14:05:00+09:00</published><updated>2020-05-06T14:05:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/06/javascript132</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/06/javascript132/">&lt;p&gt;배열의 &lt;strong&gt;처음&lt;/strong&gt;은 첫 번째 요소, 즉 인덱스가 0인 요소를 말합니다.&lt;br /&gt;
마찬가지로 배열의 &lt;strong&gt;끝&lt;/strong&gt;은 인덱스가 가장 큰 요소, 즉 배열이 arr이라면 arr.length - 1 인 요소를 말합니다.&lt;br /&gt;
push와 pop은 각각 배열의 끝에 요소를 추가하거나 제거합니다(&lt;strong&gt;수정&lt;/strong&gt;).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;역주_ 수정&lt;/strong&gt;
이 장에서 (수정)이라는 표현은 배열 자체를 수정한다는 뜻입니다.&lt;br /&gt;
(사본)이라는 표현은 원래 배열은 바뀌지 않고 변경된 내용을 반영한 새 배열을 반환한다는 뜻입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;shift 와 unshift 는 각각 배열의 처음에 요소를 제거하거나 추가합니다(수정).&lt;br /&gt;
push와 unshift는 새 요소를 추가해서 늘어난 길이를 반환하고, pop과 shift는 제거된 요소를 반환합니다.&lt;br /&gt;
다음은 이들 메서드의 예제입니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 4. arr은 이제 [&quot;b&quot;, &quot;c&quot;,  &quot;d&quot;, &quot;e&quot;] 입니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// &quot;e&quot;. arr은 이제 [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 입니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;unshift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 4. arr은 이제 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 입니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// &quot;a&quot;. arr은 이제 [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 입니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image51.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">배열의 처음은 첫 번째 요소, 즉 인덱스가 0인 요소를 말합니다. 마찬가지로 배열의 끝은 인덱스가 가장 큰 요소, 즉 배열이 arr이라면 arr.length - 1 인 요소를 말합니다. push와 pop은 각각 배열의 끝에 요소를 추가하거나 제거합니다(수정). 역주_ 수정 이 장에서 (수정)이라는 표현은 배열 자체를 수정한다는 뜻입니다. (사본)이라는 표현은 원래 배열은 바뀌지 않고 변경된 내용을 반영한 새 배열을 반환한다는 뜻입니다. shift 와 unshift 는 각각 배열의 처음에 요소를 제거하거나 추가합니다(수정). push와 unshift는 새 요소를 추가해서 늘어난 길이를 반환하고, pop과 shift는 제거된 요소를 반환합니다. 다음은 이들 메서드의 예제입니다. const arr = [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;]; arr.push(&quot;e&quot;); // 4. arr은 이제 [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;] 입니다. arr.pop(); // &quot;e&quot;. arr은 이제 [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 입니다. arr.unshift(&quot;a&quot;); // 4. arr은 이제 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 입니다. arr.shift(); // &quot;a&quot;. arr은 이제 [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 입니다.</summary></entry><entry><title type="html">8.2 배열 요소 조작</title><link href="http://localhost:4000/javascript/2020/05/06/javascript131/" rel="alternate" type="text/html" title="8.2 배열 요소 조작" /><published>2020-05-06T09:41:57+09:00</published><updated>2020-05-06T09:41:57+09:00</updated><id>http://localhost:4000/javascript/2020/05/06/javascript131</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/06/javascript131/">&lt;p&gt;메서드를 설명하기에 앞서, 자주 사용하는 &lt;strong&gt;배열 조작 메서드에 대해 짚고 넘어갈 점&lt;/strong&gt;이 있습니다.&lt;br /&gt;
애석하게도 배열 메서드 중 일부는 배열 &lt;strong&gt;‘자체를 수정&lt;/strong&gt;하며, 다른 일부는 &lt;strong&gt;새 배열을 반환&lt;/strong&gt;합니다.&lt;br /&gt;
예를 들어 push는 배열 자체를 수정하며, concat은 새 배열을 반환합니다.&lt;br /&gt;
메서드 이름에 이런 차이점에 대한 힌트가 전혀 없으므로 프로그래머가 전부 기억해야 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;NOTE_&lt;/strong&gt;&lt;br /&gt;
루비 같은 언어는 이름만 봐도 대상 자체를 수정하는지, 아니면 새로운 것을 반환하는지 알 수 있도록 만들어져 있습니다.&lt;br /&gt;
예를 들어 루비에서 문자열 str에서 str.downcase를 호출하면 소문자 버전이 반환되지만 str 자체는 바뀌지 않습니다.&lt;br /&gt;
반면 str.downcase! 를 호출하면 소문자 버전이 반환되지만 str 자체가 바뀝니다.&lt;br /&gt;
필자는 자바스크립트 표준 라이브러리에서 어떤 메서드가 데이터 자체를 수정하고 어떤 메서드가 사본을 반환하는지에 관한 아무런 단서도 제공하지 않는다는 점은 불필요한 기억을 강요하는 단점이라고 생각합니다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">메서드를 설명하기에 앞서, 자주 사용하는 배열 조작 메서드에 대해 짚고 넘어갈 점이 있습니다. 애석하게도 배열 메서드 중 일부는 배열 ‘자체를 수정하며, 다른 일부는 새 배열을 반환합니다. 예를 들어 push는 배열 자체를 수정하며, concat은 새 배열을 반환합니다. 메서드 이름에 이런 차이점에 대한 힌트가 전혀 없으므로 프로그래머가 전부 기억해야 합니다. NOTE_ 루비 같은 언어는 이름만 봐도 대상 자체를 수정하는지, 아니면 새로운 것을 반환하는지 알 수 있도록 만들어져 있습니다. 예를 들어 루비에서 문자열 str에서 str.downcase를 호출하면 소문자 버전이 반환되지만 str 자체는 바뀌지 않습니다. 반면 str.downcase! 를 호출하면 소문자 버전이 반환되지만 str 자체가 바뀝니다. 필자는 자바스크립트 표준 라이브러리에서 어떤 메서드가 데이터 자체를 수정하고 어떤 메서드가 사본을 반환하는지에 관한 아무런 단서도 제공하지 않는다는 점은 불필요한 기억을 강요하는 단점이라고 생각합니다.</summary></entry><entry><title type="html">8.1 배열의 기초</title><link href="http://localhost:4000/javascript/2020/05/05/javascript130/" rel="alternate" type="text/html" title="8.1 배열의 기초" /><published>2020-05-05T23:17:00+09:00</published><updated>2020-05-05T23:17:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/05/javascript130</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/05/javascript130/">&lt;p&gt;본격적으로 시작하기 전에 먼저 배열의 기본적인 사항을 다시 떠올려 봅시다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;배열은 객체와 달리 본질에서 순서가 있는 데이터 집합이며 0으로 시작하는 숫자형 인덱스를 사용합니다.&lt;/li&gt;
  &lt;li&gt;자바스크립트의 배열은 &lt;strong&gt;비균질적(nonhomogeneous)&lt;/strong&gt; 입니다. &lt;strong&gt;즉, 한 배열의 요소가 모두 같은 타입일 필요는 없습니다.&lt;/strong&gt; 배열은 다른 배열이나 객체도 포함할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;배열 리터럴은 대괄호로 만들고, 배열 요소에 인덱스로 접근할 때도 대괄호를 사용합니다.&lt;/li&gt;
  &lt;li&gt;모든 배열에는 요소가 몇 개 있는지 나타내는 length 프로퍼티가 있습니다.&lt;/li&gt;
  &lt;li&gt;배열에 배열 길이보다 큰 인덱스를 사용해서 요소를 할당하면 배열은 자동으로 그 인덱스에 맞게 늘어나며, 빈자리는 undefined로 채워집니다.&lt;/li&gt;
  &lt;li&gt;Array 생성자를 써서 배열을 만들 수도 있지만 그렇게 해야 하는 경우는 별로 없습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 장을 시작하기 전에, 지금까지 짚어 본 내용이 모두 익숙한지 확인하십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 배열 리터럴&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 숫자로 구성된 배열&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;one&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;three&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 비균질적 배열&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;one&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;three&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 배열을 포함한 배열&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Fred&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;luckyNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Susan&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Anthony&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
	&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;arrays can contain functions too&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
	&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;three&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 배열 요소에 접근하기&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [&quot;one&quot;, 2, &quot;three&quot;]&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// { name:&quot;Susan&quot;, type: &quot;object&quot; }&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 배열 길이&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 5&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 배열 길이 늘리기&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [1, 2, 3, undefined, 5]&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 5&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 배열의 현재 길이보다 큰 인덱스에 접근하는 것만으로 배열의 길이가 늘어나지는 않습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Array 생성자(거의 사용하지 않습니다)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 빈 배열&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// [1, 2, 3]&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 길이가 2인 배열. 요소는 모두 undefined 입니다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [&quot;2&quot;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image50.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">본격적으로 시작하기 전에 먼저 배열의 기본적인 사항을 다시 떠올려 봅시다. 배열은 객체와 달리 본질에서 순서가 있는 데이터 집합이며 0으로 시작하는 숫자형 인덱스를 사용합니다. 자바스크립트의 배열은 비균질적(nonhomogeneous) 입니다. 즉, 한 배열의 요소가 모두 같은 타입일 필요는 없습니다. 배열은 다른 배열이나 객체도 포함할 수 있습니다. 배열 리터럴은 대괄호로 만들고, 배열 요소에 인덱스로 접근할 때도 대괄호를 사용합니다. 모든 배열에는 요소가 몇 개 있는지 나타내는 length 프로퍼티가 있습니다. 배열에 배열 길이보다 큰 인덱스를 사용해서 요소를 할당하면 배열은 자동으로 그 인덱스에 맞게 늘어나며, 빈자리는 undefined로 채워집니다. Array 생성자를 써서 배열을 만들 수도 있지만 그렇게 해야 하는 경우는 별로 없습니다. 이 장을 시작하기 전에, 지금까지 짚어 본 내용이 모두 익숙한지 확인하십시오. // 배열 리터럴 const arr1 = [1, 2, 3]; // 숫자로 구성된 배열 const arr2 = [&quot;one&quot;, 2, &quot;three&quot;]; // 비균질적 배열 const arr3 = [[1, 2, 3], [&quot;one&quot;, 2, &quot;three&quot;]]; // 배열을 포함한 배열 const arr4 = [ { name: &quot;Fred&quot;, type: &quot;object&quot;, luckyNumbers: [5, 7, 13] }, [ { name: &quot;Susan&quot;, type: &quot;object&quot; }, { name: &quot;Anthony&quot;, type: &quot;object&quot; }, ], 1, function () { return &quot;arrays can contain functions too&quot;; }, &quot;three&quot;, ]; // 배열 요소에 접근하기 arr1[0]; // 1 arr1[2]; // 3 arr3[1]; // [&quot;one&quot;, 2, &quot;three&quot;] arr4[1][0]; // { name:&quot;Susan&quot;, type: &quot;object&quot; } // 배열 길이 arr1.length; // 3 arr4.length; // 5 arr4[1].length; // 2 arr4[0].length; // undefined // 배열 길이 늘리기 arr1[4] = 5; arr1; // [1, 2, 3, undefined, 5] arr1.length; // 5 // 배열의 현재 길이보다 큰 인덱스에 접근하는 것만으로 배열의 길이가 늘어나지는 않습니다. arr2[10]; // undefined arr2.length; // 3 // Array 생성자(거의 사용하지 않습니다) const arr5 = new Array(); // 빈 배열 const arr6 = new Array(1, 2, 3); // [1, 2, 3] const arr7 = new Array(2); // 길이가 2인 배열. 요소는 모두 undefined 입니다. const arr8 = new Array(&quot;2&quot;); // [&quot;2&quot;]</summary></entry><entry><title type="html">8. 배열과 배열 처리</title><link href="http://localhost:4000/javascript/2020/05/05/javascript129/" rel="alternate" type="text/html" title="8. 배열과 배열 처리" /><published>2020-05-05T23:13:12+09:00</published><updated>2020-05-05T23:13:12+09:00</updated><id>http://localhost:4000/javascript/2020/05/05/javascript129</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/05/javascript129/">&lt;p&gt;자바스크립트의 배열 메서드는 필자가 가장 좋아하는 기능 중 하나입니다.&lt;br /&gt;
프로그래밍을 하다보면 데이터 집합을 조작해야 할 일이 정말 많습니다.&lt;br /&gt;
자바스크립트의 배열 메서드에 익숙해지면 이런 작업을 쉽게 처리할 수 있고 자바스크립트 개발 능력이 한 단계 올라갈 겁니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">자바스크립트의 배열 메서드는 필자가 가장 좋아하는 기능 중 하나입니다. 프로그래밍을 하다보면 데이터 집합을 조작해야 할 일이 정말 많습니다. 자바스크립트의 배열 메서드에 익숙해지면 이런 작업을 쉽게 처리할 수 있고 자바스크립트 개발 능력이 한 단계 올라갈 겁니다.</summary></entry><entry><title type="html">7.12 요약</title><link href="http://localhost:4000/javascript/2020/05/05/javascript128/" rel="alternate" type="text/html" title="7.12 요약" /><published>2020-05-05T19:17:00+09:00</published><updated>2020-05-05T19:17:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/05/javascript128</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/05/javascript128/">&lt;p&gt;어떤 프로그래밍 언어에서든 스코프는 반드시 이해해야 할 중요한 부분입니다.&lt;br /&gt;
자바스크립트는 let을 도입하면서 대부분의 최신 언어와 비슷하게 동작하게 됐습니다.&lt;br /&gt;
&lt;strong&gt;자바스크립트가 &lt;span style=&quot;color:red;&quot;&gt;클로저&lt;/span&gt;를 지원한 첫 번째 언어는 아니지만, 실무에서 널리 쓰이는 언어 중에서는 매우 빨리 지원한 편&lt;/strong&gt;입니다.&lt;br /&gt;
&lt;strong&gt;자바스크립트 개발자들은 클로저를 아주 유용하게 사용하고 있으며, 클로저는 최신 자바스크립트 개발에서 중요한 위치를 차지하고 있습니다.&lt;/strong&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">어떤 프로그래밍 언어에서든 스코프는 반드시 이해해야 할 중요한 부분입니다. 자바스크립트는 let을 도입하면서 대부분의 최신 언어와 비슷하게 동작하게 됐습니다. 자바스크립트가 클로저를 지원한 첫 번째 언어는 아니지만, 실무에서 널리 쓰이는 언어 중에서는 매우 빨리 지원한 편입니다. 자바스크립트 개발자들은 클로저를 아주 유용하게 사용하고 있으며, 클로저는 최신 자바스크립트 개발에서 중요한 위치를 차지하고 있습니다.</summary></entry><entry><title type="html">7.11 스트릭트 모드</title><link href="http://localhost:4000/javascript/2020/05/05/javascript127/" rel="alternate" type="text/html" title="7.11 스트릭트 모드" /><published>2020-05-05T19:08:00+09:00</published><updated>2020-05-05T19:08:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/05/javascript127</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/05/javascript127/">&lt;p&gt;ES5 문법에서는 &lt;strong&gt;암시적 전역 변수(implicit global)&lt;/strong&gt; 라는 것이 생길 수 있었습니다.&lt;br /&gt;
암시적 전역 변수는 여러 가지 골치 아픈 에러를 일으키곤 했습니다.&lt;br /&gt;
간단히 말해 var로 변수를 선언하는 것을 잊으면 자바스크립트는 전역 변수를 참조하려 한다고 간주하고, 그런 전역 변수가 존재하지 않으면 스스로 만들었습니다.&lt;br /&gt;
수많은 문제가 발생할 것은 불 보듯 뻔한 일입니다.&lt;/p&gt;

&lt;p&gt;이런 이유로 자바스크립트에서는 &lt;strong&gt;스트릭트 모드(strict mode)&lt;/strong&gt; 를 도입했습니다.&lt;br /&gt;
&lt;strong&gt;스트릭트 모드에서는 암시적 전역 변수를 허용하지 않습니다.&lt;/strong&gt;&lt;br /&gt;
스트릭트 모드를 사용하려면 문자열 &lt;strong&gt;“use strict”&lt;/strong&gt;(작은 따옴표를 써도 됩니다) 하나만으로 이루어진 행을 코드 맨 앞에 쓰면 됩니다.&lt;br /&gt;
전역 스코프에서 “use strict”를 사용하면 스크립트 전체가 스트릭트 모드로 실행되고, 함수 안에서 “use strict”를 사용하면 해당 함수만 스트릭트 모드로 실행됩니다.&lt;/p&gt;

&lt;p&gt;전역 스코프에 스트릭트 모드를 적용하면 스크립트 전체의 동작 방식이 바뀌므로 주의해야합니다.&lt;br /&gt;
&lt;strong&gt;최신 웹사이트는 대부분 다양한 스크립트를 불러와서 사용하므로 전역 스코프에서 스트릭트 모드를 사용하면 불러온 스크립트 전체에 스트릭트 모드가 강제됩니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;모든 스크립트가 스트릭트 모드에서 정확히 동작한다면 멋진 일이겠지만 바라기 힘든 일&lt;/strong&gt;입니다.&lt;br /&gt;
&lt;strong&gt;따라서 일반적으로는 전역 스코프에서 스트릭트 모드를 사용하지 않는 편이 좋습니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;작성하는 함수 하나하나마다 전부 “use strict”를 붙이고 싶은 사람은 없을 테니, 코드 전체를 &lt;span style=&quot;color:red;&quot;&gt;즉시 실행되는 함수&lt;/span&gt; 하나로 감싸면 됩니다.&lt;/strong&gt;&lt;br /&gt;
이에 관해서는 13장에서 다시 설명할 겁니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;use strict&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	
	&lt;span class=&quot;c1&quot;&gt;// 코드를 전부 이 안에 작성합니다.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 이 코드는 스트릭트 모드로 동작하지만,&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 이 코드와 함께 동작하는 다른 스크립트는&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 스트릭트 모드에 영향받지 않습니다.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스트릭트 모드는 대부분의 경우에 바람직하므로 필자는 스트릭트 모드를 권합니다.&lt;br /&gt;
&lt;strong&gt;린트 프로그램을 사용한다면 스트릭트 모드가 막아주는 문제를 대부분 막아주지만, 두 번 체크해서 나쁠 것은 전혀 없습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;스트릭트 모드에 대해 더 자세히 알고 싶다면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN 문서&lt;/a&gt;를 보십시오.&lt;/p&gt;</content><author><name></name></author><summary type="html">ES5 문법에서는 암시적 전역 변수(implicit global) 라는 것이 생길 수 있었습니다. 암시적 전역 변수는 여러 가지 골치 아픈 에러를 일으키곤 했습니다. 간단히 말해 var로 변수를 선언하는 것을 잊으면 자바스크립트는 전역 변수를 참조하려 한다고 간주하고, 그런 전역 변수가 존재하지 않으면 스스로 만들었습니다. 수많은 문제가 발생할 것은 불 보듯 뻔한 일입니다. 이런 이유로 자바스크립트에서는 스트릭트 모드(strict mode) 를 도입했습니다. 스트릭트 모드에서는 암시적 전역 변수를 허용하지 않습니다. 스트릭트 모드를 사용하려면 문자열 “use strict”(작은 따옴표를 써도 됩니다) 하나만으로 이루어진 행을 코드 맨 앞에 쓰면 됩니다. 전역 스코프에서 “use strict”를 사용하면 스크립트 전체가 스트릭트 모드로 실행되고, 함수 안에서 “use strict”를 사용하면 해당 함수만 스트릭트 모드로 실행됩니다. 전역 스코프에 스트릭트 모드를 적용하면 스크립트 전체의 동작 방식이 바뀌므로 주의해야합니다. 최신 웹사이트는 대부분 다양한 스크립트를 불러와서 사용하므로 전역 스코프에서 스트릭트 모드를 사용하면 불러온 스크립트 전체에 스트릭트 모드가 강제됩니다. 모든 스크립트가 스트릭트 모드에서 정확히 동작한다면 멋진 일이겠지만 바라기 힘든 일입니다. 따라서 일반적으로는 전역 스코프에서 스트릭트 모드를 사용하지 않는 편이 좋습니다. 작성하는 함수 하나하나마다 전부 “use strict”를 붙이고 싶은 사람은 없을 테니, 코드 전체를 즉시 실행되는 함수 하나로 감싸면 됩니다. 이에 관해서는 13장에서 다시 설명할 겁니다. (function () { 'use strict'; // 코드를 전부 이 안에 작성합니다. // 이 코드는 스트릭트 모드로 동작하지만, // 이 코드와 함께 동작하는 다른 스크립트는 // 스트릭트 모드에 영향받지 않습니다. })() 스트릭트 모드는 대부분의 경우에 바람직하므로 필자는 스트릭트 모드를 권합니다. 린트 프로그램을 사용한다면 스트릭트 모드가 막아주는 문제를 대부분 막아주지만, 두 번 체크해서 나쁠 것은 전혀 없습니다. 스트릭트 모드에 대해 더 자세히 알고 싶다면 MDN 문서를 보십시오.</summary></entry><entry><title type="html">7.10 사각지대</title><link href="http://localhost:4000/javascript/2020/05/05/javascript126/" rel="alternate" type="text/html" title="7.10 사각지대" /><published>2020-05-05T18:49:00+09:00</published><updated>2020-05-05T18:49:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/05/javascript126</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/05/javascript126/">&lt;p&gt;&lt;strong&gt;사각지대(temporal dead zone)&lt;/strong&gt; 란, let으로 선언하는 변수는 선언하기 전까지 존재하지 않는다는 직관적 개념을 잘 나타내는 표현입니다.&lt;br /&gt;
스코프 안에서 변수의 사각지대는 변수가 선언되기 전의 코드입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;변수를 선언하기 전에 사용할 일은 거의 없으므로 사각지대에 빠질 일도 거의 없지만, ES6 이전의 자바스크립트에 익숙한 사람이라면 주의해야할 경우가 하나 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;typeof 연산자는 변수가 선언됐는지 알아볼 때 널리 쓰이고, 존재를 확인하는 안전한 방법으로 알려져 있습니다.&lt;br /&gt;
즉, let 키워드가 도입되고 변수의 사각지대가 생기기 전에는 다음과 같은 코드는 항상 안전하며 에러가 발생하지도 않았습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;x doesn't exist or is undefined&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// x를 사용해도 안전한 코드&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 이 코드를 let으로 변수 선언하면 안전하지 않습니다.&lt;br /&gt;
다음 코드에서는 에러가 발생합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;x doesn't exist or is undefined&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// x를 사용해도 안전한 코드&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ES6에서는 typeof 연산자로 변수가 정의됐는지 확인할 필요가 거의 없으므로 typeof가 문제를 일으킬 소지도 거의 없습니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">사각지대(temporal dead zone) 란, let으로 선언하는 변수는 선언하기 전까지 존재하지 않는다는 직관적 개념을 잘 나타내는 표현입니다. 스코프 안에서 변수의 사각지대는 변수가 선언되기 전의 코드입니다. 변수를 선언하기 전에 사용할 일은 거의 없으므로 사각지대에 빠질 일도 거의 없지만, ES6 이전의 자바스크립트에 익숙한 사람이라면 주의해야할 경우가 하나 있습니다. typeof 연산자는 변수가 선언됐는지 알아볼 때 널리 쓰이고, 존재를 확인하는 안전한 방법으로 알려져 있습니다. 즉, let 키워드가 도입되고 변수의 사각지대가 생기기 전에는 다음과 같은 코드는 항상 안전하며 에러가 발생하지도 않았습니다. if (typeof x === &quot;undefined&quot;) { console.log(&quot;x doesn't exist or is undefined&quot;); } else { // x를 사용해도 안전한 코드 } 하지만 이 코드를 let으로 변수 선언하면 안전하지 않습니다. 다음 코드에서는 에러가 발생합니다. if (typeof x === &quot;undefined&quot;) { console.log(&quot;x doesn't exist or is undefined&quot;); } else { // x를 사용해도 안전한 코드 } let x = 5; ES6에서는 typeof 연산자로 변수가 정의됐는지 확인할 필요가 거의 없으므로 typeof가 문제를 일으킬 소지도 거의 없습니다.</summary></entry></feed>