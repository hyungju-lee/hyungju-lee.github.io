<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LEE HYUNG JU</title>
    <description>Jekyll Blog</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 27 Sep 2020 19:13:14 +0900</pubDate>
    <lastBuildDate>Sun, 27 Sep 2020 19:13:14 +0900</lastBuildDate>
    <generator>Jekyll v4.0.1</generator>
    
      <item>
        <title>전문가가되기 위해 마스터해야하는 36 가지 JavaScript 개념</title>
        <description>&lt;h2 id=&quot;전문가가되기-위해-마스터해야하는-36-가지-javascript-개념&quot;&gt;전문가가되기 위해 마스터해야하는 36 가지 JavaScript 개념&lt;/h2&gt;

&lt;p&gt;많은 사람들이 자바스크립트가 이상하고 때로는 가치가 없다고 불평하는 것을 듣게 될 것입니다.&lt;br /&gt;
사람들은 내부에서 일이 어떻게 작동하느지 이해하지 못하기 때문에 이렇게 불평합니다.&lt;br /&gt;
자바스크립트의 일부 시나리오가 다르게 처리된다는데 동의하지만, 그것은 이상하게 만드는 것이 아니라 그 자체로 아름답습니다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어를 사랑하기 시작하려면 먼저 깊이 살펴보고 그 개념을 하나씩 마스터해야 합니다.&lt;br /&gt;
다음은 만능 자바스크립트 전문가가되기위해 마스터해야하는 36가지 자바스크립트 개념 목록입니다.&lt;/p&gt;

&lt;p&gt;이 작품은 내 가장 긴 작품 중 하나이지만 시간을 내기에 합당하다는 것을 확신합니다.&lt;br /&gt;
리소스에 대한 Stephen과 Leonardo에게 찬사를 보냅니다.&lt;/p&gt;

&lt;p&gt;리소스 섹션에는 Leonardo의 Github 저장소에 대한 링크가 포함되어 있으며 아래에 설명된 이러한 모든 개념에 대한 학습 자료가 포함되어 있습니다.&lt;br /&gt;
아래에 언급된 각 개념을 이해하는데 시간을 할애하십시오.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/leonardomso/33-js-concepts&quot; target=&quot;_blank&quot;&gt;학습링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-call-stack-execution-호출-스텍-실행&quot;&gt;1. Call Stack Execution (호출 스텍 실행)&lt;/h2&gt;

&lt;p&gt;누구나 웹 사이트 Stack overflow에 대해 들어봤을 것입니다.&lt;br /&gt;
&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;그러나 실제 Stack overflow를 알고 있습니까?&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;Stack overflow는 호출 스택 작업과 관련된 오류입니다.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;호출 스택을 이해하면 자바스크립트와 같은 고급 언어가 실행되는 방식에 대한 실무 지식을 갖게됩니다.&lt;/p&gt;

&lt;h3 id=&quot;1-1-자바스크립트-함수-실행-이해---호출스택-이벤트-루프-작업-등&quot;&gt;1-1. 자바스크립트 함수 실행 이해 - 호출스택, 이벤트 루프, 작업 등&lt;/h3&gt;

&lt;p&gt;우리가 흔히 불려왔던 웹 개발자 또는 프론트엔드 엔지니어들은 요즘 모든 것을 한다.&lt;br /&gt;
컴퓨터 게임을 만들기 위한 브라우저의 인터렉티브한 코드부터 시작해서,&lt;br /&gt;
데스크톱 위젯, 크로스 플랫폼 모바일 앱, 그리고 데이터베이스에 연결하기위한 서버사이드에서 작동하는(제일 유명한 노드js) 코드까지 작성한다.&lt;/p&gt;

&lt;p&gt;이렇게 자바스크립트는 스크립팅 언어로서 거의 모든 곳에서 사용되고 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;따라서 자바스크립트의 내부에 대해 알고 더 효율적이고 효과적으로 사용하는 것이 중요하며 이것이 이번 글의 주제이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;자바스크립트 생태계는 그 어느 때보다 복잡해졌고 앞으로도 계속될 것이다.&lt;br /&gt;
최신 웹, 앱을 구축하는데 필요한 도구는 &lt;strong&gt;Webpack, Babel, ESLint, Mocha, Karma, Grunt…&lt;/strong&gt; 등으로 압도적이다.&lt;/p&gt;

&lt;p&gt;무엇을 사용해야할까? 당신은 어떤 도구를 사용하고 있나?&lt;/p&gt;

&lt;p&gt;오늘날 웹 개발자들의 투쟁을 완벽하게 보여주는 웹 만화를 찾았다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;만화 내용&lt;/strong&gt;&lt;br /&gt;
A : 나 고기가 먹고싶은데, 그냥 먹으면 될까?&lt;br /&gt;
B : 안돼! 불을 사용해서 요리해서 먹어!&lt;br /&gt;
A : 불은 뜨겁잖아! 내 손까지 익으면 어떻게해?&lt;br /&gt;
B : 뾰족한 막대기를 사용해서 요리하던지, 아니면 돌을 달궈서 그 위에 고기를 얹어서 익히던지, 아니면 박스 안에 불을 지펴!&lt;br /&gt;
A : 선택사항이 너무 많잖아, 거기서 내가 뭘 선택해야돼?&lt;br /&gt;
B : 모르지.&lt;br /&gt;
…&lt;br /&gt;
…&lt;br /&gt;
A : 오! 고기가 익었어, 나 지금 먹어도 되지?&lt;br /&gt;
B : 안되지! 기다려! 소금이랑 향신료를 뿌려야지!&lt;br /&gt;
A : … 고기를 먹기위해 불로 요리하고, 요리될 때까지 기다리고, 바위에 향신료까지 필요해? 난 단지 날것으로 먹으면 땡인데? 멍청해!&lt;br /&gt;
B : …&lt;/p&gt;

  &lt;p&gt;개발자 : 이러한 이유로 현대 자바스크립트가 너무 복잡하다고 생각해..&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-Javascript Fatique : 자바스크립트를 배울때 느낌-&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위와 같은 모든 것을 일단 제외해야된다.&lt;br /&gt;
자바스크립트 개발자가 개발할 때 프레임워크나 라이브러리를 사용하기 전에 먼저 해야할 일은 이 모든 것이 루트 수준에서 내부적으로 수행되는 방법의 기본 기반을 아는 것이다.&lt;br /&gt;
원론적인 내용을 알아야된다.&lt;/p&gt;

&lt;p&gt;대부분의 자바스크립트 개발자는 크롬의 런타임인 V8이라는 용어를 들어봤을지 모르지만, 그게 무슨뜻인지 모를 것이다.&lt;br /&gt;
나는 신입 때 결과물을 만들어내는 거에 집중하느라 이러한 모든 멋진 개념에 대해 많이 알지 못했다.&lt;br /&gt;
그것은 이 헬 같은 자바스크립트가 모든 일을 어떻게 할 수 있는지에 대한 나의 궁금증을 충족시키지 못한 원인이었다.&lt;/p&gt;

&lt;p&gt;나는 구글을 뒤지면서 자바스크립트에 대해 더 깊이 파고들기로 결심했고, 
이벤트 루프에 대한 JSConf의 훌륭한 강연, 그리고 Philip Roberts를 포함하여 좋은 게시물 몇 개를 발견했다.&lt;br /&gt;
그래서 난 배운 내용을 요약하고 공유하기로 결정했다.&lt;/p&gt;

&lt;p&gt;알아야 할 것이 많기 때문에 기사를 두 부분으로 나누었다.&lt;br /&gt;
이 부분에서는 일반적으로 사용되는 용어를 소개하고 두 번째 부분에서는 모든 용어를 연결하면서 설명하도록 하겠다.&lt;/p&gt;

&lt;h3 id=&quot;필립-로버츠의-이벤트-루프-강의&quot;&gt;필립 로버츠의 이벤트 루프 강의&lt;/h3&gt;

&lt;p&gt;자바스크립트의 이벤트 루프가 도대체 무엇일까요.&lt;br /&gt;
자바스크립트라는 것은 실제로 어떻게 작동할까요? 정확히 이해하고 있는 사람 있을까요?&lt;br /&gt;
V8 이라는 단어는 들어봤지만, 크롬의 런타임에 대해서는 정확히 무엇을 의미하는지 몰랐습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;싱글 스레드라고 했는데, 분명 난 콜백을 사용하고 있다…? 뭘까?&lt;/strong&gt;&lt;br /&gt;
콜백은 실제로 어떻게 작동하는 걸까?&lt;br /&gt;
그래서 난 열심히 읽고, 조사하고, 실제 브라우저에서 실험하는 일련의 여정을 시작했습니다.&lt;/p&gt;

&lt;p&gt;이렇게요.&lt;br /&gt;
“자바스크립트 넌 도대체 뭐니?”&lt;br /&gt;
대답은 이랬죠.&lt;br /&gt;
“저는 싱글스레드 논 블로킹 비동기 동적 언어입니다.”&lt;/p&gt;

&lt;p&gt;음.. 좋아. “저는 콜스택과 이벤트 루프, 콜백 큐 그리고 API나 뭐 그런 것들을 가지고 있어요”&lt;br /&gt;
… 음.. 좋아. 저는 컴퓨터 전공자가 아닙니다.&lt;br /&gt;
그러다보니 이런 것들은 그냥 단어에 지나지 않았어요.&lt;br /&gt;
V8이나 런타임, 다양한 브라우저를 들어보긴 했었죠.&lt;br /&gt;
그래서 V8에게 너도 콜스택, 이벤트루프, 콜백 큐, 뭐 그런것들을 가지고 있냐고 물어봤더니, 이렇게 대답하더군요.&lt;/p&gt;

&lt;p&gt;“제가 콜스태과 힙을 가지고 있긴한데.. 다른건 도대체 뭡니까?”&lt;/p&gt;

&lt;p&gt;좋아. 재밌군.. 뭐 그렇게 18개월을 보냈고, 이제 꽤 이해했다는 생각이 들었습니다.&lt;br /&gt;
이것이 제가 오늘 발표할 내용입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;처음 접하는 분들에게 자바스크립트는 다른 언어와 비교하여 왜 이렇게 이상하고 콜백이라는 것이 종종 지옥을 만들면서도 왜 중요하고 꼭 필요한지 
이해하시는데 도움이 되었으면 합니다.&lt;br /&gt;
한편으로 자바스크립트에 익숙한 분들에게는 자바스크립트 런타임에 대해 다시한번 생각하는 기회가 되었으면 좋겠네요.&lt;br /&gt;
크롬의 V8 같은 실제 자바스크립트 런타임을 들여다 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image02.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이건 자바스크립트 런타임을 단순화해본 것인데요, 메모리 할당이 일어나는 힙과 콜스택이 보입니다.&lt;br /&gt;
그런데 V8 프로젝트를 클론해서 코드 베이스를 들여다 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;setTimeout&lt;/code&gt;이나 &lt;code class=&quot;highlighter-rouge&quot;&gt;DOM&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP 요청&lt;/code&gt;을 관리하는 코드들은 찾아볼 수 없습니다.&lt;br /&gt;
놀라웠어요.&lt;br /&gt;
비동기 코딩에서 가장 먼저 생각하는 것들이잖아요?&lt;br /&gt;
그런데 V8 소스에 그런 내용은 없죠.&lt;br /&gt;
재밌네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image03.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;18개월 동안의 조사 끝에 만들어낸 이 그림이 사실 제가 오늘 전달하고 이해를 도우려 하는 것들입니다.&lt;br /&gt;
그림을 보시면 V8 런타임과 브라우저가 제공하는 웹 API가 있습니다.&lt;br /&gt;
브라우저는 DOM, AJAX, setTimeout 등과 함께 그 유명한 event loop와 콜백 큐를 가지고 있습니다.&lt;br /&gt;
아마 단어들은 많이 들어보셨을 거에요.&lt;/p&gt;

&lt;p&gt;하지만, 이것들이 어떤식으로 연결되어 움직이는지는 정확하게 이해하시는 분들이 많지 않을 겁니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image04.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그래서 저는 어떤 분들에게는 새롭고 어떤 분들에게는 그렇지 않겠지만, 최대한 빠르게 기본적인 것부터 짚어가겠습니다.&lt;br /&gt;
잘 아시는 분들은 잠시만 참아주세요.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;자바스크립트는 싱글 스레드 프로그래밍 언어입니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;싱글 스레드 런타임&lt;/strong&gt;을 가지고 있다는 말인데 이것은 결국 한번에 하나의 싱글 콜스택만을 가지고 있다는 말입니다.&lt;br /&gt;
그게 싱글 스레드의 의미겠죠.&lt;br /&gt;
하나의 프로그램은 동시에 하나의 코드만 실행할 수 있다는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image05.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그럼 이걸 시각화해서 무엇을 의미하는지 살펴보겠습니다.&lt;br /&gt;
왼쪽 코드를 보시면, 함수가 몇 개 보입니다.&lt;br /&gt;
두 수를 곱해주는 multiply 라는 함수, multiply 함수를 호출하여 같은 수를 곱하는 square(제곱) 함수, 
한 숫자를 받아서 square 함수를 호출한 뒤 결과를 console.log 로 보여주는 함수도 있습니다.&lt;br /&gt;
그리고 맨 마지막에는 제곱을 보여주는 printSquare 를 호출하고 있네요.&lt;br /&gt;
다들 이해하실 겁니다.&lt;/p&gt;

&lt;p&gt;쉽죠?&lt;br /&gt;
좋습니다.&lt;br /&gt;
이제 이 함수를 실행시켜보죠.&lt;br /&gt;
죄송합니다.&lt;br /&gt;
설명을 빠트린 것이 있네요.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;콜 스텍은 데이터 스트럭처로 실행되는 순서를 기억하고 있습니다.&lt;/strong&gt;&lt;br /&gt;
함수를 실행하려면 스택에 해당하는 함수를 집어넣게 되는데 함수에서 리턴이 일어나면 스택의 가장 위쪽에서 해당 함수를 꺼내게 됩니다.&lt;br /&gt;
이게 콜 스택이 하는 일의 전부죠.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;이 코드를 실행하면 실행되는 코드 자체를 말하는 메인 함수를 스택에 집어넣게 됩니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/static/img/script/image06.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그러면 이제 함수들을 정의하게 됩니다. 현재 우리가 가지고 있는 것들을 정의한다고 볼 수 있겠네요.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/static/img/script/image07.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그리고 마지막에 가서 printSquare를 만나게 됩니다. printSquare(4)는 함수 호출이니, 스택에 함수를 추가합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/static/img/script/image08.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그러면 바로 printSquare를 호출하게 되겠네요. 스택에 printSquare가 추가되고,&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/static/img/script/image09.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그러면 바로 square를 호출하게 되겠네요. 스택에 square가 추가되고,&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/static/img/script/image10.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이제 square는 multiply를 호출합니다. 이제 리턴절을 만나서 a와 b를 곱한 결과를 반환합니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/static/img/script/image11.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;무엇인가를 리턴할 때마다 우리는 스택 맨 위에 있는 것을 꺼내게 됩니다. multiply에서 square로 리턴되고,&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/static/img/script/image12.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다시 printSquare 까지 돌아옵니다. console.log를 실행하겠네요. 여기에 리턴은 보이지않지만, 암묵적으로 리턴합니다.&lt;br /&gt;
함수의 마지막 줄에 도달했기 때문이죠. 자 이제 다 끝났습니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/static/img/script/image13.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image14.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image15.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이것이 바로 콜스택입니다.&lt;br /&gt;
이해가 되셨나요?&lt;br /&gt;
콜 스택을 그림으로 그려보시지 않았다고 하더라도 브라우저에서 개발을 하시다보면 어느정도 이해하셨을거라고 생각합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image16.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image17.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;baz가 호출하는 함수 bar, 그리고 bar가 호출하는 foo 함수가 위와같이 에러를 만들게 된다면, 크롬 개발자 도구에서는 이런식으로 스택의 꼬리를 물면서 Oops! 를 표시하게 될겁니다.&lt;br /&gt;
에러가 발생한 스택의 상태를 보여주는 것이죠.&lt;br /&gt;
&lt;strong&gt;uncaught error&lt;/strong&gt;는 foo 에서 생겼는데 bar가 호출했고 bar는 또 baz에게서.. 이런식으로 익명함수 즉 &lt;strong&gt;main 함수&lt;/strong&gt;까지 올라가게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image18.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;스택을 날려먹었다는 용어를 들어보셨나요?&lt;/strong&gt;&lt;br /&gt;
좋은 예시 하나를 보여드리려고 합니다.&lt;br /&gt;
foo 함수를 호출하는 foo 함수가 있다면 어떻게 될까요?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;main 함수가 foo를 호출합니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;foo 함수는 foo 함수를 호출하는 foo 함수를 호출하는 foo 함수를 호출하게 되죠…&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/static/img/script/image19.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그리고 크롬이 이렇게 말하죠. “스스로를 호출하는 foo 함수를 16,000번이나 계속하신건 아니겠죠?” &lt;br /&gt;
“이 녀석들을 중지 시킬게요. 버그를 고쳐주세요.” 그렇겠죠?&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/static/img/script/image20.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;콜 스택이라는 측면을 설명하고 있긴 하지만, 이 역시 개발하시다보면 이미 겪어 보셨을 겁니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;그럼 이제 중요한 질문이 생깁니다. 느려진다는 것은 어떤 것인가?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image21.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;블로킹 혹은 블로킹 현상에 대해서 이야기하긴 하지만, &lt;strong&gt;블로킹이라는 것에 대한 정확한 정의는 존재하지 않습니다. 그저 느리게 동작하는 코드일 뿐입니다.&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;console.log&lt;/code&gt; 자체는 느리지 않습니다.&lt;br /&gt;
하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;while 루프&lt;/code&gt; 안에서 수십억번 실행된다면 느리겠죠.&lt;br /&gt;
네트워크 요청이나 이미지 프로세싱은 느립니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;느린 동작이 스택에 남아있는 것을 보통 블로킹이라고 말하게 됩니다.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를 하나 들어보겠습니다.&lt;br /&gt;
이런 코드가 있다고 가정해보죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image22.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동기적으로 AJAX 요청을 보내는 jQuery 함수 getSync가 있다고 한다면, 어떤식으로 동작하게 될까요?&lt;br /&gt;
일단 비동기 콜백은 잊어버리세요.&lt;br /&gt;
동기적으로 작동한다고 생각해봅시다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;이 코드를 한줄한줄 실행해보죠. getSync를 호출하면 응답을 기다리게 됩니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/static/img/script/image23.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image24.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;네트워크 요청은 컴퓨터 입장에서는 꽤 느립니다.&lt;br /&gt;
성공했다고 간주하겠습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그러면 다음 줄로 넘어가고 다시 기다립니다. 넘어가고 기다리고. 넘어가고 기다리고.&lt;br /&gt;
안 끝날 수도 있죠. 하지만 끝났다고 가정해보죠. 이 세가지 행동이 드디어 다 끝났습니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/static/img/script/image25.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image26.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이제 스택을 지울 수 있겠네요.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/static/img/script/image27.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image28.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image29.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;프로그래밍 언어에서 싱글 스레드라고 하는 것은 &lt;strong&gt;루비 같은 언어와는 달리 여러 개의 스레드를 사용하지 않는다는 의미입니다.&lt;/strong&gt;&lt;br /&gt;
네트워크 요청을 하고는 마냥 끝날때까지 기다립니다.&lt;br /&gt;
그거 말고는 방법도 없어요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image30.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;문제가 뭐냐고요?&lt;br /&gt;
웹 브라우저에서 코드가 실행되고 있기 때문입니다.&lt;br /&gt;
자 이제 그럼… 잠시만요, 크롬 브라우저를 실행시켰습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getSync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;//foo.com&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getSync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;//bar.com&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;qux&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getSync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;//qux.com&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;qux&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드를 실행시켜볼건데요, 브라우저는 실제로 ajax 요청을 동기적으로 실행시키지 않습니다.&lt;br /&gt;
그래서 저는 이걸 동기적으로 실행하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;while 루프&lt;/code&gt; 안에 넣고 5초 동안 가상으로 동작하는 코드를 만들었습니다.&lt;br /&gt;
콘솔을 열면 실제로 무엇이 일어나는지 볼 수 있겠네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image31.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;foo.com에 요청을 하고 있는 동안 아무것도 클릭할 수 없습니다.&lt;br /&gt;
왜 그런걸까요?&lt;br /&gt;
좀 전에 클릭한 Run 버튼조차 리-렌더링을 끝내지 못했네요.&lt;br /&gt;
브라우저가 멈췄어요.&lt;br /&gt;
브라우저는 모든 리퀘스트가 완료될 때까지 멈춰있을 겁니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image32.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 나서는 이런 심각한 문제들이 나타납니다.&lt;br /&gt;
멈춰있는 동안 행동을 기억하고 있었지만 그릴 수, 렌더링할 수 없었습니다.&lt;br /&gt;
아무것도 할 수 없었죠.&lt;br /&gt;
왜냐하면 콜스택에 어떤 것들이 남아 있으면… 오, 아직도 뭔가 실행하네요.&lt;br /&gt;
&lt;strong&gt;동기적으로 실행되는 네트워크 요청이 콜 스택을 블로킹하여 브라우저는 다른 일들을 할 수 없었습니다.&lt;/strong&gt;&lt;br /&gt;
렌더링이나 다른 코드를 실행하지 못하고 그냥 멈춰버렸죠.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;별로네요, 유려한 UI를 만들려고 한다면, 콜스택을 멈추게 해서는 안되겠죠.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image33.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러면 어떻게 해결해야 할까요?&lt;br /&gt;
제일 쉽게 접할 수 있는 건 &lt;strong&gt;비동기 콜백&lt;/strong&gt;입니다.&lt;br /&gt;
&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;브라우저 혹은 노드에는 블로킹 함수가 거의 없습니다.&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;
대부분 비동기로 만들어졌죠.&lt;br /&gt;
&lt;strong&gt;이는 어떤 코드를 실행하면 결국 콜백을 받고 이걸 나중에 실행한다는 말입니다.&lt;/strong&gt;&lt;br /&gt;
자바스크립트를 해보셨다면 비동기 콜백들은 다들 경험해보실겁니다.&lt;/p&gt;

&lt;p&gt;그러면 이것들은 실제로 어떤식으로 실행될까요?&lt;br /&gt;
예를 들어보겠습니다.&lt;br /&gt;
이런 코드가 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Hi&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;There&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;JSConfEU&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;setTimeout을 사용하여 console.log로 There를 출력하도록하면 console.log는 큐에 등록되고 JSConf를 먼저 출력합니다.&lt;br /&gt;
5초 뒤에 There를 찍게 됩니다.&lt;br /&gt;
그렇죠?&lt;/p&gt;

&lt;p&gt;이렇게 setTimeout이 뭔가를 실행하고 있습니다.&lt;br /&gt;
그러면서 지금까지 다뤄왔던 스택상에서는 어떻게 실행되는 것일까요?&lt;br /&gt;
console.log hi를 출력하고 setTimeout을 실행합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image34.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image35.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image34.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아시다시피 바로 실행되지 않습니다.&lt;br /&gt;
5초 안에 실행되겠죠.&lt;br /&gt;
&lt;strong&gt;스택에 추가되지 않고, 어떻게인지는 모르겠지만 그냥 사라져버립니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;아직 설명할 방법이 없네요.&lt;/strong&gt;&lt;br /&gt;
곧 알게 될겁니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image36.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음 JSConfEU를 출력합니다.&lt;br /&gt;
그리고 5초 후, 마법처럼 console.log(‘There’)가 스택에 나타납니다.&lt;br /&gt;
이떻게 된걸까요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image37.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image38.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image39.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기에서 이벤트 루프와 동시성이 역할을 하게 됩니다.&lt;br /&gt;
&lt;strong&gt;저는 자바스크립트는 한번에 하나의 일만 할 수 있다고 이야기했습니다. 거짓말일까요?&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;물론 사실입니다. 자바스크립트는 한번에 하나밖에 할 수 없습니다.&lt;/strong&gt;&lt;br /&gt;
자바스크립트는 다른 코드를 실행시키는 동안 Ajax 요청을 실행할 수 없습니다.&lt;br /&gt;
setTimeout 역시 마찬가지죠.&lt;/p&gt;

&lt;p&gt;하지만 우리가 이걸 동시에 할 수 있는 이유는 브라우저는 단순 런타임 이상을 의미하기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image03.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 그림이 기억나시나요?&lt;br /&gt;
자바스크립트 런타임은 한번에 하나만 할 수 있습니다.&lt;br /&gt;
하지만 브라우저가 Web API와 같은 것들을 제공하죠.&lt;br /&gt;
&lt;strong&gt;이들은 자바스크립트에서 호출할 수 있는 스레드를 효과적으로 지원합니다.&lt;/strong&gt;&lt;br /&gt;
여기서 &lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;동시성&lt;/span&gt;&lt;/strong&gt;이 들어오는 것이죠.&lt;/p&gt;

&lt;p&gt;백엔드 개발자시라면, Web API 대신 C++ API를 사용할 뿐이지, Node 또한 다르지 않습니다.&lt;br /&gt;
C++가 숨기고 있죠.&lt;br /&gt;
이제 좀 더 브라우저란 무엇인가를 보여주는 그림을 보면서 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image40.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이전과 같습니다.&lt;br /&gt;
코드를 실행하면 console 창에 Hi를 출력합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image41.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;hi를 로깅하죠. 단순합니다. 이제 setTimeout을 호출해서 어떤일이 일어나는지 확인해 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image42.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image43.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 콜백 함수와 지연시간을 setTimeout 콜에 넘겨보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image44.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;setTimeout은 브라우저에서 제공하는 API입니다.&lt;br /&gt;
V8 소스코드에 존재하지 않다는걸 기억하시나요?
자바스크립트가 실행되는 런타임 환경에 존재하는 별도의 API입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image45.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image46.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;브라우저가 타이머를 실행시키고 카운트 다운을 시작합니다.&lt;br /&gt;
이건 setTimeout 호출 자체는 완료되었다는 의미고 우리는 스택에서 함수를 지울 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image47.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image48.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JSConfEU를 출력하고 다시 지워집니다.&lt;br /&gt;
이제 Web API에서 실행하고 있는 타이머가 남았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image49.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image50.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5초 뒤에 타이머가 종료되겠죠. Web API는 갑자기 작성된 코드에 끼여들 순 없습니다.&lt;br /&gt;
어느 순간 갑자기 스택에 함수를 집어넣던가 하는 것 말이죠.&lt;br /&gt;
&lt;strong&gt;이제 테스크 큐와 콜백 큐가 활약할 차례입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image51.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모든 Web API는 작동이 완료되면 콜백을 테스크 큐에 밀어넣습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image52.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;드디어 이 발표의 제목이기도 한 &lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;이벤트 루프&lt;/span&gt;&lt;/strong&gt;에 다달았습니다.&lt;br /&gt;
&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;이벤트 루프&lt;/span&gt;&lt;/strong&gt;란 무엇일까요?&lt;br /&gt;
이벤트 루프는 이 전체 시스템에서 아주 단순한 일을 하는 작은 파트입니다.&lt;br /&gt;
이벤트 루프의 역할은 콜스택과 테스크 큐를 주시하는 것입니다.&lt;br /&gt;
스택이 비어있으면, 큐의 첫번째 콜백을 스택에 쌓아 효과적으로 실행할 수 있게 해줍니다.&lt;br /&gt;
보시는 바와 같이 스택이 비어있고, 테스크 큐에는 콜백이 하나 있네요.&lt;br /&gt;
이벤트 루프는 “어, 내가 할 일이 있네, 자 이거 받아”하며 콜백을 스택에 넣어줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image53.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스택은 자바스크립트 영지라는 걸 기억하세요.&lt;br /&gt;
이제 V8 엔진으로 돌아가서 console.log(‘there’)를 실행합니다.&lt;br /&gt;
이해가 되시나요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image54.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image55.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;좋습니다.&lt;br /&gt;
이제 여러분들은 자바스크립트 비동기 함수가 어떤식으로 동작하는지 아시게 되었을 겁니다.&lt;br /&gt;
특히 무엇인가 알수없는 문제가 생겼을 때 setTimeout 0을 사용하면 해결될거야 라고 말하는 상황 말이죠.&lt;br /&gt;
음.. 함수를 0초 후에 실행하라고?&lt;br /&gt;
그럼 setTimeout 자체를 왜 하라는건데?&lt;br /&gt;
저와 비슷한 분들은 그러셨을 겁니다.&lt;br /&gt;
되긴 되는 것 같은데, 왜 그런지 모르겠다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;일반적으로 이것은 스택이 비어있을 때까지 기다리게 하기 위해서입니다.&lt;/strong&gt;&lt;br /&gt;
자바스크립트를 직접 작성해서 실행해보시면 동일한 결과를 얻으실 수 있을 겁니다.&lt;br /&gt;
“hi”, “JSConfEU” 그리고 마지막에 “there”가 개발자 콘솔에 나타날겁니다.&lt;br /&gt;
이 코드를 실행해보면서, 작동원리를 알아보죠.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;there&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;JSConfEU&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;“hi”를 프린트하고, setTimeout 0이 실행되면 Web API는 바로 종료하고 큐에 콜백을 집어넣습니다.&lt;br /&gt;
이벤트 루프에 대한 것을 기억하시죠?&lt;br /&gt;
이벤트 루프는 스택이 비워질때까지 기다린 후에 큐에 있는 콜백을 스택에 쌓을 수 있습니다.&lt;br /&gt;
스택은 계속해서 실행을 합니다.&lt;br /&gt;
console.log(‘JSConfEU’)를 실행하고 스택이 정리됩니다.&lt;br /&gt;
이제 &lt;strong&gt;이벤트 루프가 개입하여, 콜백을 호출합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이것이 setTimeout 0이 코드 실행을 어떤 이유에선가 스택에 마지막까지 지연시키는 이유입니다.&lt;br /&gt;
정확히는 스택이 비워질때까지겠죠.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;모든 이런 종류의 Web API는 동일한 방식으로 동작합니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;Ajax Request는 URL로 호출할 때 콜백을 함께 실행하게 됩니다.&lt;/strong&gt;&lt;br /&gt;
역시 동일하게 작동하게 되죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image56.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;console.log(‘hi’)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image57.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음 AJAX 요청을 하고 AJAX 요청은 자바스크립트 런타임이 아니라, 브라우저 Web API에서 실행됩니다.&lt;br /&gt;
이제 XHR Web API가 실행되는 동안 다른 코드는 정상적으로 실행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image58.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image59.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image60.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;XHR 요청이 끝날때까지, 끝나지 않을 수도 있습니다.&lt;br /&gt;
그래도 상관없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image61.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스택은 계속해서 코드를 실행할 수 있습니다.&lt;br /&gt;
XHR 실행이 완료되었다면 콜백은 큐에 쌓이게 되고,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image62.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이벤트 루프에 의해서 실행됩니다.&lt;br /&gt;
이 과정이 비동기 함수가 호출되는 방식입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image63.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/script/image64.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;자, 그럼 진짜 복잡한 예제를 실행해보죠.&lt;br /&gt;
잘 실행되면 좋겠네요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image65.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여러분이 눈치 채셨는지 모르겠지만, 이 모든건 키노트로 작성되었습니다.&lt;br /&gt;
그래서 여기에 500개의 애니메이션을..&lt;/p&gt;

&lt;p&gt;(대충 슬라이드 반을 날렸는데, 다시 만들기 빡세서 다른 예제로 대체한다는 내용)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image66.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Started&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Clicked&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;onTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Timeout Finished&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;addEventListener, setTimeout 등을 기준으로 shim을 해서 콘솔에 보여주는 겁니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;console.log(‘Started’)가 콜스텍에 쌓인다.&lt;/li&gt;
  &lt;li&gt;콘솔창에 Started를 찍고 콜스텍에서 console.log(‘Started’)는 없어진다. (동기적)&lt;/li&gt;
  &lt;li&gt;$.on(‘button’, ‘click’, …)이 콜스텍에 쌓인다.&lt;/li&gt;
  &lt;li&gt;그리고 Web APIs로 보내진다.&lt;/li&gt;
  &lt;li&gt;그 다음엔 setTimeout이 콜스텍에 쌓인다.&lt;/li&gt;
  &lt;li&gt;setTimeout의 콜백펑션인 timeout이 Web APIs로 보내지고 시간을 체크한다.&lt;/li&gt;
  &lt;li&gt;console.log(‘Done’)이 콜 스텍에 쌓인 후 Done을 콘솔창에 찍은 후 콜스텍에서 제거된다.&lt;/li&gt;
  &lt;li&gt;Web APIs의 시칸체크가 끝나면 setTimeout의 콜백함수가 테스크 큐에 들어간다.&lt;/li&gt;
  &lt;li&gt;이벤트 루프가 콜스텍에 쌓인 스텍이 아무것도 없으면 테스크 큐에 쌓여있는 콜백함수를 콜스택으로 넘긴다.&lt;/li&gt;
  &lt;li&gt;setTimeout의 콜백함수 안의 console.log(‘Timeout Finished’)가 콜스텍에 더 쌓인다.&lt;/li&gt;
  &lt;li&gt;그리고 콘솔창에 Timeout Finished를 찍고 제거된다.&lt;/li&gt;
  &lt;li&gt;setTimeout의 콜백함수도 콜스텍에서 제거된다.&lt;/li&gt;
  &lt;li&gt;버튼을 클릭하면 Web APIs에 있던 버튼 클릭시 실행되는 콜백함수가 테스크 큐로 넘어가고,&lt;/li&gt;
  &lt;li&gt;이벤트 루프가 이를 콜스택으로 넘깁니다.&lt;/li&gt;
  &lt;li&gt;그 후에 클릭시 실행되어야하는 콜백함수가 호출하는 console.log(‘Clicked’)도 콜스텍에 쌓입니다.&lt;/li&gt;
  &lt;li&gt;Clicked를 콘솔창에 찍은 후 console.log(‘Clicked’)는 제거되고, 이를 불러왔던 콜백함수(onClick)도 콜스텍에서 사라진다.&lt;/li&gt;
  &lt;li&gt;만약 클릭을 100번연속한다면, 클릭으로 인해 실행되어야 하는 콜백함수는 테스크큐에 쌓이고, 콜백함수 하나씩 하나씩 이벤트 루프를 통해 
콜스텍으로 넘어간 후 실행된다.&lt;br /&gt;
콜스텍에서 실행되고 스텍이 다 없어져야 다시 콜백함수가 이벤트루프를 통해 넘어간다.&lt;br /&gt;
클릭하면 그 함수는 곧바로 실행되는게 아니고, 큐에 쌓인 후, 그 후에 차례대로 처리됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D&quot; target=&quot;_blank&quot;&gt;이벤트 루프 예시사이트&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;또 다른 예시들도 보여드릴게요.&lt;br /&gt;
실제로 맞닥뜨리실만한 상황들이지만, &lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;여러분이 Async API와 관련해서 생각하시지 못했을 부분들에 대해 말씀드릴게요.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 1분 딜레이가 설정된 setTimeout을 4번 호출하고, hi를 콘솔에 찍는다면 콜백이 큐에 쌓인 후 네번째 콜백이 1초후에 실행되어야 함에도 불구, 그러지 않고 여전히 실행되지 않고 있다는 것을 알 수 있다.&lt;br /&gt;
&lt;strong&gt;이걸 보면 timeout(콜백펑션)이 실제로 정해진 시간과는 달리 제대로 작동하지 않을 수도 있고 다만 딜레이되는 최소의 시간만을 지정할 수 있다는 것을 알 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;마치 0초로 설정된 코드가 바로 실행되지 않는 것 처럼요.&lt;/strong&gt;&lt;br /&gt;
대신 차례를 기다린 후 실행되죠.&lt;br /&gt;
그렇죠?&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// synchronous&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// asynchronous&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;asyncForEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;asyncForEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 예시에서는 콜백에 대해서 더 이야기하려고 합니다.&lt;br /&gt;
누구에게 물어보느냐에 따라 다르지만, 콜백은 둘 중에 하나로 묘사됩니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;하나는 콜백은 다른 함수가 부르는 함수이다.&lt;/li&gt;
  &lt;li&gt;혹은 앞으로 큐에 쌓일 비동기식 콜백이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이라고 묘사할 수 있죠.&lt;br /&gt;
여기 이 코드가 그러한 차이의 예시인데, &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;forEach&lt;/code&gt; 함수의 경우, 함수를 실행시키기는 합니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;콜백이라고 할 수는 있지만, 비동기적으로 실행하지는 않죠.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;자신의 자체적 스택에서 실행시킵니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;한편 asyncForEach를 하나 선언해서 배열과 콜백을 받아 각 요소에서 setTimeout을 0으로 실행하는 것도 가능합니다.&lt;br /&gt;
값을 하나 넘겨야할 것 같지만… 어쨌든, 실행을 한번 해보고 다른점이 무엇인지 보죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image67.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;첫번째 블록의 경우, 스택을 차지합니다.&lt;br /&gt;
그렇죠?&lt;br /&gt;
실행이 다 끝날 때까지요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image68.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;반대로 비동기 버전은 여러개의 콜백을 큐에 쌓을거고, 스택이 비워지면 실제로 쌓이 콜백들이 실행되게 되죠.&lt;br /&gt;
&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;이 예시에서는 콘솔 함수가 금방 실행되서 async의 이점이 잘 드러나지 않지만, 여러분이 각 배열 요소에 대해 
오래 걸리는 처리를 해야한다고 치면,&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// synchronous&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;processing sync&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// asynchronous&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;asyncForEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;asyncForEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;processing async&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;식을 위와 같이 바꾸고, 아래처럼 따라 해보세요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/script/image69.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실제 브라우저 repaint 혹은 렌더링 상황을 재연하는 기능인데,(체크하세요.)&lt;br /&gt;
제가 아직 이러한 것들이 렌더링과는 어떤 관계가 있는지 충분히 설명하지 않았는데,&lt;br /&gt;
&lt;strong&gt;브라우저는 여러분이 자바스크립트로 하는 무언가로 인해 제약을 받습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;브라우저는 기본적으로 화면을 매 16.6 밀리세컨드, 즉 1초에 60 프레임을 repaint하는 게 이상적입니다.&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;
그게 제일 빠른 거죠.&lt;br /&gt;
하지만 브라우저는 &lt;strong&gt;여러분이 자바스크립트로 하는 것들로 인해 여러가지 이유로 제약을 받습니다.&lt;/strong&gt;&lt;br /&gt;
그래서 &lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;스택에 코드가 있으면, 렌더링을 못합니다.&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;렌더도 하나의 콜백처럼 행동하니까요.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;스택이 비워질 때까지 기다려야 하는 겁니다.&lt;br /&gt;
다른 점이라면, 렌더는 &lt;strong&gt;여러분의 콜백에 비해 더 높은 우선순위를 갖죠&lt;/strong&gt;&lt;br /&gt;
매 16ms 마다 큐에 렌더가 들어가고, 스택이 깨끗해진 후에야 렌더링을 합니다.&lt;/p&gt;

&lt;p&gt;그래서 위 렌더 큐가 그 렌더링을 재연한거에요.&lt;br /&gt;
그래서 매 초마다 ‘렌더해도 될까?’ ‘그래’ 하는 식으로, 지금 아무 것도 없기 때문에 진행이 되죠.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;하지만 제가 코드를 실행하면, 우리가 이 느린 동기식 루프를 진행하는동안 렌더는 막히게 됩니다.(블락킹)&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;렌더가 막히면, 화면의 텍스트를 선택하거나 선택해서 반응을 보거나 하는 게 불가능하죠.&lt;/strong&gt;&lt;br /&gt;
이전에 보여드린 예시처럼, 이 예시에서는.. 지금 우리가 async timeout을 큐에 쌓는 동안 스택이 쌓이지만, 상대적으로 빨리 사라지고는 있죠.&lt;br /&gt;
&lt;strong&gt;이때 우리는 렌더에게 각 요소 중간중간에, 렌더가 끼어들 수 있는 기회를 줄 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
큐가 async를 통해 쌓였으니까요.&lt;/p&gt;

&lt;p&gt;모두 이해되시나요?&lt;/p&gt;

&lt;p&gt;즉, 이게 렌더링을 재연한 것입니다.&lt;br /&gt;
&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;사람들이 event loop를 막지 말라고 할 때, 바로 이런 현상을 뜻하는 것이죠.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;스택에 필요없는 느린 코드를 쌓아서 브라우저가 할 일을 못하게 만들지 말아라, 유동적인 UI를 만들어라.&lt;/strong&gt;&lt;br /&gt;
이것이 이미지 처리나 애니메이션이 너무 잦아졌을 때 큐 관리에 주의를 기울이지 않으면 이런 일이 일어나니까요.&lt;br /&gt;
예를 들어서, &lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;스크롤 핸들러&lt;/span&gt;&lt;/strong&gt;를 이용해서,.. 스크롤 이벤트는 DOM에서 매우 자주 일어나죠.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;animateSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;scroll&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;animateSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스크롤이 매 프레임에서 매 15ms마다 작동한다고 짐작했을 때, 위 코드를 작성해봤습니다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;document.scroll&lt;/code&gt;이 일어날 때 애니메이션을 넣거나 무언가를 하죠.&lt;br /&gt;
이 코드상으론 제가 스크롤을 할 때마다, &lt;strong&gt;큐에 엄청나게 많은 콜백을 쌓습니다.&lt;/strong&gt;&lt;br /&gt;
그리고 매번 이걸 처리하면서 각각의 느린 프로세싱이 일어날 때마다, 스택을 채우지는 않지만 &lt;strong&gt;큐를 이벤트로 범람시키죠.&lt;/strong&gt;&lt;br /&gt;
그래서 이것을 통해, 제 생각엔, 여러분이 실제로 이 많은 콜백을 작동시킬 때 어떤 일이 일어나는지 눈으로 보고 어떤식으로 대처할지,&lt;br /&gt;
&lt;strong&gt;예를 들어 큐에 이벤트가 쌓이는 것은 어쩔 수 없지만, 매 몇초마다 혹은 유저가 스크롤을 멈출 때까지 작업량을 줄인다든지 하는 결정을 내릴 수 있겠죠.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;제가 준비한 것은 여기까지입니다.&lt;br /&gt;
이것에 관련된 다른 토론들도 아주 많아요.&lt;br /&gt;
코드를 실행할 때, 예를 들어 이 코드는 런타임에서 실행되는데,&lt;br /&gt;
제가 Esprima(자바스크립트 parser)로 이걸 실행하고 매 코드 앞뒤로 while 루프를 실행해서 0.5초씩 걸리게 한다면, 
모든 코드를 슬로우 모션으로 실행해요.&lt;/p&gt;

&lt;p&gt;이걸 웹 워커로 옮기고 이런저런걸 해서 시각화 시키면, 런타임에서 어떤 일이 일어나는지 알 수 있습니다.&lt;br /&gt;
또 다른 많은 이야기를 할 수 있죠.&lt;/p&gt;
</description>
        <pubDate>Sat, 26 Sep 2020 18:48:00 +0900</pubDate>
        <link>http://localhost:4000/js/2020/09/26/javascript.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2020/09/26/javascript.html</guid>
        
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>sprites handlebars 반올림 설정 round, ceil, floor</title>
        <description>&lt;h2 id=&quot;round-ceil-floor&quot;&gt;round, ceil, floor&lt;/h2&gt;

&lt;p&gt;자동으로 계산되어나오는 값에 반올림, 올림, 내림을 하고 싶다면 위 단어들을 적용해주면 된다.&lt;br /&gt;
아래는 그 예시 파일이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/hyungju-lee/private-hj/blob/master/private/round-handlebars/spritesmith-mixins.handlebars&quot; target=&quot;_blank&quot;&gt;예시링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 26 Sep 2020 18:43:00 +0900</pubDate>
        <link>http://localhost:4000/node_module/2020/09/26/module3.html</link>
        <guid isPermaLink="true">http://localhost:4000/node_module/2020/09/26/module3.html</guid>
        
        
        <category>node_module</category>
        
      </item>
    
      <item>
        <title>gulp-imagemin 모듈 옵션설명</title>
        <description>&lt;h2 id=&quot;gulp-imagemin-모듈-옵션설명&quot;&gt;gulp-imagemin 모듈 옵션설명&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/imagemin/imagemin-optipng&quot; target=&quot;_blank&quot;&gt;참고링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 26 Sep 2020 18:38:00 +0900</pubDate>
        <link>http://localhost:4000/node_module/2020/09/26/module2.html</link>
        <guid isPermaLink="true">http://localhost:4000/node_module/2020/09/26/module2.html</guid>
        
        
        <category>node_module</category>
        
      </item>
    
      <item>
        <title>gulp-pngquant 모듈 에러</title>
        <description>&lt;h2 id=&quot;gulp-pngquant-모듈-에러&quot;&gt;gulp-pngquant 모듈 에러&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/module/image07.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가끔 위와 같은 오류가 날 때가 있다.&lt;br /&gt;
해당 모듈을 지우고 다시 설치해도 동일한 에러가 발생한다.&lt;br /&gt;
이 에러가 지속되면 gulp 테스크를 수행하지 못하게 된다.&lt;/p&gt;

&lt;h3 id=&quot;원인&quot;&gt;원인&lt;/h3&gt;

&lt;p&gt;노드 모듈의 문제가 아니라 빌드 툴에 문제가 있어 발생하는 현상이다.&lt;/p&gt;

&lt;h3 id=&quot;해결방법&quot;&gt;해결방법&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;탐색기에서 &lt;strong&gt;C:\Users(PC 사용자이름)&lt;/strong&gt;으로 이동한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;.windows-build-tools&lt;/strong&gt;의 파일을 확인한다.&lt;/li&gt;
  &lt;li&gt;파일이 이미 있는 경우라면 지워준다.&lt;/li&gt;
  &lt;li&gt;하단의 첨부파일 &lt;strong&gt;BuildTools_Full.exe를 실행하여 재설치를 해서 파일을 교체&lt;/strong&gt;한다.&lt;/li&gt;
  &lt;li&gt;그러면 &lt;strong&gt;pngquant 에러&lt;/strong&gt;가 발생하지 않는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/static/img/module/BuildTools_Full.zip&quot;&gt;첨부파일&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/imagemin/imagemin-pngquant/issues/46#issuecomment-515808859&quot; target=&quot;_blank&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 26 Sep 2020 18:31:00 +0900</pubDate>
        <link>http://localhost:4000/node_module/2020/09/26/module.html</link>
        <guid isPermaLink="true">http://localhost:4000/node_module/2020/09/26/module.html</guid>
        
        
        <category>node_module</category>
        
      </item>
    
      <item>
        <title>윈도우, 맥 로컬서버 외부 기기에서 쉽게 접속하는 방법</title>
        <description>&lt;h2 id=&quot;윈도우-맥-로컬서버-외부-기기에서-쉽게-접속하는-방법&quot;&gt;윈도우, 맥 로컬서버 외부 기기에서 쉽게 접속하는 방법&lt;/h2&gt;

&lt;h3 id=&quot;ngrok-프로그램-활용&quot;&gt;ngrok 프로그램 활용&lt;/h3&gt;

&lt;p&gt;웹사이트나 API 서버 등을 개발할 때 보통은 로컬에 개발환경이 구축되어있으므로 외부에서 접근하려면 외부에서 접속할 수 있는 서버에 올리거나 해야한다.&lt;br /&gt;
이는 일반적인 개발 단계이기는 하지만 배포단계가 아닌 개발단계에서 외부에 열어주어야 하는 경우에는 상당히 귀찮은 일이다.&lt;br /&gt;
예를 들어 만들고 있는 웹사이트를 기획자나 디자이너한테 공유해서 보여주고 의견을 들어야 한다거나 폰이나 태블릿에서 접속해서 테스트를 해보아야 하는데 같은 
네트워크에 접속되어 있지 않다면 수정하고 배포하는 단계가 아주 귀찮아지기 마련이다.&lt;/p&gt;

&lt;h3 id=&quot;ngrok&quot;&gt;ngrok&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://ngrok.com/&quot; target=&quot;_blank&quot;&gt;ngrok&lt;/a&gt; 사이트에는 &lt;strong&gt;Secure tunnels to localhost&lt;/strong&gt;라고 나와있는데, 새로운 개념이라기보다는 
방화벽을 넘어서 외부에서 로컬에 접속 가능하게 하는 터널 프로그램이라고 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;사용방법&quot;&gt;사용방법&lt;/h3&gt;

&lt;p&gt;해당 프로그램은 Mac / Window 모두 지원한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;우선 window 설치방법부터 설명하도록 하겠다.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;다운로드&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/static/img/issue/image02.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;다운로드받은 압축파일을 더블클릭하여 압축을 푼다.&lt;/li&gt;
  &lt;li&gt;압축푼 파일을 더블클릭하여 실행한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다음을 명령어를 실행한다.&lt;/p&gt;

    &lt;p&gt;이 명령을 실행하면 기본 ngrok.yml 구성 파일에 authtoken이 추가됩니다.&lt;br /&gt;
이렇게하면 더 많은 기능과 더 긴 세션 시간에 액세스 할 수 있습니다.&lt;br /&gt;
실행중인 터널은 대시 보드의 상태 페이지에 나열됩니다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./ngrok authtoken 1hykNFRQ62516cun1cbHuK6Oxj1_83cFQuoGa8CwzTAx99jQJ
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서버를 실행하기 위해 다음과 같은 명령어를 입력한다.&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./ngrok http &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;외부접속가능하게할 포트번호&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;여기서 중요한 점은 포트번호를 현재 열려있는 그리고 외부기기로 접속해서 보고싶은 로컬서버 포트번호와 일치시켜야된다는 점이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Mac은 다음과 같이 설치하면 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;압축해제 명령어&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unzip /path/to/ngrok.zip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;나머진 window와 동일하다.&lt;/p&gt;
</description>
        <pubDate>Fri, 25 Sep 2020 17:06:00 +0900</pubDate>
        <link>http://localhost:4000/issue/2020/09/25/issue3.html</link>
        <guid isPermaLink="true">http://localhost:4000/issue/2020/09/25/issue3.html</guid>
        
        
        <category>issue</category>
        
      </item>
    
      <item>
        <title>업무 - grunt 옛날 레포</title>
        <description>&lt;h2 id=&quot;업무---grunt-옛날-레포&quot;&gt;업무 - grunt 옛날 레포&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://rubyinstaller.org/downloads/&quot; target=&quot;_blank&quot;&gt;Ruby 설치&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;ftp://ftp.graphicsmagick.org/pub/GraphicsMagick/windows/&quot; target=&quot;_blank&quot;&gt;GraphicsMagick 설치 - Image resizer 플러그인을 실행하기 위함&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;bash 창을 열어 아래와 같은 순서대로 진행
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;sass
gem &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;compass
npm i &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; grunt-cli bower
// &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; 여기까지는 grunt 최초 설치시에만 진행
npm &lt;span class=&quot;nb&quot;&gt;install
&lt;/span&gt;bower &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 25 Sep 2020 17:03:00 +0900</pubDate>
        <link>http://localhost:4000/issue/2020/09/25/issue2.html</link>
        <guid isPermaLink="true">http://localhost:4000/issue/2020/09/25/issue2.html</guid>
        
        
        <category>issue</category>
        
      </item>
    
      <item>
        <title>iphone iOS click</title>
        <description>&lt;h2 id=&quot;iphone-ios-click&quot;&gt;iphone iOS click&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://techoi.github.io/posts/ios-click-event-issue&quot; target=&quot;_blank&quot;&gt;iOS 고유 클릭 이벤트 이슈 및 해결방법&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 글의 내용을 간추리면 아래와 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;iOS 개발자들이 의도적으로 발생시킨 현상이다.&lt;/li&gt;
  &lt;li&gt;그 이유는 사용자가 페이지를 스크롤 할 어떠한 원인으로 click 이벤트가 발생할지 모르기 때문이다.&lt;br /&gt;
즉, 사용자가 의도하지 않은 click 이벤트가 많이 발생할 수 있다는 말이다.&lt;/li&gt;
  &lt;li&gt;그렇기 때문에 브라우저에 과부하를 줄 수 있다. 이를 방지하고자 이러한 현상을 의도적으로 넣었다.&lt;/li&gt;
  &lt;li&gt;이러한 이슈가 보고된해가 2010년이다. 그럼에도 불구하고 현재까지 수정 안하는 것은 iOS 개발자들이 일부로 의도했다는 증거이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html&quot; target=&quot;_blank&quot;&gt;2010년 아이폰 click event delegation에 대한글&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;여기까지가 위 포스트 글쓴이의 추측이다. 이래서 iOS 개발자들이 의도적으로 노린 것 같다는 내용이다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://theme.co/forum/t/button-and-link-problem-on-safari-mobile-iphone/24627&quot; target=&quot;_blank&quot;&gt;Button and link problem on Safari mobile (iphone)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 글을 읽어보면 정확한 원인은 모르겠다고 한다.&lt;br /&gt;
여튼 2010년에 이슈라이징되어서 지금까지 해결안된 이슈는 맞는 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;무튼 위 내용들로 이 내용이 진짜인가 테스트 해봤다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;우선-어제-태스트-내용&quot;&gt;우선 어제 태스트 내용&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;세번째 main-section 위에 button 태그가 위치하면 처음 클릭시 이벤트가 바로 인식되어 콜백함수 실행&lt;/li&gt;
  &lt;li&gt;세번째 main-section 안 또는 아래 button 태그가 위치하면 처음 클릭시 클릭이벤트가 발생하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;위-내용들을-바탕으로-세운-가설&quot;&gt;위 내용들을 바탕으로 세운 가설&lt;/h3&gt;

&lt;p&gt;위 글 내용들이 진짜라면, 그리고 위의 현상을 종합해보면&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;스크롤이 많이 되었을시 &lt;strong&gt;(당연히 터치이벤트, 클릭이벤트가 많이 발생했을 것이다.)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;iOS는 의도적으로 button 태그의 click 이벤트를 off한다. &lt;strong&gt;(여기서 중요한 점은 터치이벤트는 off하지 않는다는 점이다. 그래서 터치관련 이벤트를 넣으면 바로 작동하는 것 같다.)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;그래서 첫번째 button 터치(or클릭)를 하면 바로 click 이벤트가 발생 안한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;–&amp;gt; 그렇다면 스크롤을 많이 할때마다 해당 버튼의 처음 클릭은 인식이 안되어야 합니다. or 안되는 경우가 많아야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;가설을-입증하기-위한-테스트&quot;&gt;가설을 입증하기 위한 테스트&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;아이폰으로 해당 현상이 발생하는 페이지 접속한다.&lt;/li&gt;
  &lt;li&gt;스크롤을 내려서 버튼을 클릭해 처음에 click 이벤트를 인식하는지 확인한다. 두번째 클릭하면 당연히 인식할 것이다.&lt;/li&gt;
  &lt;li&gt;다시 스크롤을 많이 한다.&lt;/li&gt;
  &lt;li&gt;다시 해당 버튼으로 돌아가 클릭해본다. 처음 클릭 이벤트를 인식못할수도 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;결론&quot;&gt;결론&lt;/h3&gt;

&lt;p&gt;위의 내용처럼 iOS에서 의도된 동작같다.&lt;br /&gt;
아니면 여전히 10년째 해결하지 못한 버그같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;추가로 이 페이지말고도 다른 페이지에서 이런 현상이 많이 발생했었다. (생각해보니..)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 25 Sep 2020 13:56:00 +0900</pubDate>
        <link>http://localhost:4000/issue/2020/09/25/issue.html</link>
        <guid isPermaLink="true">http://localhost:4000/issue/2020/09/25/issue.html</guid>
        
        
        <category>issue</category>
        
      </item>
    
      <item>
        <title>svn cleanup 에러</title>
        <description>&lt;h2 id=&quot;svn-cleanup-에러&quot;&gt;svn cleanup 에러&lt;/h2&gt;

&lt;p&gt;업데이트 등의 어떤 액션을 하다가 실패를 해서(정상적인 종료가 안되어서) lock이 걸리는 경우가 있다.&lt;br /&gt;
cleanup 액션은 비정상적으로 SVN의 액션이 종료되었을 때 이것을 정리해주는 명령어이다.&lt;br /&gt;
이렇게 하면 Revert한 것처럼 수정된 파일도 커밋하기전의 원래 파일로 돌아온다.&lt;/p&gt;

&lt;p&gt;참고 : 에러메시지가 하라는 대로하면 해결되는 경우가 대부분이다.&lt;/p&gt;
</description>
        <pubDate>Wed, 23 Sep 2020 23:07:00 +0900</pubDate>
        <link>http://localhost:4000/svn/2020/09/23/svn2.html</link>
        <guid isPermaLink="true">http://localhost:4000/svn/2020/09/23/svn2.html</guid>
        
        
        <category>svn</category>
        
      </item>
    
      <item>
        <title>svn 계정설정</title>
        <description>&lt;h2 id=&quot;svn-계정설정&quot;&gt;svn 계정설정&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.naver.com/PostView.nhn?blogId=chudu&amp;amp;logNo=221509141567&quot; target=&quot;_blank&quot;&gt;링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;svn tortoise가 설치되어 있어야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;우클릭&lt;/li&gt;
  &lt;li&gt;tortoiseSVN&lt;/li&gt;
  &lt;li&gt;settings&lt;/li&gt;
  &lt;li&gt;권한 계정 클리어&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/svn/image00.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;현재 TortoiseSVN 사용버전은 1.9.5이다.&lt;br /&gt;
한글 언어팩을 설치하면 한글로 나온다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/svn/image01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사용자 인증정보를 변경하는 방법은 간단하다.&lt;br /&gt;
폴더에서 마우스 오른쪽 버튼을 누른 후 TortoiseSVN에 settings 버튼을 누르면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/svn/image02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저장된 데이터 메뉴를 누른 후 오른쪽 인증 정보의 버튼 중, 지우기 또는 모두 지우기를 눌러준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/svn/image03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;삭제할 인증정보를 체크하고 확인을 눌러준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/svn/image04.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/static/img/svn/image05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저장소 브라우저로 들어가게되면~!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/svn/image06.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사용자 계정을 새로 등록할 수 있는 팝업이 뜬다.&lt;br /&gt;
사용자명과 암호를 입력하면 접속이 되는 것을 확인할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Wed, 23 Sep 2020 23:00:00 +0900</pubDate>
        <link>http://localhost:4000/svn/2020/09/23/svn.html</link>
        <guid isPermaLink="true">http://localhost:4000/svn/2020/09/23/svn.html</guid>
        
        
        <category>svn</category>
        
      </item>
    
      <item>
        <title>의존성 모듈의 취약점 해결하기</title>
        <description>&lt;h2 id=&quot;의존성-모듈의-취약점-해결하기&quot;&gt;의존성 모듈의 취약점 해결하기&lt;/h2&gt;

&lt;h3 id=&quot;1-상황&quot;&gt;1. 상황&lt;/h3&gt;

&lt;p&gt;npm package.json을 활용해 모듈(=라이브러리) 버전 관리를 하면서 작업을 하다보면, 깃 또는 메일로 의존성 모듈의 취약점을 알리는 메시지와 메일이 
잔뜩 오는 상황을 겪을 때가 있다.&lt;br /&gt;
이는 해당 레포에서 사용하는 외부(의존성) 모듈에 문제가 있음을 알리는 경고이다.&lt;br /&gt;
이를 해결하는 방법에 대한 가이드이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;참고로 이런 경고 메시지는 해당 레포의 default 브랜치를 기준으로 한다.&lt;br /&gt;
default 브랜치가 master라면 master 브랜치를 기준으로 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;2-의존성-모듈이란&quot;&gt;2. 의존성 모듈이란?&lt;/h3&gt;

&lt;p&gt;의존성 모듈에 대해 먼저 짚고 넘어가자.&lt;br /&gt;
npm에서 관리되는 모듈은 독자적인 모듈은 거의 없다.&lt;br /&gt;
A 모듈이 B 모듈에 영향을 주고 B 모듈은 C 모듈에 영향을 준다.&lt;/p&gt;

&lt;p&gt;이때 C 모듈은 B 모듈에 ‘의존’하고 있다 라고 말한다.&lt;br /&gt;
왜냐하면 B 모듈이 없으면 C 모듈은 제대로 작동할 수 없기 때문이다.&lt;/p&gt;

&lt;p&gt;이런 의존성을 package.json을 통해 관리해주는 것이 npm의 역할이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;어떤 곳에서는 모듈 버전을 관리한다하고 어떤 곳에서는 라이브러리 버전을 관리한다고 한다.&lt;br /&gt;
모듈과 라이브러리는 같은 뜻이라고 생각하면 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;3-모듈-버전의-의미&quot;&gt;3. 모듈 버전의 의미&lt;/h3&gt;

&lt;p&gt;모듈 버전의 의미에 대해 짚고 넘어가자.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;에 명시된 모듈(=라이브러리) 버전을 보면 보통 아래와 같이 명시된 것을 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;dependencies&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;react&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^16.12.0&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt; 이 문자를 &lt;strong&gt;캐럿&lt;/strong&gt;이라고 하는데, 이 캐럿이 의미하는 바는 무엇일까?&lt;br /&gt;
아래 &lt;strong&gt;프로젝트 특징&lt;/strong&gt;에서도 설명하겠지만, 위 버전에 대해 설명하기 전에 우선 &lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;버전관리&lt;/span&gt;&lt;/strong&gt;에 대해 생각해보자.&lt;br /&gt;
만약 프로젝트에서 사용하는 모듈(=라이브러리)의 버전을 엄격하게 제한한다면 어떤 일이 발생할까?&lt;/p&gt;

&lt;p&gt;모듈(=라이브러리) 버전업을 하는데 꽤 힘들 수 있다.&lt;br /&gt;
사용하는 패키지를 전부 버전업해야하기 때문이다.&lt;br /&gt;
그렇게되면 해당 프로젝트는 특정 버전에 갖혀 버릴지도 모른다.&lt;/p&gt;

&lt;p&gt;하지만 반대로 버전을 느슨하게 풀어 놓는 것도 문제가 될 수 있다.&lt;br /&gt;
호환성 문제가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;이를 위해 &lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;유의적 버전(Sementic Version)&lt;/span&gt;&lt;/strong&gt; 체계가 만들어졌다.&lt;br /&gt;
npm은 이 &lt;strong&gt;유의적 버전&lt;/strong&gt;을 따르는 전제 하에 모듈 버전을 관리한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;유의적 버전&lt;/strong&gt;은 주(Major), 부(Minor), 수(Patch) 세 가지 숫자를 조합해서 버전을 관리한다.&lt;br /&gt;
위으 react 라이브러리는 버전은 16.12.0이며 16이 주버전, 12가 부버전, 0이 수버전이라는 뜻이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주버전(Major Version) : 기존 버전과 호환되지 않게 변경한 경우&lt;/li&gt;
  &lt;li&gt;부버전(Minor Version) : 기존 버전과 호환되면서 기능이 추가된 경우&lt;/li&gt;
  &lt;li&gt;수버전(Patch Version) : 기존 버전과 호환되면서 버그를 수정한 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;버전을-관리하기-위해-보통-다음과-같은-방법을-사용합니다&quot;&gt;버전을 관리하기 위해 보통 다음과 같은 방법을 사용합니다.&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;특정 버전을 명시한다.&lt;/p&gt;

    &lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;library&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1.2.3&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;부등호로 버전 범위를 명시한다.&lt;/p&gt;

    &lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;library&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;gt;1.2.3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;library2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;gt;=1.2.3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;library3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;1.2.3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;library4&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;=1.2.3&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;틸드(~)와 캐럿(^)을 사용해 범위를 명시한다.&lt;/p&gt;

    &lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
       &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;library&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;~1.2.3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
       &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;library2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^1.2.3&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;틸드&lt;/strong&gt;&lt;br /&gt;
틸드(~)는 마이너(부) 버전이 명시되어 있으면 패치(수) 버전을 변경한다.&lt;br /&gt;
예를 들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;~1.2.3&lt;/code&gt; 표기는 1.2.3 부터 1.3.0 미만까지를 포함한다.&lt;br /&gt;
마이너(부) 버전이 없으면 마이너(부) 버전을 갱신한다.&lt;br /&gt;
~0 표기는 0.0.0 부터 1.0.0 미만까지를 포함한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;캐럿&lt;/strong&gt;&lt;br /&gt;
캐럿(^)은 정식버전에서 마이너(부) 버전과 패치(수) 버전을 변경한다.&lt;br /&gt;
예를 들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;^1.2.3&lt;/code&gt; 표기는 1.2.3 부터 2.0.0 미만까지를 포함한다.&lt;br /&gt;
정식버전 미만인 0.x 버전은 패치(수) 버전만 갱신한다.&lt;br /&gt;
^0 표기는 0.0.0 부터 0.1.0 미만까지를 포함한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;과거에-npm은-틸드를-기본으로-사용했는데-지금은-캐럿을-사용한다&quot;&gt;과거에 NPM은 틸드를 기본으로 사용했는데 지금은 캐럿을 사용한다.&lt;/h3&gt;

&lt;p&gt;그 이유는 다음과 같다.&lt;/p&gt;

&lt;p&gt;보통 라이브러리 정식 릴리즈 전에는 모듈 버전이 수시로 변한다.&lt;br /&gt;
0.1에서  0.2로 마이너(부) 버전이 변하더라도 하위 호환성을 지키지 않고 배포하는 경우가 빈번하다.&lt;br /&gt;
~0으로 버전 범위를 표기한다면 0.0.0 부터 1.0.0 미만까지 사용하기 때문에 하위 호환성을 지키지 못하는 0.2로 업데이트 되어버리는 문제가 발생할 수도 있다.&lt;/p&gt;

&lt;p&gt;반면 캐럿을 사용해 ^0으로 표기한다면 0.0.0 부터 0.1.0 미만 내에서만 버전을 사용하도록 제한하기 때문에 하위 호환성을 유지할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;4-프로젝트-특징&quot;&gt;4. 프로젝트 특징&lt;/h3&gt;

&lt;p&gt;보통 프로젝트는 이러한 의존성 모듈 버전을 &lt;code class=&quot;highlighter-rouge&quot;&gt;package-lock.json&lt;/code&gt;이라는 파일을 통해 고정시켜버린다.&lt;br /&gt;
그 이유는 같은 모듈일지라도 모듈 버전에 따라 결과물이 달라진다거나 또는 에러가 날 수 있기 때문이다.&lt;br /&gt;
때문에 그런 에러를 줄여 함께 작업하는 사람들의 시간을 단축시키기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;package-lock.json&lt;/code&gt;을 사용한다.&lt;/p&gt;

&lt;p&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;.nvmrc&lt;/code&gt; 파일이 하는 역할도 같은 맥락이다. nvm을 사용하는 개발자에게 노드 버전을 명시하는 역할을 한다.)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;모듈 관리툴로 yarn을 사용한다면 yarn.lock 파일이 package-lock.json 역할을 대신한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;package-lock.json&lt;/code&gt;을 통해 모듈 버전을 고정시키게 되면 장기간 모듈 버전이 업데이트 안되는 현상이 발생한다.&lt;br /&gt;
그렇게 되면 해당 프로젝트에 사용하고 있는 모듈의 취약점들이 해결이 안된채로 남아있게 된다.&lt;br /&gt;
그래서 주기적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;package-lock.json&lt;/code&gt;도 업데이트 해줘야된다.&lt;/p&gt;

&lt;p&gt;하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;package-lock.json&lt;/code&gt;은 &lt;strong&gt;자동으로 설치 시점의 환경&lt;/strong&gt;을 기록하는 파일이기 때문에 수동으로 변경해도 해결이 안된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;설치 시점의 환경이란 package-lock.json 파일이 없는 상황에서 설치된 시점을 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;5-해결방법&quot;&gt;5. 해결방법&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;레포를 클론받아 위 명령어를 통해 모듈 설치를 한다면, package.json(package-lock.json이 있다면 package-lock.json)에 명시되어 있는 모듈 버전을 설치한다.&lt;br /&gt;
그런데 설치하다보면 아래와 같은 메시지가 뜰 때가 있다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MINGW64 /c/workspace/summer/foreign_survey/client &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;develop&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;npm i
audited 30197 packages &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;12.466s
found 657 vulnerabilities &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;574 low, 64 moderate, 16 high, 3 critical&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  run &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;npm audit fix&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; to fix them, or &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;npm audit&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;details
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;npm은 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm i&lt;/code&gt; 명령어를 실행할 때 package의 취약점을 검사한다.&lt;/strong&gt;&lt;br /&gt;
즉, 현재 취약점을 몇 개 찾았으니 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm audit fix&lt;/code&gt; 명령어를 통해 이 취약점을 해결하던지 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm audit&lt;/code&gt; 명령어를 통해 상세 내용을 확인하던지 해라. 라는 뜻이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;npm audit 명령어는 npm 6 버전 이상에 추가된 기능이라고 한다.&lt;br /&gt;
원래는 다른 라이브러리가 이를 대신했었다고 한다.&lt;br /&gt;
현재는 npm 5 버전에도 위 기능을 추가한 상태라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, 아래와 같이 명령어를 실행하면 취약점이 발견된 모듈을 자동으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt; 해준다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MINGW64 /c/workspace/summer/foreign_survey/client &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;develop&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;npm audit fix
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.1.3 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;node_modules&lt;span class=&quot;se&quot;&gt;\f&lt;/span&gt;sevents&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;fsevents@1.1.3: wanted &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;os&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;darwin&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;arch&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;any&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;current: &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;os&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;win32&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;arch&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;x64&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;

+ babel-preset-env@1.7.0
added 43 packages from 39 contributors, removed 10 packages, updated 8 packages and moved 1 package &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;28.66s
fixed 477 of 657 vulnerabilities &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;30197 scanned packages
  7 package updates &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;180 vulns involved breaking changes
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;npm audit fix &lt;span class=&quot;nt&quot;&gt;--force&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; to &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;breaking changes&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; or &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;it by hand&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm audit fix&lt;/code&gt;을 해도 취약점이 다 해결되지 않는 경우가 많다.&lt;br /&gt;
그럴 경우엔 아래 명령어로 현재 모듈들의 버전을 체크해준다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;USER@DESKTOP-RUCOU5S MINGW64 /d/
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;npm outdated
Package            Current  Wanted  Latest  Location
@babel/core         7.11.0  7.11.6  7.11.6  
@babel/preset-env   7.11.0  7.11.5  7.11.5  
@babel/register     7.10.5  7.11.5  7.11.5  
autoprefixer         9.8.6   9.8.6  10.0.0  
gulp-load-plugins    2.0.3   2.0.4   2.0.4  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 각 모듈의 버전을 확인하여 최신 버전으로 업데이트 해준다.&lt;br /&gt;
그리고 다시 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm audit fix&lt;/code&gt; 명령어를 실행한다.&lt;br /&gt;
이렇게 하면 현재 취약점이 발견된 모듈 개수가 줄어든 것을 확인할 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;하지만 여전히 취약점이 있는 모듈이 있는 경우가 있다..&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;
이럴 경우에 다음 명령어를 실행한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; npm audit

                       &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; npm audit security report &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Run  npm update lodash --depth 5  to resolve 13 vulnerabilities&lt;/span&gt;

  Low             Prototype Pollution

  Package         lodash

  Dependency of   browser-sync &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;dev]

  Path            browser-sync &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; easy-extender &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; lodash

  More info       https://npmjs.com/advisories/1523




  Low             Prototype Pollution

  Package         lodash

  Dependency of   cheerio &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;dev]

  Path            cheerio &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; lodash

  More info       https://npmjs.com/advisories/1523

  Low             Prototype Pollution

  Package         lodash

  Dependency of   gulp-htmlhint &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;dev]

  Path            gulp-htmlhint &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; htmlhint &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; async &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; lodash

  More info       https://npmjs.com/advisories/1523




  Low             Prototype Pollution

  Package         lodash

  Dependency of   gulp-htmlhint &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;dev]

  Path            gulp-htmlhint &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; htmlhint &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; jshint &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; lodash

  More info       https://npmjs.com/advisories/1523

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 명령어를 실행하면 취약점을 가지고 있는 모듈들 목록이 나온다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;모듈 이름과&lt;/li&gt;
  &lt;li&gt;해당 모듈이 어떤 문제를 발생시킬 수 있는지,&lt;/li&gt;
  &lt;li&gt;그리고 의존성이 어떻게 되는지&lt;/li&gt;
  &lt;li&gt;이러한 문제점을 해결하기 위한 정보를 제공해주는 Moro info url도 제공한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;우선 맨 위에 쓰여있는 명령어를 실행해 취약점을 해결한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm update lodash &lt;span class=&quot;nt&quot;&gt;--depth&lt;/span&gt; 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그래도 끝내 해결 안되는 모듈들은 아래처럼 하면 된다.&lt;br /&gt;
package.json에 끝내 해결 안되는 모듈들을 명시하자.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;scripts&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;preinstall&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;npx npm-force-resolutions&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;resolutions&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;yargs-parser&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^18.1.2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;minimist&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^1.2.3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;braces&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^2.3.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;cryptiles&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^4.1.2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;stringstream&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^0.0.6&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;hoek&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^5.0.3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;kind-of&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^6.0.3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;jpeg-js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^0.4.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;lodash.template&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^4.5.0&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;“scripts” 키는 커스텀 명령어를 작성할 수 있는 키이다.&lt;br /&gt;
위와 같이 커스텀 명령어를 입력하면&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm run preinstall
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이란 명령어를 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm npm-force-resolutions&lt;/code&gt; 명령어를 실행할 수 있다.&lt;br /&gt;
“resolutions” 키엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm audit&lt;/code&gt; 에서 나온 취약점을 갖고있는 모듈 목록을 넣어주면 된다.&lt;br /&gt;
옆에는 권장버전이다.&lt;br /&gt;
권장 버전은 아래처럼 깃헙에서도 확인할 수 있고,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/module/image06.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;More info에서도 확인할 수 있다.&lt;br /&gt;
위와 같이 package.json을 작성해주시고&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm run preinstall
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;명령어를 실행해주면 취약점을 갖고있는 모듈 문제가 해결된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의 : 기존 사용하던 툴이 제대로 동작하는지 확인해봐야된다. 걸프, 그런트, 웹팩 등등&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 23 Sep 2020 12:17:00 +0900</pubDate>
        <link>http://localhost:4000/node_module/2020/09/23/module4.html</link>
        <guid isPermaLink="true">http://localhost:4000/node_module/2020/09/23/module4.html</guid>
        
        
        <category>node_module</category>
        
      </item>
    
  </channel>
</rss>
