<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-05-03T22:44:08+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">LHJ</title><subtitle>coding blog</subtitle><entry><title type="html">7.2 정적 스코프와 동적 스코프</title><link href="http://localhost:4000/javascript/2020/05/03/javascript118/" rel="alternate" type="text/html" title="7.2 정적 스코프와 동적 스코프" /><published>2020-05-03T22:32:00+09:00</published><updated>2020-05-03T22:32:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/03/javascript118</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/03/javascript118/">&lt;p&gt;프로그램의 소스 코드를 살펴보는 건 프로그램의 &lt;strong&gt;정적(어휘적, lexical) 구조&lt;/strong&gt;를 살펴보는 겁니다.&lt;br /&gt;
하지만 프로그램을 실제 실행하면 실행 흐름은 이곳 저곳으로 움직입니다.&lt;br /&gt;
함수 두 개를 쓰는 프로그램이 있다고 합시다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;one&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;two&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;정적으로 보면 이 프로그램은 단순히 위에서 아래로 읽어내리는 문의 연속입니다.&lt;br /&gt;
하지만 이 프로그램을 실행하면 실행 흐름은 읽는 순서와 다릅니다.&lt;br /&gt;
f1이 f2보다 먼저 정의됐지만, f2의 함수 바디가 실행된 다음 f1으로, 다시 f2로 넘어갑니다.&lt;/p&gt;

&lt;p&gt;자바스크립트의 스코프는 &lt;strong&gt;정적&lt;/strong&gt;입니다.&lt;br /&gt;
소스 코드만 봐도 변수가 스코프에 있는지 판단할 수 있다는 뜻입니다.&lt;br /&gt;
다만, 소스 코드만 봐도 즉시 스코프를 &lt;strong&gt;분명히 알 수 있다는 뜻은 아닙니다.&lt;/strong&gt;&lt;br /&gt;
이 장에서 꼼꼼히 살피다 보면 스코프를 판단할 수 있는 몇몇 예제를 찾아볼 수 있을 겁니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;정적 스코프&lt;/strong&gt;는 어떤 변수가 함수 스코프 안에 있는지 함수를 &lt;strong&gt;정의할 때&lt;/strong&gt; 알 수 있다는 뜻입니다.&lt;br /&gt;
&lt;strong&gt;호출할 때 알 수 있는 것은 아닙니다.&lt;/strong&gt;&lt;br /&gt;
다음 예제를 보십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 새 스코프&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;변수 x는 함수 f를 정의할 때 존재하지만, y는 그렇지 않습니다.&lt;br /&gt;
y는 다른 스코프에 존재합니다.&lt;br /&gt;
다른 스코프에서 y를 선언하고 그 스코프에서 f를 호출하더라도, f를 호출하면 x는 그 바디 안의 스코프에 있지만 y는 그렇지 않습니다.&lt;br /&gt;
이것이 정적 스코프입니다.&lt;br /&gt;
함수 f는 자신이 &lt;strong&gt;정의될 때&lt;/strong&gt; 접근할 수 있었던 식별자에는 여전히 접근할 수 있지만, &lt;strong&gt;호출할 때&lt;/strong&gt; 스코프에 있는 식별자에 접근할 수는 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image48.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;자바스크립트의 정적 스코프는 전역 스코프(global scope)와 블록 스코프(block scope), 함수 스코프(function scope)에 적용됩니다.&lt;/strong&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">프로그램의 소스 코드를 살펴보는 건 프로그램의 정적(어휘적, lexical) 구조를 살펴보는 겁니다. 하지만 프로그램을 실제 실행하면 실행 흐름은 이곳 저곳으로 움직입니다. 함수 두 개를 쓰는 프로그램이 있다고 합시다. function f1() { console.log('one'); } function f2() { console.log('two'); } f2(); f1(); f2(); 정적으로 보면 이 프로그램은 단순히 위에서 아래로 읽어내리는 문의 연속입니다. 하지만 이 프로그램을 실행하면 실행 흐름은 읽는 순서와 다릅니다. f1이 f2보다 먼저 정의됐지만, f2의 함수 바디가 실행된 다음 f1으로, 다시 f2로 넘어갑니다. 자바스크립트의 스코프는 정적입니다. 소스 코드만 봐도 변수가 스코프에 있는지 판단할 수 있다는 뜻입니다. 다만, 소스 코드만 봐도 즉시 스코프를 분명히 알 수 있다는 뜻은 아닙니다. 이 장에서 꼼꼼히 살피다 보면 스코프를 판단할 수 있는 몇몇 예제를 찾아볼 수 있을 겁니다. 정적 스코프는 어떤 변수가 함수 스코프 안에 있는지 함수를 정의할 때 알 수 있다는 뜻입니다. 호출할 때 알 수 있는 것은 아닙니다. 다음 예제를 보십시오. const x = 3; function f() { console.log(x); console.log(y); } { // 새 스코프 const y = 5; f(); } 변수 x는 함수 f를 정의할 때 존재하지만, y는 그렇지 않습니다. y는 다른 스코프에 존재합니다. 다른 스코프에서 y를 선언하고 그 스코프에서 f를 호출하더라도, f를 호출하면 x는 그 바디 안의 스코프에 있지만 y는 그렇지 않습니다. 이것이 정적 스코프입니다. 함수 f는 자신이 정의될 때 접근할 수 있었던 식별자에는 여전히 접근할 수 있지만, 호출할 때 스코프에 있는 식별자에 접근할 수는 없습니다. 자바스크립트의 정적 스코프는 전역 스코프(global scope)와 블록 스코프(block scope), 함수 스코프(function scope)에 적용됩니다.</summary></entry><entry><title type="html">7.1 스코프와 존재</title><link href="http://localhost:4000/javascript/2020/05/03/javascript117/" rel="alternate" type="text/html" title="7.1 스코프와 존재" /><published>2020-05-03T22:23:00+09:00</published><updated>2020-05-03T22:23:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/03/javascript117</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/03/javascript117/">&lt;p&gt;변수가 존재하지 않으면 그 변수는 스코프 안에 ‘있지 않음’을 직관적으로 알 수 있습니다.&lt;br /&gt;
즉, 아직 선언하지 않은 변수나 함수가 종료되면서 존재하지 않게 된 변수는 분명 스코프 안에 ‘있지 않습니다.’&lt;/p&gt;

&lt;p&gt;그건 무슨 뜻일까요?&lt;br /&gt;
변수가 스코프 안에 있지 않다면, 그 변수는 존재하지 않는다는 말일까요?&lt;br /&gt;
꼭 그런 건 아닙니다.&lt;br /&gt;
그리고 여기서 &lt;strong&gt;스코프&lt;/strong&gt;와 &lt;strong&gt;존재&lt;/strong&gt;를 반드시 구별해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;가시성(visibility)&lt;/strong&gt; 이라고도 불리는 스코프는 프로그램의 현재 실행 중인 부분, 즉 &lt;strong&gt;실행 컨텍스트(execution context)&lt;/strong&gt; 에서 현재 보이고 접근할 수 있는 식별자들을 말합니다.&lt;br /&gt;
반면 &lt;strong&gt;존재한다&lt;/strong&gt;는 말은 그 식별자가 메모리가 할당된(예약된) 무언가를 가리키고 있다는 뜻입니다.&lt;br /&gt;
‘존재하지만 스코프 안에는 없는’ 변수의 예를 곧 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;무언가가 더는 존재하지 않는다고 해도 자바스크립트는 메모리를 바로 회수하지는 않습니다.&lt;br /&gt;
그것을 계속 유지할 필요가 없다고 표시해 두면, 주기적으로 일어나는 &lt;strong&gt;가비지 콜렉션(garbage collection)&lt;/strong&gt; 프로세스에서 메모리를 회수합니다.&lt;br /&gt;
자바스크립트의 가비지 콜렉션은 자동으로 일어나며, CPU나 메모리를 심하게 혹사하는 애플리케이션이 아니라면 프로그래머가 신경 쓸 필요는 없습니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">변수가 존재하지 않으면 그 변수는 스코프 안에 ‘있지 않음’을 직관적으로 알 수 있습니다. 즉, 아직 선언하지 않은 변수나 함수가 종료되면서 존재하지 않게 된 변수는 분명 스코프 안에 ‘있지 않습니다.’ 그건 무슨 뜻일까요? 변수가 스코프 안에 있지 않다면, 그 변수는 존재하지 않는다는 말일까요? 꼭 그런 건 아닙니다. 그리고 여기서 스코프와 존재를 반드시 구별해야 합니다. 가시성(visibility) 이라고도 불리는 스코프는 프로그램의 현재 실행 중인 부분, 즉 실행 컨텍스트(execution context) 에서 현재 보이고 접근할 수 있는 식별자들을 말합니다. 반면 존재한다는 말은 그 식별자가 메모리가 할당된(예약된) 무언가를 가리키고 있다는 뜻입니다. ‘존재하지만 스코프 안에는 없는’ 변수의 예를 곧 살펴보겠습니다. 무언가가 더는 존재하지 않는다고 해도 자바스크립트는 메모리를 바로 회수하지는 않습니다. 그것을 계속 유지할 필요가 없다고 표시해 두면, 주기적으로 일어나는 가비지 콜렉션(garbage collection) 프로세스에서 메모리를 회수합니다. 자바스크립트의 가비지 콜렉션은 자동으로 일어나며, CPU나 메모리를 심하게 혹사하는 애플리케이션이 아니라면 프로그래머가 신경 쓸 필요는 없습니다.</summary></entry><entry><title type="html">7. 스코프</title><link href="http://localhost:4000/javascript/2020/05/03/javascript116/" rel="alternate" type="text/html" title="7. 스코프" /><published>2020-05-03T22:13:00+09:00</published><updated>2020-05-03T22:13:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/03/javascript116</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/03/javascript116/">&lt;p&gt;스코프(scope)는 변수와 상수, 매개변수가 언제 어디서 정의되는지 결정합니다.&lt;br /&gt;
우리는 이미 스코프의 개념을 조금 접했습니다.&lt;br /&gt;
함수 매개변수가 함수 바디 안에서만 존재하는 것도 스코프의 한 예입니다.&lt;br /&gt;
다음 예제를 보십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 8&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ReferenceError: x is not defined&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;x가 아주 잠시나마 존재했었으니 x + 3을 계산할 수 있었습니다.&lt;br /&gt;
하지만 함수 바디를 벗어나면 x는 존재하지 않는 것처럼 보입니다.&lt;br /&gt;
따라서 우리는 x의 &lt;strong&gt;스코프&lt;/strong&gt;가 함수 f라고 말합니다.&lt;/p&gt;

&lt;p&gt;변수의 스코프가 어떤 함수라고 말할 때는, 함수를 실제 호출할 때까지는 함수 바디의 정해진 &lt;strong&gt;매개변수(formal argument)&lt;/strong&gt; 가 존재하지 않음을 반드시 상기해야 합니다.&lt;br /&gt;
함수는 여러 번 호출할 수 있습니다.&lt;br /&gt;
그리고 함수를 호출할 때마다 매개변수가 나타나고, 함수가 제어권을 반환하면 스코프 밖으로 사라집니다.&lt;/p&gt;

&lt;p&gt;변수와 상수는 만들기 전에는 존재하지 않는다는 것도 확실합니다.&lt;br /&gt;
즉, let이나 const로 선언하기 전에는 스코프 안에 존재하지 않습니다(var는 특수한 경우로 7장 후반에 설명합니다).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;NOTE_&lt;/strong&gt;&lt;br /&gt;
일부 언어는 &lt;strong&gt;선언(declaration)&lt;/strong&gt;과 &lt;strong&gt;정의(definition)&lt;/strong&gt; 을 명확히 구분합니다.&lt;br /&gt;
일반적으로 변수를 선언한다는 것은 식별자를 주어서 그 존재를 알리는 겁니다.&lt;br /&gt;
반면 정의는 선언과 함께 값도 부여하는 것을 말합니다.&lt;br /&gt;
자바스크립트에서는 모든 변수를 선언하는 동시에 값이 주어지므로(명시적으로 정하지 않으면 undefined가 암시적으로 주어지므로) 두 용어를 구분하지 않습니다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">스코프(scope)는 변수와 상수, 매개변수가 언제 어디서 정의되는지 결정합니다. 우리는 이미 스코프의 개념을 조금 접했습니다. 함수 매개변수가 함수 바디 안에서만 존재하는 것도 스코프의 한 예입니다. 다음 예제를 보십시오. function f(x) { return x + 3; } f(5); // 8 x; // ReferenceError: x is not defined x가 아주 잠시나마 존재했었으니 x + 3을 계산할 수 있었습니다. 하지만 함수 바디를 벗어나면 x는 존재하지 않는 것처럼 보입니다. 따라서 우리는 x의 스코프가 함수 f라고 말합니다. 변수의 스코프가 어떤 함수라고 말할 때는, 함수를 실제 호출할 때까지는 함수 바디의 정해진 매개변수(formal argument) 가 존재하지 않음을 반드시 상기해야 합니다. 함수는 여러 번 호출할 수 있습니다. 그리고 함수를 호출할 때마다 매개변수가 나타나고, 함수가 제어권을 반환하면 스코프 밖으로 사라집니다. 변수와 상수는 만들기 전에는 존재하지 않는다는 것도 확실합니다. 즉, let이나 const로 선언하기 전에는 스코프 안에 존재하지 않습니다(var는 특수한 경우로 7장 후반에 설명합니다). NOTE_ 일부 언어는 선언(declaration)과 정의(definition) 을 명확히 구분합니다. 일반적으로 변수를 선언한다는 것은 식별자를 주어서 그 존재를 알리는 겁니다. 반면 정의는 선언과 함께 값도 부여하는 것을 말합니다. 자바스크립트에서는 모든 변수를 선언하는 동시에 값이 주어지므로(명시적으로 정하지 않으면 undefined가 암시적으로 주어지므로) 두 용어를 구분하지 않습니다.</summary></entry><entry><title type="html">6.9 요약</title><link href="http://localhost:4000/javascript/2020/05/03/javascript115/" rel="alternate" type="text/html" title="6.9 요약" /><published>2020-05-03T20:12:00+09:00</published><updated>2020-05-03T20:12:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/03/javascript115</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/03/javascript115/">&lt;p&gt;함수는 자바스크립트에서 핵심적인 부분입니다.&lt;br /&gt;
함수는 단지 코드를 모듈화하는 역할만 있는 건 아닙니다.&lt;br /&gt;
함수는 아주 강력한 논리적 단위가 될 수 있습니다.&lt;br /&gt;
이 장에서는 함수가 어떻게 동작하는지에 치중했습니다.&lt;br /&gt;
좀 무미건조하지만 중요한 내용입니다.&lt;br /&gt;
이 장에서 배운 내용을 기초로, 함수가 얼마나 다재다능한지 하나씩 살펴볼 겁니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">함수는 자바스크립트에서 핵심적인 부분입니다. 함수는 단지 코드를 모듈화하는 역할만 있는 건 아닙니다. 함수는 아주 강력한 논리적 단위가 될 수 있습니다. 이 장에서는 함수가 어떻게 동작하는지에 치중했습니다. 좀 무미건조하지만 중요한 내용입니다. 이 장에서 배운 내용을 기초로, 함수가 얼마나 다재다능한지 하나씩 살펴볼 겁니다.</summary></entry><entry><title type="html">6.8 call 과 apply, bind</title><link href="http://localhost:4000/javascript/2020/05/03/javascript114/" rel="alternate" type="text/html" title="6.8 call 과 apply, bind" /><published>2020-05-03T19:07:00+09:00</published><updated>2020-05-03T19:07:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/03/javascript114</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/03/javascript114/">&lt;p&gt;this를 사용하는 일반적인 방법은 이미 살펴봤습니다.&lt;br /&gt;
다른 객체지향 언어에서도 this를 이런 식으로 사용합니다.&lt;br /&gt;
&lt;strong&gt;자바스크립트에서는 일반적인 방법 외에도, 함수를 어디서, 어떻게 호출했느냐와 관계없이 this가 무엇인지 지정할 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
먼저 call 메서드부터 시작합시다.&lt;/p&gt;

&lt;h2 id=&quot;call&quot;&gt;call&lt;/h2&gt;

&lt;p&gt;call 메서드는 모든 함수에서 사용할 수 있으며, this를 특정 값으로 지정할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bruce&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Bruce&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;madeline&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Madeline&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 이 함수는 어떤 객체에도 연결되지 않았지만 this를 사용합니다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;greet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`Hello, I'm &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;!`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;greet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;Hello, I'm undefined!&quot; - this는 어디에도 묶이지 않았습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;greet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bruce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;Hello, I'm Bruce!&quot; - this는 bruce입니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;greet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;madeline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;Hello, I'm Madeline!&quot; - this는 madeline입니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;함수를 호출하면서 call을 사용하고 this로 사용할 객체를 넘기면 해당 함수가 주어진 객체의 메서드인 것처럼 사용할 수 있습니다.&lt;br /&gt;
call의 첫 번째 매개변수는 this로 사용할 값이고, 매개변수가 더 있으면 그 매개변수는 호출하는 함수로 전달됩니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;birthYear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;occupation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;birthYear&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;birthYear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;occupation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;occupation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bruce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1949&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;singer&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// bruce는 이제 { name: &quot;Bruce&quot;, birthYear: 1949, occupation: &quot;singer&quot; } 입니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;madeline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1942&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;actress&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// madeline은 이제 { name: 'Madeline', birthYear: 1942, occupation: &quot;actress&quot; } 입니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;apply&quot;&gt;apply&lt;/h2&gt;

&lt;p&gt;apply는 함수 매개변수를 처리하는 방법을 제외하면 call과 완전히 같습니다.&lt;br /&gt;
call은 일반적인 함수와 마찬가지로 매개변수를 직접 받지만, apply는 매개변수를 배열로 받습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bruce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1955&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;actor&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// bruce는 이제 { name: &quot;Bruce&quot;, birthYear: 1955, occupation: &quot;actor&quot; } 입니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;madeline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1918&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;writer&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// madeline은 이제 { name: &quot;Madeline&quot;, birthYear: 1918, occupation: &quot;writer&quot; } 입니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;apply&lt;/strong&gt;는 배열 요소를 함수 매개변수로 사용해야 할 때 유용합니다.&lt;br /&gt;
apply를 설명할 때 흔히 사용하는 예제는 배열의 최솟값과 최댓값을 구하는 겁니다.&lt;br /&gt;
자바스크립트의 내장 함수인 &lt;strong&gt;Math.min&lt;/strong&gt;과 &lt;strong&gt;Math.max&lt;/strong&gt;는 매개변수를 받아 그중 최솟값과 최댓값을 각각 반환합니다.&lt;br /&gt;
apply를 사용하면 기존 배열을 이들 함수에 바로 넘길 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// -5&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 15&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;this의 값에 null을 쓴 이유는 Math.min과 Math.max가 this와 관계없이 동작하기 때문입니다.&lt;br /&gt;
&lt;strong&gt;즉, 무엇을 넘기든 관계없습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;ES6의 &lt;strong&gt;확산 연산자(…)&lt;/strong&gt; 를 사용해도 apply와 같은 결과를 얻을 수 있습니다.&lt;br /&gt;
update 메서드는 this 값이 중요하므로 call을 사용해야 하지만, Math.min과 Math.max는 this값이 무엇이든 관계없으므로 확산 연산자를 그대로 사용할 수 있습니다.&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newBruce&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1940&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;martial artist&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bruce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;newBruce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// apply(bruce, newBruce)와 같습니다.&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// -5&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 15&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;bind&quot;&gt;bind&lt;/h2&gt;

&lt;p&gt;this 의 값을 바꿀 수 있는 마지막 함수는 bind입니다.&lt;br /&gt;
bind를 사용하면 함수의 this 값을 영구히 바꿀 수 있습니다.&lt;br /&gt;
update 메서드를 이리저리 옮기면서도 호출할 때 this 값은 항상 bruce가 되게끔, call이나 apply, 다른 bind와 함께 호출하더라도 this값이 bruce가 되도록 하려면 bind를 사용합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;updateBruce&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bruce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;updateBruce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1904&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;actor&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// bruce는 이제 { name: &quot;Bruce&quot;, birthYear: 1904, occupation: &quot;actor&quot; } 입니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;updateBruce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;madeline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1274&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;king&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// bruce는 이제 { name: &quot;Bruce&quot;, birthYear: 1274, occupation: &quot;king&quot; } 입니다.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// madeline은 변하지 않았습니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;bind는 함수의 동작을 영구적으로 바꾸므로 찾기 어려운 버그의 원인이 될 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
bind를 사용한 함수는 call이나 apply, 다른 bind와 함께 사용할 수 없는 거나 마찬가지입니다.&lt;br /&gt;
함수를 여기저기서 call이나 apply로 호출해야 하는데, this 값이 그에 맞춰 바뀌어야 하는 경우를 상상해 보십시오.&lt;br /&gt;
이럴 때는 bind를 사용하면 문제가 생깁니다.&lt;br /&gt;
bind를 쓰지 말라고 권하는 것은 아닙니다.&lt;br /&gt;
&lt;strong&gt;bind는 매우 유용하지만, 함수의 this가 어디에 묶이는지 정확히 파악하고 사용해야 합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;bind에 매개변수를 넘기면 항상 그 매개변수를 받으면서 호출되는 새 함수를 만드는 효과가 있습니다.&lt;/strong&gt;&lt;br /&gt;
예를 들어 bruce가 태어난 해를 항상 1949로 고정하지만, 직업은 자유롭게 바꿀 수 있는 업데이트 함수를 만들고 싶다면 다음과 같이 하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;updateBruce1949&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bruce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1949&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;updateBruce1949&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;singer, songwriter&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// bruce는 이제 { name: &quot;Bruce&quot;, birthYear: 1949, occupation: &quot;singer, songwriter&quot; } 입니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">this를 사용하는 일반적인 방법은 이미 살펴봤습니다. 다른 객체지향 언어에서도 this를 이런 식으로 사용합니다. 자바스크립트에서는 일반적인 방법 외에도, 함수를 어디서, 어떻게 호출했느냐와 관계없이 this가 무엇인지 지정할 수 있습니다. 먼저 call 메서드부터 시작합시다. call call 메서드는 모든 함수에서 사용할 수 있으며, this를 특정 값으로 지정할 수 있습니다. const bruce = { name: &quot;Bruce&quot; }; const madeline = { name: &quot;Madeline&quot; }; // 이 함수는 어떤 객체에도 연결되지 않았지만 this를 사용합니다. function greet() { return `Hello, I'm ${this.name}!`; } greet(); // &quot;Hello, I'm undefined!&quot; - this는 어디에도 묶이지 않았습니다. greet.call(bruce); // &quot;Hello, I'm Bruce!&quot; - this는 bruce입니다. greet.call(madeline); // &quot;Hello, I'm Madeline!&quot; - this는 madeline입니다. 함수를 호출하면서 call을 사용하고 this로 사용할 객체를 넘기면 해당 함수가 주어진 객체의 메서드인 것처럼 사용할 수 있습니다. call의 첫 번째 매개변수는 this로 사용할 값이고, 매개변수가 더 있으면 그 매개변수는 호출하는 함수로 전달됩니다. function update(birthYear, occupation) { this.birthYear = birthYear; this.occupation = occupation; } update.call(bruce, 1949, 'singer'); // bruce는 이제 { name: &quot;Bruce&quot;, birthYear: 1949, occupation: &quot;singer&quot; } 입니다. update.call(madeline, 1942, 'actress'); // madeline은 이제 { name: 'Madeline', birthYear: 1942, occupation: &quot;actress&quot; } 입니다. apply apply는 함수 매개변수를 처리하는 방법을 제외하면 call과 완전히 같습니다. call은 일반적인 함수와 마찬가지로 매개변수를 직접 받지만, apply는 매개변수를 배열로 받습니다. update.apply(bruce, [1955, &quot;actor&quot;]); // bruce는 이제 { name: &quot;Bruce&quot;, birthYear: 1955, occupation: &quot;actor&quot; } 입니다. update.apply(madeline, [1918, &quot;writer&quot;]); // madeline은 이제 { name: &quot;Madeline&quot;, birthYear: 1918, occupation: &quot;writer&quot; } 입니다. apply는 배열 요소를 함수 매개변수로 사용해야 할 때 유용합니다. apply를 설명할 때 흔히 사용하는 예제는 배열의 최솟값과 최댓값을 구하는 겁니다. 자바스크립트의 내장 함수인 Math.min과 Math.max는 매개변수를 받아 그중 최솟값과 최댓값을 각각 반환합니다. apply를 사용하면 기존 배열을 이들 함수에 바로 넘길 수 있습니다. const arr = [2, 3, -5, 15, 7]; Math.min.apply(null, arr); // -5 Math.max.apply(null, arr); // 15 this의 값에 null을 쓴 이유는 Math.min과 Math.max가 this와 관계없이 동작하기 때문입니다. 즉, 무엇을 넘기든 관계없습니다. ES6의 확산 연산자(…) 를 사용해도 apply와 같은 결과를 얻을 수 있습니다. update 메서드는 this 값이 중요하므로 call을 사용해야 하지만, Math.min과 Math.max는 this값이 무엇이든 관계없으므로 확산 연산자를 그대로 사용할 수 있습니다. const newBruce = [1940, &quot;martial artist&quot;]; update.call(bruce, ...newBruce); // apply(bruce, newBruce)와 같습니다. Math.min(...arr); // -5 Math.max(...arr); // 15 bind this 의 값을 바꿀 수 있는 마지막 함수는 bind입니다. bind를 사용하면 함수의 this 값을 영구히 바꿀 수 있습니다. update 메서드를 이리저리 옮기면서도 호출할 때 this 값은 항상 bruce가 되게끔, call이나 apply, 다른 bind와 함께 호출하더라도 this값이 bruce가 되도록 하려면 bind를 사용합니다. const updateBruce = update.bind(bruce); updateBruce(1904, &quot;actor&quot;); // bruce는 이제 { name: &quot;Bruce&quot;, birthYear: 1904, occupation: &quot;actor&quot; } 입니다. updateBruce.call(madeline, 1274, &quot;king&quot;); // bruce는 이제 { name: &quot;Bruce&quot;, birthYear: 1274, occupation: &quot;king&quot; } 입니다. // madeline은 변하지 않았습니다. bind는 함수의 동작을 영구적으로 바꾸므로 찾기 어려운 버그의 원인이 될 수 있습니다. bind를 사용한 함수는 call이나 apply, 다른 bind와 함께 사용할 수 없는 거나 마찬가지입니다. 함수를 여기저기서 call이나 apply로 호출해야 하는데, this 값이 그에 맞춰 바뀌어야 하는 경우를 상상해 보십시오. 이럴 때는 bind를 사용하면 문제가 생깁니다. bind를 쓰지 말라고 권하는 것은 아닙니다. bind는 매우 유용하지만, 함수의 this가 어디에 묶이는지 정확히 파악하고 사용해야 합니다. bind에 매개변수를 넘기면 항상 그 매개변수를 받으면서 호출되는 새 함수를 만드는 효과가 있습니다. 예를 들어 bruce가 태어난 해를 항상 1949로 고정하지만, 직업은 자유롭게 바꿀 수 있는 업데이트 함수를 만들고 싶다면 다음과 같이 하면 됩니다. const updateBruce1949 = update.bind(bruce, 1949); updateBruce1949(&quot;singer, songwriter&quot;); // bruce는 이제 { name: &quot;Bruce&quot;, birthYear: 1949, occupation: &quot;singer, songwriter&quot; } 입니다.</summary></entry><entry><title type="html">6.7 화살표 표기법</title><link href="http://localhost:4000/javascript/2020/05/03/javascript113/" rel="alternate" type="text/html" title="6.7 화살표 표기법" /><published>2020-05-03T18:50:00+09:00</published><updated>2020-05-03T18:50:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/03/javascript113</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/03/javascript113/">&lt;p&gt;ES6에서 새로 만든 &lt;strong&gt;화살표 표기법(arrow notation)&lt;/strong&gt; 도 환영받는 문법입니다.&lt;br /&gt;
화살표 표기법은 간단히 말해 function이라는 단어와 중괄호 숫자를 줄이려고 고안된 &lt;strong&gt;단축 문법&lt;/strong&gt;입니다.&lt;br /&gt;
중요한 차이가 하나 있는데, 곧 설명하겠습니다.&lt;/p&gt;

&lt;p&gt;화살표 함수에는 세 가지 단축 문법이 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;역주_&lt;/strong&gt;&lt;br /&gt;
화살표 함수는 이 책 전반에 걸쳐 자주 사용되므로, ES6 문법을 처음 접하는 독자분이라면 읽고만 넘어가지 말고 충분히 연습해서 익숙해져야 이후 내용을 이해하기 편리합니다.&lt;br /&gt;
화살표 함수는 단순히 function 키워드와 괄호 등을 생략하는 단축 문법에 그치지 않으며, 최근 주목받고 있는 함수형 프로그래밍을 자바스크립트에 도입하는 중요한 열쇠이기도 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;function을 생략해도 됩니다.&lt;/li&gt;
  &lt;li&gt;함수에 매개변수가 단 하나뿐이라면 (())도 생략할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;함수 바디가 표현식 하나라면 중괄호와 return문도 생략할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;화살표 함수는 항상 익명입니다.&lt;br /&gt;
화살표 함수도 변수에 할당할 수는 있지만, function 키워드 처럼 이름 붙은 함수를 만들 수는 없습니다.&lt;/p&gt;

&lt;p&gt;다음 예제를 보십시오.&lt;br /&gt;
이들 표현식은 모두 동등한 한 쌍입니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;hello!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 또는&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;hello!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`Hello, &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;!`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 또는&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`Hello, &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;!`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 또는&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이들 예제는 다분히 인위적입니다.&lt;br /&gt;
이름 붙은 함수가 필요하다면 그냥 일반적인 함수 선언을 사용하면 됩니다.&lt;br /&gt;
화살표 함수는 익명 함수를 만들어 다른 곳에 전달하려 할 때 가장 유용하며, 이에 대해서는 8장에서 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;화살표 함수에는 일반적인 함수와 중요한 차이가 있습니다.&lt;br /&gt;
&lt;span style=&quot;color:red;&quot;&gt;&lt;strong&gt;this 가 다른 변수와 마찬가지로, 정적으로(lexically) 묶인다는 겁니다.&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;
이 장에서 만들었던 greetBackwards 예제를 고쳐 써 봅시다.&lt;br /&gt;
&lt;strong&gt;화살표 함수를 사용하면 내부 함수 안에서 this를 사용할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Julie&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;greetBackwards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getReverseName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nameBackwards&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
				&lt;span class=&quot;nx&quot;&gt;nameBackwards&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nameBackwards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getReverseName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; si eman ym, olleH`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;greetBackwards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;화살표 함수에는 일반적인 함수와 다른 점이 두 가지 더 있습니다.&lt;/strong&gt;&lt;br /&gt;
&lt;span style=&quot;color:blue&quot;&gt;화살표 함수는 (9장에서 설명할) 객체 생성자로 사용할 수 없고, arguemnts 변수도 사용할 수 없습니다.&lt;/span&gt;&lt;br /&gt;
하지만 ES6에서 확산 연산자가 생겼으니 arguments 변수는 필요가 없긴 합니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">ES6에서 새로 만든 화살표 표기법(arrow notation) 도 환영받는 문법입니다. 화살표 표기법은 간단히 말해 function이라는 단어와 중괄호 숫자를 줄이려고 고안된 단축 문법입니다. 중요한 차이가 하나 있는데, 곧 설명하겠습니다. 화살표 함수에는 세 가지 단축 문법이 있습니다. 역주_ 화살표 함수는 이 책 전반에 걸쳐 자주 사용되므로, ES6 문법을 처음 접하는 독자분이라면 읽고만 넘어가지 말고 충분히 연습해서 익숙해져야 이후 내용을 이해하기 편리합니다. 화살표 함수는 단순히 function 키워드와 괄호 등을 생략하는 단축 문법에 그치지 않으며, 최근 주목받고 있는 함수형 프로그래밍을 자바스크립트에 도입하는 중요한 열쇠이기도 합니다. function을 생략해도 됩니다. 함수에 매개변수가 단 하나뿐이라면 (())도 생략할 수 있습니다. 함수 바디가 표현식 하나라면 중괄호와 return문도 생략할 수 있습니다. 화살표 함수는 항상 익명입니다. 화살표 함수도 변수에 할당할 수는 있지만, function 키워드 처럼 이름 붙은 함수를 만들 수는 없습니다. 다음 예제를 보십시오. 이들 표현식은 모두 동등한 한 쌍입니다. const f1 = function() { return &quot;hello!&quot;; } // 또는 const f1 = () =&amp;gt; &quot;hello!&quot;; const f2 = function(name) { return `Hello, ${name}!`; } // 또는 const f2 = name =&amp;gt; `Hello, ${name}!`; const f3 = function(a, b) { return a + b; } // 또는 const f3 = (a, b) =&amp;gt; a + b; 이들 예제는 다분히 인위적입니다. 이름 붙은 함수가 필요하다면 그냥 일반적인 함수 선언을 사용하면 됩니다. 화살표 함수는 익명 함수를 만들어 다른 곳에 전달하려 할 때 가장 유용하며, 이에 대해서는 8장에서 살펴보겠습니다. 화살표 함수에는 일반적인 함수와 중요한 차이가 있습니다. this 가 다른 변수와 마찬가지로, 정적으로(lexically) 묶인다는 겁니다. 이 장에서 만들었던 greetBackwards 예제를 고쳐 써 봅시다. 화살표 함수를 사용하면 내부 함수 안에서 this를 사용할 수 있습니다. const o = { name: 'Julie', greetBackwards: function() { const getReverseName = () =&amp;gt; { let nameBackwards = ''; for(let i=this.name.length-1; i&amp;gt;=0; i--){ nameBackwards += this.name[i]; } return nameBackwards; }; return `${getReverseName()} si eman ym, olleH`; }, }; o.greetBackwards(); 화살표 함수에는 일반적인 함수와 다른 점이 두 가지 더 있습니다. 화살표 함수는 (9장에서 설명할) 객체 생성자로 사용할 수 없고, arguemnts 변수도 사용할 수 없습니다. 하지만 ES6에서 확산 연산자가 생겼으니 arguments 변수는 필요가 없긴 합니다.</summary></entry><entry><title type="html">6.6 함수 표현식과 익명 함수</title><link href="http://localhost:4000/javascript/2020/05/03/javascript112/" rel="alternate" type="text/html" title="6.6 함수 표현식과 익명 함수" /><published>2020-05-03T18:32:00+09:00</published><updated>2020-05-03T18:32:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/03/javascript112</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/03/javascript112/">&lt;p&gt;지금까지는 함수 &lt;strong&gt;선언&lt;/strong&gt;만 봤습니다.&lt;br /&gt;
함수를 선언하면 함수에 &lt;strong&gt;바디&lt;/strong&gt;와 &lt;strong&gt;식별자&lt;/strong&gt;가 모두 주어집니다.&lt;br /&gt;
자바스크립트는 &lt;strong&gt;익명 함수(anonymous function)&lt;/strong&gt; 도 지원합니다.&lt;br /&gt;
익명 함수에서는 함수에 식별자가 주어지지 않습니다.&lt;/p&gt;

&lt;p&gt;함수에 &lt;strong&gt;식별자&lt;/strong&gt;가 없다는 말을 보고 어리둥절했을 수도 있습니다.&lt;br /&gt;
식별자가 없다면, 도대체 어떻게 호출해야 할까요?&lt;br /&gt;
답은 &lt;strong&gt;함수 표현식(function expression)&lt;/strong&gt; 에 있습니다.&lt;br /&gt;
우리는 표현식이 값이 되고, 함수 역시 값이 된다는 것을 알고 있습니다.&lt;br /&gt;
함수 표현식은 함수를 선언하는 한 가지 방법일 뿐이며, 그 함수가 익명이 될 수도 있을 뿐입니다.&lt;br /&gt;
함수 표현식은 식별자에 할당할 수도 있고 &lt;span style=&quot;color:red&quot;&gt;즉시 호출&lt;/span&gt;할 수도 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;즉시 호출하는 함수 표현식(IIFE, immediately invoked function expression)이라고 부릅니다.&lt;br /&gt;
7장에서 설명합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;함수 표현식은 함수 이름을 생략할 수 있다는 점을 제외하면 함수 선언과 문법적으로 완전히 같습니다.&lt;/strong&gt;&lt;br /&gt;
함수 표현식을 쓰고 그 결과를 변수에 할당하는 예제를 봅시다.&lt;br /&gt;
이 예제는 결과적으로 함수 선언과 동등합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;결과는 여태까지 했던 대로 함수를 선언한 것과 마찬가지입니다.&lt;br /&gt;
식별자 f가 이 함수를 가리킵니다.&lt;br /&gt;
일반적인 함수 선언과 마찬가지로 f()로 이 함수를 호출할 수 있습니다.&lt;br /&gt;
&lt;strong&gt;차이점은 먼저 함수 표현식으로 익명 함수를 만들고 그 함수를 변수에 할당했다는 겁니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;익명 함수는 어디든지 쓸 수 있습니다.&lt;br /&gt;
다른 함수나 메서드의 매개변수로 넘길 수도 있고, 객체의 함수 프로퍼티가 될 수도 있습니다.&lt;br /&gt;
책 전체에 걸쳐 이런 방법을 사용할 겁니다.&lt;/p&gt;

&lt;p&gt;앞에서 함수 표현식에서는 함수 이름을 &lt;strong&gt;생략&lt;/strong&gt;할 수 있다고 했습니다.&lt;br /&gt;
그러면 함수에 이름을 정하고 다시 변수에 할당하면 어떻게 될까요?&lt;br /&gt;
그리고 그렇게 한다면 이유는 무엇일까요?&lt;br /&gt;
다음 예제를 보십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 식으로 함수를 만들면 이름 g에 우선순위가 있습니다.&lt;br /&gt;
그리고 함수 바깥에서 함수에 접근할 때는 g를 써야 하며, f로 접근하려 하면 변수가 정의되지 않았다는 에러가 생깁니다.&lt;br /&gt;
그렇다면 왜 이런 방법을 사용하는 걸까요?&lt;br /&gt;
&lt;span style=&quot;color:red&quot;&gt;함수 안에서 자신을 호출할 때 (&lt;strong&gt;재귀(recursion)&lt;/strong&gt; 라고 합니다) 이런 방식이 필요할 수 있습니다.&lt;/span&gt;&lt;br /&gt;
다음 예제를 보십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;f stopped&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;함수 안에서는 f를 써서 자기 자신을 참조하고, 함수 바깥에서는 g를 써서 함수를 호출합니다.&lt;br /&gt;
함수에 두 가지 이름을 붙이는 것이 좋을 이유는 없지만, 여기서 그렇게 한 이유는 이름 붙은 함수 표현식이 어떻게 동작하는지 명확하게 설명하기 위해서입니다.&lt;/p&gt;

&lt;p&gt;함수 선언과 함수 표현식이 완전히 똑같이 보인다면, 자바스크립트는 둘을 어떻게 구분할까요?&lt;br /&gt;
차이가 있기는 한 걸까요?&lt;br /&gt;
답은 &lt;strong&gt;컨텍스트&lt;/strong&gt;입니다.&lt;br /&gt;
함수 선언이 표현식으로 사용됐다면 그건 함수 표현식입니다.&lt;br /&gt;
표현식으로 사용되지 않았다면 함수 선언입니다.&lt;/p&gt;

&lt;p&gt;이 차이는 다분히 이론적이며, 일반적으로는 이 차이에 대해 생각할 필요가 없습니다.&lt;br /&gt;
나중에 호출할 생각으로 함수를 만든다면 함수 선언을 사용하면 되고, 다른 곳에 할당하거나 다른 함수에 넘길 목적으로 함수를 만든다면 함수 표현식을 사용하면 됩니다.&lt;br /&gt;
복잡하게 생각할 필요는 없습니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">지금까지는 함수 선언만 봤습니다. 함수를 선언하면 함수에 바디와 식별자가 모두 주어집니다. 자바스크립트는 익명 함수(anonymous function) 도 지원합니다. 익명 함수에서는 함수에 식별자가 주어지지 않습니다. 함수에 식별자가 없다는 말을 보고 어리둥절했을 수도 있습니다. 식별자가 없다면, 도대체 어떻게 호출해야 할까요? 답은 함수 표현식(function expression) 에 있습니다. 우리는 표현식이 값이 되고, 함수 역시 값이 된다는 것을 알고 있습니다. 함수 표현식은 함수를 선언하는 한 가지 방법일 뿐이며, 그 함수가 익명이 될 수도 있을 뿐입니다. 함수 표현식은 식별자에 할당할 수도 있고 즉시 호출할 수도 있습니다. 즉시 호출하는 함수 표현식(IIFE, immediately invoked function expression)이라고 부릅니다. 7장에서 설명합니다. 함수 표현식은 함수 이름을 생략할 수 있다는 점을 제외하면 함수 선언과 문법적으로 완전히 같습니다. 함수 표현식을 쓰고 그 결과를 변수에 할당하는 예제를 봅시다. 이 예제는 결과적으로 함수 선언과 동등합니다. const f = function() { // ... }; 결과는 여태까지 했던 대로 함수를 선언한 것과 마찬가지입니다. 식별자 f가 이 함수를 가리킵니다. 일반적인 함수 선언과 마찬가지로 f()로 이 함수를 호출할 수 있습니다. 차이점은 먼저 함수 표현식으로 익명 함수를 만들고 그 함수를 변수에 할당했다는 겁니다. 익명 함수는 어디든지 쓸 수 있습니다. 다른 함수나 메서드의 매개변수로 넘길 수도 있고, 객체의 함수 프로퍼티가 될 수도 있습니다. 책 전체에 걸쳐 이런 방법을 사용할 겁니다. 앞에서 함수 표현식에서는 함수 이름을 생략할 수 있다고 했습니다. 그러면 함수에 이름을 정하고 다시 변수에 할당하면 어떻게 될까요? 그리고 그렇게 한다면 이유는 무엇일까요? 다음 예제를 보십시오. const g = function() { // ... } 이런 식으로 함수를 만들면 이름 g에 우선순위가 있습니다. 그리고 함수 바깥에서 함수에 접근할 때는 g를 써야 하며, f로 접근하려 하면 변수가 정의되지 않았다는 에러가 생깁니다. 그렇다면 왜 이런 방법을 사용하는 걸까요? 함수 안에서 자신을 호출할 때 (재귀(recursion) 라고 합니다) 이런 방식이 필요할 수 있습니다. 다음 예제를 보십시오. const g = function f (stop) { if(stop) console.log('f stopped'); f(true); }; g(false); 함수 안에서는 f를 써서 자기 자신을 참조하고, 함수 바깥에서는 g를 써서 함수를 호출합니다. 함수에 두 가지 이름을 붙이는 것이 좋을 이유는 없지만, 여기서 그렇게 한 이유는 이름 붙은 함수 표현식이 어떻게 동작하는지 명확하게 설명하기 위해서입니다. 함수 선언과 함수 표현식이 완전히 똑같이 보인다면, 자바스크립트는 둘을 어떻게 구분할까요? 차이가 있기는 한 걸까요? 답은 컨텍스트입니다. 함수 선언이 표현식으로 사용됐다면 그건 함수 표현식입니다. 표현식으로 사용되지 않았다면 함수 선언입니다. 이 차이는 다분히 이론적이며, 일반적으로는 이 차이에 대해 생각할 필요가 없습니다. 나중에 호출할 생각으로 함수를 만든다면 함수 선언을 사용하면 되고, 다른 곳에 할당하거나 다른 함수에 넘길 목적으로 함수를 만든다면 함수 표현식을 사용하면 됩니다. 복잡하게 생각할 필요는 없습니다.</summary></entry><entry><title type="html">6.5 this 키워드</title><link href="http://localhost:4000/javascript/2020/05/03/javascript111/" rel="alternate" type="text/html" title="6.5 this 키워드" /><published>2020-05-03T16:40:00+09:00</published><updated>2020-05-03T16:40:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/03/javascript111</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/03/javascript111/">&lt;p&gt;함수 바디 안에는 &lt;strong&gt;특별한 읽기 전용 값인 this가 있습니다.&lt;/strong&gt;&lt;br /&gt;
this는 일반적으로 객체지향 프로그래밍 개념에 밀접한 연관이 있습니다.&lt;br /&gt;
객체지향 프로그래밍에 대해서는 9장에서 더 설명합니다.&lt;br /&gt;
자바스크립트에서는 객체지향 프로그래밍 말고도 this를 사용하는 여러 가지 방법이 있습니다.&lt;/p&gt;

&lt;p&gt;일반적으로 this는 객체의 프로퍼티인 함수에서 의미가 있습니다.&lt;br /&gt;
메서드를 호출하면 this는 호출한 메서드를 소유하는 객체가 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Wallace&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;speak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`My name is &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;!`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;o.speak() 를 호출하면 this는 o에 묶입니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;speak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;My name is Wallace!&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;this는 함수를 어떻게 선언했느냐가 아니라 어떻게 호출했느냐에 따라 달라진다는 것을 이해해야 합니다.&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;
즉, this가 o에 묶인 이유는 speak가 o의 프로퍼티여서가 아니라, o에서 speak를 호출했기 때문입니다.&lt;br /&gt;
같은 함수를 변수에 할당하면 어떻게 되는지 봅시다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;speak&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;speak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;speak&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;speak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true; 두 변수는 같은 함수를 가리킵니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;speak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;My name is undefined!&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;함수를 이렇게 호출하면 자바스크립트는 이 함수가 어디에 속하는지 알 수 없으므로 this는 undefined에 묶입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;NOTE_&lt;/strong&gt;&lt;br /&gt;
앞의 예제에서 한 것처럼 함수의 this가 어디에 묶이는지 명확히 알 수 없도록 호출했을 때 this를 결정하는 방법은 매우 복잡합니다.&lt;br /&gt;
스트릭트 모드인지 아닌지에 따라 다르고,&lt;br /&gt;
함수를 어디에서 호출했느냐에 따라서도 다릅니다.&lt;br /&gt;
이런 상황은 피하는 것이 최선이므로 자세한 내용은 의도적으로 생략했습니다.&lt;br /&gt;
더 알고 싶다면 코드 포메팅에 관한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this&quot;&gt;MDN 문서&lt;/a&gt;를 보십시오&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;메서드&lt;/strong&gt;라는 용어는 원래 객체지향 프로그래밍의 개념이지만, 이 책에서는 객체의 프로퍼티이며 o.speak() 처럼 객체 인스턴스에서 호출할 의도로 만든 함수라는 뜻으로 사용합니다.&lt;br /&gt;
함수에서 this를 사용하지 않으면 어디에서 선언했든 관계없이 함수라고 부르겠습니다.&lt;/p&gt;

&lt;p&gt;중첩된 함수 안에서 this를 사용하려다 보면 혼란스러울 때가 많습니다.&lt;br /&gt;
다음 예제를 보십시오.&lt;br /&gt;
이 예제에는 메서드 안에 보조 함수가 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Julie&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;greetBackwards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getReverseName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nameBackwards&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
				&lt;span class=&quot;nx&quot;&gt;nameBackwards&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nameBackwards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getReverseName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; si eman ym ,olleH`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;greetBackwards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;앞의 예제에서는 이름을 거꾸로 쓰고자 중첩된 함수 getReverseName 를 사용했습니다.&lt;br /&gt;
하지만 getReverseName은 의도한 대로 동작하지 않습니다.&lt;br /&gt;
o.greetBackwards() 를 호출하는 시점에서 자바스크립트는 this를 의도한 대로 o에 연결하지만, greetBackwards 안에서 getReverseName 을 호출하면 this는 o가 아닌 다른 것에 묶입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;스트릭트 모드인지 아닌지에 따라 this는 undefined가 되기도 하고 전역 객체에 묶이기도 합니다.&lt;br /&gt;
앞서 말했듯, 이런 상황은 피하는 것이 최선이므로 자세한 내용은 설명하지 않습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이런 문제를 해결하기 위해 널리 사용하는 방법은 다른 변수에 this를 할당하는 겁니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Julie&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;greetBackwards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getReverseName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nameBackwards&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;nx&quot;&gt;nameBackwards&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nameBackwards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getReverseName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; si eman ym, olleH`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;greetBackwards&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 방법은 널리 쓰이는 방법이며, this를 self나 that에 할당하는 코드를 많이 보게 될겁니다.&lt;br /&gt;
&lt;strong&gt;이 장 후반에서 설명할 화살표 함수를 써도 이 문제를 해결할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">함수 바디 안에는 특별한 읽기 전용 값인 this가 있습니다. this는 일반적으로 객체지향 프로그래밍 개념에 밀접한 연관이 있습니다. 객체지향 프로그래밍에 대해서는 9장에서 더 설명합니다. 자바스크립트에서는 객체지향 프로그래밍 말고도 this를 사용하는 여러 가지 방법이 있습니다. 일반적으로 this는 객체의 프로퍼티인 함수에서 의미가 있습니다. 메서드를 호출하면 this는 호출한 메서드를 소유하는 객체가 됩니다. const o = { name: &quot;Wallace&quot;, speak() { return `My name is ${this.name}!`; }, } o.speak() 를 호출하면 this는 o에 묶입니다. o.speak(); // &quot;My name is Wallace!&quot; this는 함수를 어떻게 선언했느냐가 아니라 어떻게 호출했느냐에 따라 달라진다는 것을 이해해야 합니다. 즉, this가 o에 묶인 이유는 speak가 o의 프로퍼티여서가 아니라, o에서 speak를 호출했기 때문입니다. 같은 함수를 변수에 할당하면 어떻게 되는지 봅시다. const speak = o.speak; speak === o.speak; // true; 두 변수는 같은 함수를 가리킵니다. speak(); // &quot;My name is undefined!&quot; 함수를 이렇게 호출하면 자바스크립트는 이 함수가 어디에 속하는지 알 수 없으므로 this는 undefined에 묶입니다. NOTE_ 앞의 예제에서 한 것처럼 함수의 this가 어디에 묶이는지 명확히 알 수 없도록 호출했을 때 this를 결정하는 방법은 매우 복잡합니다. 스트릭트 모드인지 아닌지에 따라 다르고, 함수를 어디에서 호출했느냐에 따라서도 다릅니다. 이런 상황은 피하는 것이 최선이므로 자세한 내용은 의도적으로 생략했습니다. 더 알고 싶다면 코드 포메팅에 관한 MDN 문서를 보십시오 메서드라는 용어는 원래 객체지향 프로그래밍의 개념이지만, 이 책에서는 객체의 프로퍼티이며 o.speak() 처럼 객체 인스턴스에서 호출할 의도로 만든 함수라는 뜻으로 사용합니다. 함수에서 this를 사용하지 않으면 어디에서 선언했든 관계없이 함수라고 부르겠습니다. 중첩된 함수 안에서 this를 사용하려다 보면 혼란스러울 때가 많습니다. 다음 예제를 보십시오. 이 예제에는 메서드 안에 보조 함수가 있습니다. const o = { name: 'Julie', greetBackwards: function(){ function getReverseName() { let nameBackwards = ''; for(let i = this.name.length-1; i&amp;gt;=0; i--){ nameBackwards += this.name[i]; } return nameBackwards; } return `${getReverseName()} si eman ym ,olleH`; }, }; o.greetBackwards(); 앞의 예제에서는 이름을 거꾸로 쓰고자 중첩된 함수 getReverseName 를 사용했습니다. 하지만 getReverseName은 의도한 대로 동작하지 않습니다. o.greetBackwards() 를 호출하는 시점에서 자바스크립트는 this를 의도한 대로 o에 연결하지만, greetBackwards 안에서 getReverseName 을 호출하면 this는 o가 아닌 다른 것에 묶입니다. 스트릭트 모드인지 아닌지에 따라 this는 undefined가 되기도 하고 전역 객체에 묶이기도 합니다. 앞서 말했듯, 이런 상황은 피하는 것이 최선이므로 자세한 내용은 설명하지 않습니다. 이런 문제를 해결하기 위해 널리 사용하는 방법은 다른 변수에 this를 할당하는 겁니다. const o = { name: 'Julie', greetBackwards: function() { const self = this; function getReverseName() { let nameBackwards = ''; for(let i = self.name.length-1; i&amp;gt;=0; i--) { nameBackwards += self.name[i]; } return nameBackwards; } return `${getReverseName()} si eman ym, olleH`; }, }; o.greetBackwards(); 이 방법은 널리 쓰이는 방법이며, this를 self나 that에 할당하는 코드를 많이 보게 될겁니다. 이 장 후반에서 설명할 화살표 함수를 써도 이 문제를 해결할 수 있습니다.</summary></entry><entry><title type="html">6.4 객체의 프로퍼티인 함수</title><link href="http://localhost:4000/javascript/2020/05/03/javascript110/" rel="alternate" type="text/html" title="6.4 객체의 프로퍼티인 함수" /><published>2020-05-03T16:34:00+09:00</published><updated>2020-05-03T16:34:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/03/javascript110</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/03/javascript110/">&lt;p&gt;객체의 프로퍼티인 함수를 &lt;strong&gt;메서드(method)&lt;/strong&gt; 라고 불러서 일반적인 함수와 구별합니다.&lt;br /&gt;
함수와 메서드 사이에는 다른 차이도 있는데 그건 나중에 다시 설명합니다.&lt;br /&gt;
함수를 다른 객체에 추가할 수 있다는 것은 3장에서 이미 봤습니다.&lt;br /&gt;
객체 리터럴에서도 메서드를 추가할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Wallace&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 원시 값 프로퍼티&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;bark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Woof!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 함수 프로퍼티(메서드)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ES6에서는 간편하게 메서드를 추가할 수 있는 문법이 새로 생겼습니다.&lt;br /&gt;
다음 예제는 이전 예제와 동일합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Wallace&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 원시 값 프로퍼티&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;bark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Woof!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 함수 프로퍼티(메서드)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">객체의 프로퍼티인 함수를 메서드(method) 라고 불러서 일반적인 함수와 구별합니다. 함수와 메서드 사이에는 다른 차이도 있는데 그건 나중에 다시 설명합니다. 함수를 다른 객체에 추가할 수 있다는 것은 3장에서 이미 봤습니다. 객체 리터럴에서도 메서드를 추가할 수 있습니다. const o = { name: &quot;Wallace&quot;, // 원시 값 프로퍼티 bark: function () { return &quot;Woof!&quot;; }, // 함수 프로퍼티(메서드) } ES6에서는 간편하게 메서드를 추가할 수 있는 문법이 새로 생겼습니다. 다음 예제는 이전 예제와 동일합니다. const o = { name: &quot;Wallace&quot;, // 원시 값 프로퍼티 bark() { return &quot;Woof!&quot;; }, // 함수 프로퍼티(메서드) }</summary></entry><entry><title type="html">6.3.3 매개변수 기본값</title><link href="http://localhost:4000/javascript/2020/05/03/javascript109/" rel="alternate" type="text/html" title="6.3.3 매개변수 기본값" /><published>2020-05-03T16:29:00+09:00</published><updated>2020-05-03T16:29:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/03/javascript109</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/03/javascript109/">&lt;p&gt;ES6에서는 매개변수에 &lt;strong&gt;기본값(default value)&lt;/strong&gt; 을 지정하는 기능도 추가됐습니다.&lt;br /&gt;
일반적으로 매개변수에 값을 제공하지 않으면 undefined가 값으로 할당됩니다.&lt;br /&gt;
ES6에서는 기본값을 지정할 수 있습니다.&lt;br /&gt;
다음 예제를 보십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; - &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; - &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;5 - 6 - 7&quot;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;5 - 6 - 3&quot;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;5 - default - 3&quot;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;undefined - default - 3&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">ES6에서는 매개변수에 기본값(default value) 을 지정하는 기능도 추가됐습니다. 일반적으로 매개변수에 값을 제공하지 않으면 undefined가 값으로 할당됩니다. ES6에서는 기본값을 지정할 수 있습니다. 다음 예제를 보십시오. function f(a, b=&quot;default&quot;, c=3) { return `${a} - ${b} - ${c}`; } f(5, 6, 7); // &quot;5 - 6 - 7&quot; f(5, 6); // &quot;5 - 6 - 3&quot; f(5); // &quot;5 - default - 3&quot; f(); // &quot;undefined - default - 3&quot;</summary></entry></feed>