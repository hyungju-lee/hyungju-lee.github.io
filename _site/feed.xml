<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LEE HYUNG JU</title>
    <description>Jekyll Blog</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 09 Jun 2020 01:02:09 +0900</pubDate>
    <lastBuildDate>Tue, 09 Jun 2020 01:02:09 +0900</lastBuildDate>
    <generator>Jekyll v4.0.1</generator>
    
      <item>
        <title>1. ES6+ 기초편 1회차</title>
        <description>&lt;h2 id=&quot;1-es6-기초편-1회차&quot;&gt;1. ES6+ 기초편 1회차&lt;/h2&gt;

&lt;h3 id=&quot;why-did-you-do-that-도대체-코드-왜-그렇게-짰어&quot;&gt;Why did you do that? 도대체 코드 왜 그렇게 짰어?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;철학
    &lt;ul&gt;
      &lt;li&gt;합리주의&lt;/li&gt;
      &lt;li&gt;상대주의&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;상대주의, 무엇을 기준으로 판단할 것인가.&lt;br /&gt;
모두가 동의할 수 있는 기준을 만들자.&lt;br /&gt;
그 모두가 동의할 수 있는 기준을 만들 때 합리주의 철학이 사용된다.&lt;/p&gt;

&lt;p&gt;합리주의와 상대주의는 서로 상보하는 관계. 서로 대립하거나 반대되는 개념이 아니다.&lt;br /&gt;
상대주의와 대립되는 경우는 오히려 절대주의일 것.&lt;/p&gt;

&lt;p&gt;프로그래밍 세계엔 이런 개념들이 깔려있다.&lt;/p&gt;

&lt;h3 id=&quot;프로그래밍을-짤-때-왜-이렇게짰어-를-설명할-때-세-가지를-생각하자&quot;&gt;프로그래밍을 짤 때 왜 이렇게짰어? 를 설명할 때 세 가지를 생각하자.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;가치&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;의사소통 - 쉽게 알아볼 수 있다.&lt;/li&gt;
      &lt;li&gt;단순함 - 복잡해서 단순화했다.&lt;/li&gt;
      &lt;li&gt;유연함 - 여러 케이스를 고려, 플러그인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;원칙&lt;/strong&gt;&lt;br /&gt;
원칙을 지켜야 예외 현상, 오류가 생겼을 때 빠르게 알 수 있다.  &lt;br /&gt;
원칙을 정할 땐 당연히 중요한 것들만 원칙으로 정해야 한다. 항상 지켜야되기 때문에 힘들기 때문. 수고로움이 더 많이 들어간다.  &lt;br /&gt;
따라서 가치보다 원칙을 정할 때 더 신중해야 한다.&lt;br /&gt;
원칙은 최소화해라.
    &lt;ul&gt;
      &lt;li&gt;지역화 - 전역변수 쓰지마.&lt;/li&gt;
      &lt;li&gt;중복제거 - 똑같은 모듈, 함수 다 하나로 통일해. 유지보수 힘들어.&lt;/li&gt;
      &lt;li&gt;대칭성 - get/set, add/remove…쌍을 맞춰라! 되도록!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;패턴&lt;/strong&gt;&lt;br /&gt;
선배들의 경험.&lt;br /&gt;
역사상 디버깅 비용이 줄은 경우가 없다. 예전이나 지금이나 디버깅 비용은 대략 60%.&lt;br /&gt;
선배들의 조언이 유용하다는 증거.&lt;br /&gt;
경험도 반복되면 진리에 가까워진다.&lt;br /&gt;
과학기술은 연역적으로 도출되는 것이 많다. 대부분의 학문들도..&lt;br /&gt;
경험에 의해 나왔다고 해서 이론베이스 지식보다 약할거라는 생각은 하지마라.&lt;br /&gt;
오히려 더 강할 수도 있다.&lt;br /&gt;
왜냐하면 검증을 많이 했기 때문.
    &lt;ul&gt;
      &lt;li&gt;개발론 - 함수 지향 개발, 객체 지향 개발 등&lt;/li&gt;
      &lt;li&gt;설계론 - 어떻게 설계를 할 것인가&lt;/li&gt;
      &lt;li&gt;각종 적용 패턴 - 어디서 함수를 쓰고 어디서 클래스를 쓸 것인가. 함수를 두 개로 나눌것인가 말것인가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;켄트 벡의 구현 패턴&lt;/strong&gt;과 같은 책을 구입해서 읽으면 좋다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;마지막-단계&quot;&gt;마지막 단계&lt;/h3&gt;

&lt;p&gt;그래서 내가 왜 이렇게 코드를 짰는데? 라는 이유의 동기 : &lt;strong&gt;돈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;너 왜 그래프 만들랬더니 사왔어?&lt;br /&gt;
제가 직접하면 비용이 세 배로 들어요.&lt;br /&gt;
너 왜 앵귤러 썼어?&lt;br /&gt;
제가 이걸 바닥부터 만들면 지옥입니다. 앵귤러 쓰는게 훨씬 나아요.&lt;/p&gt;

&lt;p&gt;https://www.youtube.com/watch?v=0j_eGoF8Q98&amp;amp;list=PLBNdLLaRx_rIF3jAbhliedtfixePs5g2q&lt;br /&gt;
24:08&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Jun 2020 23:04:00 +0900</pubDate>
        <link>http://localhost:4000/codespitz/2020/06/08/codespitz01.html</link>
        <guid isPermaLink="true">http://localhost:4000/codespitz/2020/06/08/codespitz01.html</guid>
        
        
        <category>codespitz</category>
        
      </item>
    
      <item>
        <title>1.2 서버로서의 노드</title>
        <description>&lt;h2 id=&quot;12-서버로서의-노드&quot;&gt;1.2 서버로서의 노드&lt;/h2&gt;

&lt;p&gt;이 절에서는 노드를 서버로 사용할 때의 특징과 장단점에 대해 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;노드가 싱글 스레드, 논블로킹 모델을 사용하므로 노드 서버 또한 동일한 모델일 수밖에 없습니다.&lt;br /&gt;
따라서 노드 서버의 장단점은 싱글 스레드, 논블로킹 모델의 장단점과 크게 다르지 않습니다.&lt;br /&gt;
&lt;strong&gt;싱글 스레드여서 멀티 스레드 방식보다는 컴퓨터 자원을 적게 사용하는 장점이 있지만, CPU 코어를 하나밖에 사용하지 못하는 단점도 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;노드 서버는 I/O가 많은 작업에 적합합니다.&lt;br /&gt;
노드는 &lt;strong&gt;libuv 라이브러리&lt;/strong&gt;를 사용하여 I/O 작업을 논블로킹 방식으로 처리해줍니다.&lt;br /&gt;
따라서 스레드 하나가 많은 수의 I/O를 혼자서도 감당할 수 있습니다.&lt;br /&gt;
하지만 CPU 부하가 큰 작업에는 적합하지 않습니다.&lt;br /&gt;
여러분이 작성하는 코드는 모두 스레드 하나에서 처리됩니다.&lt;br /&gt;
여러분의 코드가 CPU 연산을 많이 요구하면 블로킹이 발생해 스레드 하나가 감당하기 어렵습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;싱글 스레드 방식의 프로그래밍은 멀티 스레드 방식보다 상대적으로 쉽습니다.&lt;/strong&gt;&lt;br /&gt;
서버 프로그래밍에 익숙하지 않은 사람도 쉽게 입문할 수 있습니다.&lt;br /&gt;
하지만 싱글 스렏이다 보니 하나뿐인 스레드가 에러로 인해 멈추지 않도록 잘 관리해야 합니다.&lt;br /&gt;
에러를 제대로 처리하지 못하면 서버 전체가 멈추기 때문입니다.&lt;/p&gt;

&lt;p&gt;또한, 웹 서버가 내장되어 있어 입문자가 쉽게 접근할 수 있습니다.&lt;br /&gt;
노드 외의 서버를 개발하다 보면 Apache, nginx, IIS 처럼 별도의 웹 서버를 설치해야 하는 경우가 많습니다.&lt;br /&gt;
심지어 Tomcat 같은 웹 애플리케이션 서버(WAS)를 추가로 설치하는 경우도 있습니다.&lt;br /&gt;
이 경우 프로그래밍 외에도 웹 서버와 WAS 사용법을 익혀야 합니다.&lt;br /&gt;
하지만 노드는 내장된 웹 서버를 사용하면 되므로 편리합니다.&lt;br /&gt;
하지만 나중에 서버 규모가 커지면 결국 nginx 등의 웹 서버를 노드 서버와 연결해야 합니다.&lt;/p&gt;

&lt;p&gt;노드 사용자들이 말하는 가장 큰 장점은 언어로 자바스크립트를 사용한다는 것입니다.&lt;br /&gt;
웹 브라우저도 자바스크립트를 사용하므로 서버까지 노드를 사용하면 하나의 언어로 웹 사이트를 개발할 수 있습니다.&lt;br /&gt;
이는 개발 생산성을 획기적으로 높여주었고, 생산성이 중요한 기업이 노드를 체택하는 이유가 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;노드는 생산성은 매우 좋지만, Go처럼 비동기에 강점을 보이는 언어나 nginx처럼 정적 파일 제공, 로드 밸런싱에 특화된 서버에 비해서는 속도가 느립니다.&lt;/strong&gt;&lt;br /&gt;
그렇긴 해도 극단적인 성능이 필요하지 않다면 이러한 단점은 노드의 생산성으로 어느 정도 극복할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;자바스크립트를 사용하기 때문에 얻을 수 있는 소소한 장점도 있습니다.&lt;/strong&gt;&lt;br /&gt;
요즘은 XML 대신 JSON을 사용해서 데이터를 주고 받는데, JSON이 자바스크립트 형식이어서 노드에서는 쉽게 처리할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;표 1-1&lt;/strong&gt; 노드의 장단점&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;장점&lt;/th&gt;
      &lt;th&gt;단점&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;멀티 스레드 방식에 비해 컴퓨터 자원을 적게 사용함&lt;/td&gt;
      &lt;td&gt;싱글 스레드라서 CPU 코어를 하나만 사용함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;I/O 작업이 많은 서버로 적합&lt;/td&gt;
      &lt;td&gt;CPU 작업이 많은 서버로는 부적합&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;멀티 스레드 방식보다 쉬움&lt;/td&gt;
      &lt;td&gt;하나뿐인 스레드가 멈추지 않도록 관리해야 함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;웹 서버가 내장되어 있음&lt;/td&gt;
      &lt;td&gt;서버 규모가 커졌을 때 서버를 관리하기 어려움&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;자바스크립트를 사용&lt;/td&gt;
      &lt;td&gt;어중간한 성능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;JSON 형식과 호환하기 쉬움&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;p&gt;이와 같은 특성을 활용하려면 노드를 어디에 사용해야 할까요?&lt;br /&gt;
개수는 많지만 크기는 작은 데이터를 실시간으로 주고 받는 데 적합합니다.&lt;br /&gt;
&lt;strong&gt;네트워크나 데이터베이스, 디스크 작업 같은 I/O에 특화되어 있기 때문입니다.&lt;/strong&gt;&lt;br /&gt;
실시간 채팅 애플리케이션이나 주식 차트, JSON 데이터를 제공하는 API 서버가 노드를 많이 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;노드가 아무리 좋다고 하더라도 추천하지 않는 경우도 있습니다.&lt;/strong&gt;&lt;br /&gt;
이미지나 비디오 처리, 대규모 데이터 처리 같이 CPU를 많이 사용하는 작업을 위한 서버로는 권장하지 않습니다.&lt;br /&gt;
노드보다 더 적합한 다른 언어 서버가 많습니다.&lt;br /&gt;
&lt;strong&gt;요즘은 AWS Lambda나 Google Cloud Functions 같은 서비스에서 &lt;span style=&quot;color:red&quot;&gt;노드로 CPU를 많이 사용하는 작업을 처리하는 것을 지원&lt;/span&gt;합니다.&lt;/strong&gt;&lt;br /&gt;
16장에서 사용해볼 것입니다.&lt;/p&gt;

&lt;p&gt;그렇다면 실생활과 밀접한 쇼핑몰, 블로그 같은 웹 사이트에는 적합할까요?&lt;br /&gt;
이런 사이트는 보통 기본적인 틀이 있고, 그 안의 내용물(텍스트, 이미지)만 조금씩 달라집니다.&lt;br /&gt;
&lt;strong&gt;노드가 다른 서버 언어에 비해 이러한 컨텐츠를 제공하는 데 장점이 뚜렷하지는 않습니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;하지만 그렇다고 적합하지 않다는 것도 아닙니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;Pug나 EJS 같은 템플릿 엔진을 통해서 다른 언어와 비슷하게 컨텐츠를 제공할 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
템플릿 엔진은 6.5절에서 다룹니다.&lt;/p&gt;

&lt;p&gt;안전성과 보안성 측면의 문제도 이미 충분히 검증되었습니다.&lt;br /&gt;
규모가 큰 곳을 꼽자면 미국항공우주국(NASA), 에어비엔비, 우버, 넷플릭스, 링크드인 등에서 노드를 사용하고 있습니다.&lt;br /&gt;
페이팔, 월마트, 이베이 같은 결제 시스템을 사용하는 대기업들도 노드로 서비스를 운영합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image11.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Jun 2020 16:09:00 +0900</pubDate>
        <link>http://localhost:4000/nodebook/2020/06/08/node06.html</link>
        <guid isPermaLink="true">http://localhost:4000/nodebook/2020/06/08/node06.html</guid>
        
        
        <category>nodebook</category>
        
      </item>
    
      <item>
        <title>1.1.5 싱글 스레드</title>
        <description>&lt;h2 id=&quot;115-싱글-스레드&quot;&gt;1.1.5 싱글 스레드&lt;/h2&gt;

&lt;p&gt;이벤트 기반, 논블로킹 모델과 더불어 노드를 설명할 때 자주 나오는 용어가 하나 더 있습니다.&lt;br /&gt;
바로 &lt;strong&gt;싱글 스레드&lt;/strong&gt;입니다.&lt;br /&gt;
스레드를 이해하기 위해서는 프로세스도 알아야 하지만, 지금은 그냥 스레드가 컴퓨터 작업을 처리할 수 있는 일손이라고 생각하면 됩니다.&lt;br /&gt;
조금 뒤에 자세히 알아봅니다.&lt;/p&gt;

&lt;p&gt;노드가 싱글 스레드라는 말을 들어보셨나요?&lt;br /&gt;
노드는 싱글 스레드이므로 주어진 작업을 혼자서 처리해야 합니다.&lt;br /&gt;
반대로 멀티 스레드인 시스템에서는 여러 개의 스레드가 일을 나눠서 처리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;자바스크립트와 노드에서 논블로킹이 중요한 이유는 바로 싱글 스레드이기 때문입니다.&lt;/strong&gt;&lt;br /&gt;
한 번에 한 가지 일밖에 처리하지 못하므로 어떠한 작업에서 블로킹이 발생하면 다음 일을 처리하지 못합니다.&lt;/p&gt;

&lt;p&gt;언뜻 보면 여러 개의 일을 동시에 처리할 수 있기 때문에 멀티 스레드가 싱글 스레드보다 좋아 보입니다.&lt;br /&gt;
하지만 꼭 그런 것만은 아닙니다.&lt;br /&gt;
이해를 돕기 위한 예시를 하나 들어보겠습니다.&lt;/p&gt;

&lt;p&gt;한 음식점에 점원이 한 명 있습니다.&lt;br /&gt;
손님은 여러 명이고요.&lt;br /&gt;
점원 한 명이 주문을 받아 주방에 넘기고, 주방에서 요리가 나오면 손님에게 서빙을 합니다.&lt;br /&gt;
그 후 다음 손님의 주문을 받습니다.&lt;br /&gt;
이런 구조라면 다음 손님은 이전 손님의 요리가 나올 때까지 아무것도 못 하고 기다리고 있어야 합니다.&lt;br /&gt;
이것이 바로 싱글 스레드(점원), 블로킹 모델입니다.&lt;br /&gt;
매우 비효율적입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image07.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 점원이 한 손님의 주문을 받고, 주방에 주문 내역을 넘긴 뒤 다음 손님의 주문을 받습니다.&lt;br /&gt;
요리가 끝나길 기다리지 않고 주문이 들어왔다는 것만 알려주는 것입니다.&lt;br /&gt;
주방에서 요리가 완료되면 완료된 순서대로 손님에게 서빙합니다.&lt;br /&gt;
주문한 순서와 서빙하는 순서가 일치하지 않을 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이것이 싱글 스레드, 논블로킹 모델입니다.&lt;/strong&gt;&lt;br /&gt;
바로 노드가 채택하고 있는 방식입니다.&lt;br /&gt;
점원은 한 명이지만 혼자서 많은 일을 처리할 수 있습니다.&lt;br /&gt;
하지만 그 점원 한 명이 아파서 쓰러지거나 하면 큰 문제가 생길 수 있습니다.&lt;br /&gt;
또한, 주문을 받거나 서빙을 하는 데 시간이 오래 걸린다면 주문이 많이 들어 왔을 때 버거울 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image08.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;멀티 스레드 방식에서는 손님이 올 때마다 점원이 한 명씩 맡아 주문을 받고 서빙합니다.&lt;br /&gt;
언뜻 보면 싱글 스레드보다 좋은 방법인 것 같지만, 장단점이 있습니다.&lt;br /&gt;
일단 손님 한 명당 점원도 한 명이면 서빙 자체는 걱정이 없습니다.&lt;br /&gt;
점원 한 명에게 문제가 생겨도 다른 점원으로 대체하면 되기 때문입니다.&lt;br /&gt;
하지만 손님의 수가 늘어날수록 점원의 수도 늘어납니다.&lt;br /&gt;
손님의 수가 줄어들었을 때 일을 하지 않고 노는 점원도 있다는 것도 문제가 됩니다.&lt;br /&gt;
점원을 새로 고용하거나 기존 직원을 해고하는 데는 비용이 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image09.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 점원 여러 명(멀티 스레드)이 모두 논블로킹 방식으로 주문을 받으면 더 좋지 않을까 하는 의문이 들 수 있습니다.&lt;br /&gt;
실제로 그렇습니다.&lt;br /&gt;
노드도 싱글 스레드 여러 개를 사용해 멀티 스레딩과 비슷한 기능을 하게 할 수 있습니다.&lt;br /&gt;
하지만 엄밀히 말하면 멀티 스레딩이라기보다는 멀티 프로세싱에 가깝습니다.&lt;br /&gt;
그럼 프로세스와 스레드의 차이에 대해 알아봅시다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;프로세스&lt;/strong&gt;는 운영체제에서 할당하는 작업의 단위입니다.&lt;br /&gt;
노드나 인터넷 브라우저 같은 프로그램은 개별적인 프로세스입니다.&lt;br /&gt;
프로세스 간에는 메모리 등의 자원을 공유하지 않습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;스레드&lt;/strong&gt;는 프로세스 내에서 실행되는 흐름의 단위입니다.&lt;br /&gt;
하나의 프로세스는 스레드를 여러 개 가질 수 있습니다.&lt;br /&gt;
스레드들은 부모 프로세스의 자원을 공유합니다.&lt;br /&gt;
즉, 같은 메모리에 접근할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스레드를 작업을 처리하는 일손으로 표현하기도 하는데, 노드 프로세스는 일손이 하나인 셈입니다.&lt;br /&gt;
요청이 많이 들어오면 한 번에 하나의 요청을 처리합니다.&lt;br /&gt;
블로킹이 심하게 일어나지만 않는다면 하나로도 충분합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;사실 노드 프로세스도 내부적으로는 스레드를 여러 개 가지고 있습니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;하지만 여러분이 직접 제어할 수 있는 스레드는 하나뿐이므로 흔히 싱글 스레드라고 부르는 것입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image10.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;노드는 스레드를 늘리는 대신, 프로세스 자체를 복사해 여러 작업을 동시에 처리하는 멀티 프로세싱 방식을 택했습니다.&lt;br /&gt;
자바스크립트 언어 자체가 싱글 스레드 특성을 띠고 있기 때문입니다.&lt;br /&gt;
4.5절의 &lt;strong&gt;cluster 모듈&lt;/strong&gt;과 15.1.5절의 &lt;strong&gt;pm2 패키지&lt;/strong&gt;에서 멀티 프로세싱을 가능하게 하는 방법에 대해 알아봅니다.&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Jun 2020 09:57:00 +0900</pubDate>
        <link>http://localhost:4000/nodebook/2020/06/08/node05.html</link>
        <guid isPermaLink="true">http://localhost:4000/nodebook/2020/06/08/node05.html</guid>
        
        
        <category>nodebook</category>
        
      </item>
    
      <item>
        <title>1.1.4 논블로킹 I/O</title>
        <description>&lt;h2 id=&quot;114-논블로킹-io&quot;&gt;1.1.4 논블로킹 I/O&lt;/h2&gt;

&lt;p&gt;이벤트 루프를 잘 활용하면 오래 걸리는 작업을 효율적으로 처리할 수 있습니다.&lt;br /&gt;
오래 걸리는 함수를 백그라운드로 보내서 다음 코드가 먼저 실행되게 하고, 그 함수가 다시 테스크 큐를 
거쳐 호출 스택으로 올라오기를 기다리는 방식입니다.&lt;br /&gt;
&lt;strong&gt;이 방식이 논블로킹 방식입니다.&lt;/strong&gt;&lt;br /&gt;
논블로킹이란 이전 작업이 완료될 때까지 멈추지 않고 다음 작업을 수행함을 뜻합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image06.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 1-9를 부면 블로킹보다 논블로킹 방식이 같은 작업을 더 짧은 시간 동안 처리할 수 있음을 알 수 있습니다.&lt;br /&gt;
하지만 &lt;strong&gt;싱글 스레드&lt;/strong&gt;라는 한계 때문에 자바스크립트의 모든 코드가 이 방식으로 시간적 이득을 볼 수 있는 것은 
아닙니다.&lt;br /&gt;
&lt;strong&gt;현재 노드 프로세스 외의 &lt;span style=&quot;color:red&quot;&gt;다른 컴퓨팅 자원을 사용할 수 있는 I/O 작업&lt;/span&gt;이 주로 시간적 이득을 많이 봅니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;io-작업&quot;&gt;I/O 작업&lt;/h3&gt;

&lt;p&gt;I/O는 입력(input)/출력(output)을 의미합니다.&lt;br /&gt;
파일 시스템 접근(파일 읽기, 쓰기, 폴더 만들기 등)이나 네트워크 요청 같은 작업이 I/O의 일종입니다.&lt;br /&gt;
이러한 작업을 할 때 노드는 논블로킹 방식으로 동작합니다.&lt;/p&gt;

&lt;h3 id=&quot;블로킹논블로킹-동기비동기&quot;&gt;블로킹/논블로킹, 동기/비동기&lt;/h3&gt;

&lt;p&gt;블로킹과 논블로킹 말고도 동기와 비동기라는 개념에 대해서도 들어보았을 겁니다.&lt;br /&gt;
이 개념은 코드를 보지 않고서는 이해하기 어렵습니다.&lt;br /&gt;
동기와 비동기, 블로킹과 논블로킹의 관계는 3.6.1절에서 코드와 함께 설명합니다.&lt;br /&gt;
그 전까지는 동기와 블로킹이 유사하고, 비동기와 논블로킹이 유사하다고만 알아두면 됩니다.&lt;/p&gt;

&lt;p&gt;다음 예제는 블로킹 방식의 코드입니다.&lt;br /&gt;
콘솔 결과를 미리 예측해보세요.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;longRunningTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 오래 걸리는 작업&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;작업 끝&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;시작&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;longRunningTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;다음 작업&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;시작
작업 끝
다음 작업
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;작업을 수행하는 데 오래 걸리는 longRunningTask 함수가 있다고 가정해봅시다.&lt;br /&gt;
이 작업이 완료되기 전까지는 이어지는 &lt;strong&gt;console.log(‘다음 작업)&lt;/strong&gt;이 호출되지 않습니다.&lt;/p&gt;

&lt;p&gt;이번에는 setTimeout을 사용해서 코드를 바꿔보겠습니다.&lt;br /&gt;
&lt;strong&gt;논블로킹 방식의 코드입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;longRunningTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 오래 걸리는 작업&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;작업 끝&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;시작&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;longRunningTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;다음 작업&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;시작
다음 작업
작업 끝
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;setTimeout(콜백, 0)&lt;/strong&gt;은 코드를 논블로킹으로 만들기 위해 사용하는 기법 중 하나입니다.&lt;br /&gt;
노드에서는 &lt;strong&gt;setTimeout(콜백, 0)&lt;/strong&gt; 대신 다른 방식을 주로 사용합니다(3.4.3절 참조).&lt;br /&gt;
이벤트 루프를 이해했다면 &lt;strong&gt;setTimeout&lt;/strong&gt;의 콜백 함수가 태스크 큐로 보내지므로 순서대로 실행되지 않는다는 것을 
알 수 있습니다.&lt;br /&gt;
다음 작업이 먼저 실행된 후, 오래걸리는 작업이 완료됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;setTimeout(콜백, 0)&lt;/strong&gt;&lt;br /&gt;
밀리초를 0으로 설정했으므로 바로 실행되는 것이 아닌가 착각할 수 있습니다.&lt;br /&gt;
하지만 브라우저와 노드에서는 기본적인 지연 시간이 있으므로 바로 실행되지 않습니다.&lt;br /&gt;
HTML5 브라우저에서는 4ms, 노드에서는 1ms의 지연 시간이 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 08 Jun 2020 01:12:00 +0900</pubDate>
        <link>http://localhost:4000/nodebook/2020/06/08/node04.html</link>
        <guid isPermaLink="true">http://localhost:4000/nodebook/2020/06/08/node04.html</guid>
        
        
        <category>nodebook</category>
        
      </item>
    
      <item>
        <title>1.1.3 이벤트 기반</title>
        <description>&lt;h2 id=&quot;113-이벤트-기반&quot;&gt;1.1.3 이벤트 기반&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;이벤트 기반(event-driven)&lt;/strong&gt;이란 &lt;strong&gt;이벤트가 발생할 때&lt;/strong&gt; 미리 지정해둔 작업을 수행하는 방식을 의미합니다.&lt;br /&gt;
이벤트로는 클릭이나 네트워크 요청 등이 있을 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두어야 합니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;이것을 이벤트 리스너(event listener)에 콜백(callBack) 함수를 등록한다고 표현합니다.&lt;/strong&gt;&lt;br /&gt;
버튼을 누르면 경고 창을 띄우도록 설정하는 것을 예로 들어 보겠습니다.&lt;br /&gt;
클릭 이벤트 리스너에 경고 창을 띄우는 콜백 함수를 등록해두면 클릭 이벤트가 발생할 때마다 콜백 함수가 
실행돼 경고 창이 뜨는 것입니다.&lt;/p&gt;

&lt;p&gt;노드도 이벤트 기반 방식으로 동작하므로 이벤트가 발생하면 이벤트 리스너에 등록해둔 콜백 함수를 
호출합니다.&lt;br /&gt;
발생한 이벤트가 없거나 발생했던 이벤트를 다 처리하면 노드는 다음 이벤트가 발생할 때까지 대기합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image01.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;이벤트-루프&quot;&gt;이벤트 루프&lt;/h3&gt;

&lt;p&gt;이벤트 기반 모델에서는 이벤트 루프라는 개념이 등장합니다.&lt;br /&gt;
여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단합니다.&lt;br /&gt;
이 책은 여러분이 자바스크립트의 기초 지식을 알고 있다고 가정하므로 이벤트 루프 역시 이미 알고 있다고 생각하고 넘어갈 것입니다.&lt;br /&gt;
하지만 노드와 자바스크립트에서 이벤트 루프는 정말 중요한 개념이니 간략히만 설명하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;노드는 자바스크립트 코드에서 맨 위부터 한 줄씩 실행합니다.&lt;br /&gt;
함수 호출 부분을 발견하면 호출한 함수를 &lt;strong&gt;호출 스택&lt;/strong&gt;에 넣습니다.&lt;br /&gt;
다음 코드가 콘솔(브라우저 콘솔을 사용하면 됩니다. 크롬의 경우 F12를 눌렀을 때 나오는 개발자 도구의 Console 탭입니다)에 
어떤 로그를 남길지 예측해보세요.&lt;br /&gt;
만약 예측하기 어렵다면 자바스크립트를 복습해야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;첫 번째&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;third&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;두 번째&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;third&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;세 번째&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image02.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 1-5에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 함수는 &lt;strong&gt;처음 실행 시의 전역 컨텍스트&lt;/strong&gt;를 의미합니다.&lt;br /&gt;
&lt;strong&gt;컨텍스트는 함수가 호출되었을 때 생성되는 환경을 의미합니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;자바스크립트는 실행 시 기본적으로 전역 컨텍스트 안에서 돌아간다고 생각하는 게 좋습니다.&lt;/strong&gt;&lt;br /&gt;
함수의 실행이 완료되면 호출 스택에서 지워집니다.&lt;br /&gt;
third, second, first, main 순으로 지워지고, main 함수까지 실행이 모두 완료되었다면 호출 스택은 비어있게 됩니다.&lt;/p&gt;

&lt;p&gt;콘솔의 출력 결과는 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;세 번째
두 번째
첫 번째
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이번에는 특정 밀리초(1000분의 1초) 이후에 코드를 실행하는 setTimeout을 사용하겠습니다.&lt;br /&gt;
콘솔에 어떤 로그가 기록될지 예측해보세요.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;3초 후 실행&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;시작&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;끝&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;결과는 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;시작
끝
3초 후 실행
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3초 뒤에 run 함수를 실행하는 코드입니다.&lt;br /&gt;
콘솔 결과는 쉽게 예측할 수 있지만, 호출 스택으로 설명하기는 힘듭니다.&lt;br /&gt;
&lt;strong&gt;setTimeout 함수의 콜백인 run이 호출 스택에 언제 들어가는지 알기 어렵기 때문입니다.&lt;/strong&gt;&lt;br /&gt;
이를 파악하기 위해서는 &lt;strong&gt;이벤트 루프&lt;/strong&gt;, &lt;strong&gt;테스트 큐&lt;/strong&gt;, &lt;strong&gt;백그라운드&lt;/strong&gt;를 알아야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;이벤트 루프&lt;/strong&gt;&lt;br /&gt;
이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당합니다.&lt;br /&gt;
노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프라고 불립니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;테스크 큐&lt;/strong&gt;&lt;br /&gt;
이벤트 발생 후 호출되어야 할 콜백 함수들이 기다리는 공간입니다.&lt;br /&gt;
콜백들이 이벤트 루프가 정한 순서대로 줄을 서 있으므로 콜백 큐라고도 부릅니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;백그라운드&lt;/strong&gt;&lt;br /&gt;
타이머나 I/O 작업 콜백 또는 이벤트 리스너들이 대기하는 곳입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image03.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 전역 컨텍스트인 main 함수가 호출 스택에 들어갑니다.&lt;br /&gt;
그 뒤 setTimeout이 호출 스택에 들어갑니다.&lt;/p&gt;

&lt;p&gt;호출 스택에 들어간 순서와 반대로 실행되므로 setTimeout이 먼저 실행됩니다.&lt;br /&gt;
setTimeout이 실행되면 타이머와 함께 run 콜백을 백그라운드로 보내고 호출 스택에서 빠집니다.&lt;br /&gt;
그 다음으로 main 함수가 호출 스택에서 빠집니다.&lt;br /&gt;
백그라운드에서는 3초를 센 후 run 함수를 테스크 큐로 보냅니다.&lt;/p&gt;

&lt;p&gt;그림상으로는 테스크 큐가 하나의 큐처럼 보이지만 실제로는 여러 개의 큐로 이루어져 있습니다.&lt;br /&gt;
이벤트 루프는 정해진 규칙에 따라 콜백 함수들을 호출 스택으로 부릅니다.&lt;br /&gt;
더 자세히 공부하고 싶다면 1.5절의 이벤트 루프 설명에 대한 자료를 참고하세요.&lt;/p&gt;

&lt;p&gt;그림 1-7은 호출 스택에서 main까지 실행이 완료되어 호출 스택이 비어 있는 상황입니다.&lt;br /&gt;
이벤트 루프는 호출 스택이 비어 있으면 태스크 큐에서 함수를 하나씩 가져와 호출 스택에 넣고 실행합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image04.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 1-8은 이벤트 루프가 run 콜백을 테스크 큐에서 꺼내 호출 스택으로 올린 상황입니다.&lt;br /&gt;
호출 스택으로 올려진 run은 실행되고, 실행 완료 후 호출 스택에서 비워집니다.&lt;br /&gt;
이벤트 루프는 테스크 큐에 콜백 함수가 들어올 때까지 계속 대기하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image05.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 호출 스택에 함수들이 너무 많이 차 있으면 3초가 지난 후에도 run 함수가 실행되지 않을 수도 있습니다.&lt;br /&gt;
&lt;strong&gt;이벤트 루프는 호출 스택이 비어 있을 때만 테스크 큐에 있는 run 함수를 호출 스택으로 가져오니까요.&lt;/strong&gt;&lt;br /&gt;
이것이 setTimeout의 시간이 정확하지 않을 수도 있는 이유입니다.&lt;/p&gt;

</description>
        <pubDate>Sun, 07 Jun 2020 13:47:00 +0900</pubDate>
        <link>http://localhost:4000/nodebook/2020/06/07/node03.html</link>
        <guid isPermaLink="true">http://localhost:4000/nodebook/2020/06/07/node03.html</guid>
        
        
        <category>nodebook</category>
        
      </item>
    
      <item>
        <title>1.1.2 자바스크립트 런타임</title>
        <description>&lt;h2 id=&quot;112-자바스크립트-런타임&quot;&gt;1.1.2 자바스크립트 런타임&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Node.js는 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임입니다.&lt;br /&gt;
Node.js는 이벤트 기반, 논블로킹 I/O 모델을 사용해 가볍고 효율적입니다.&lt;br /&gt;
Node.js의 패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리 생태계이기도 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;노드는 자바스크립트 런타임입니다.&lt;br /&gt;
런타임은 특정 언어로 만든 프로그램들을 실행할 수 있는 환경을 뜻합니다.&lt;br /&gt;
따라서 노드는 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있게 해줍니다.&lt;/p&gt;

&lt;p&gt;기존에는 자바스크립트 프로그램을 인터넷 브라우저(브라우저도 자바스크립트 런타임입니다) 위에서만 
실행할 수 있었습니다.&lt;br /&gt;
브라우저 외의 환경에서 자바스크립트를 실행하기 위한 여러 가지 시도가 있었으나, 
자바스크립트의 실행 속도 문제 때문에 모두 큰 호응을 얻지는 못했습니다.&lt;/p&gt;

&lt;p&gt;하지만 2008년 구글이 V8 엔진을 사용하여 크롬을 출시하자 이야기가 달라졌습니다.&lt;br /&gt;
당시 V8 엔진은 다른 자바스크립트 엔진과 달리 매우 빨랐고, 오픈 소스로 코드도 공개되었습니다.&lt;br /&gt;
속도 문제가 해결되자 라이언 달은 2009년 V8 엔진 기반의 노드 프로젝트를 시작했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image00.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;노드는 V8 오픈 소스 자바스크립트 엔진과 함께 libuv라는 라이브러리를 사용합니다.&lt;br /&gt;
V8과 libuv는 C와 C++로 구현되어있습니다.&lt;br /&gt;
여러분이 코딩한 자바스크립트 코드는 노드가 알아서 V8과 libuv에 연결해주므로 노드를 사용할 때
C와 C++은 몰라도 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;libuv 라이브러리는 노드의 특성인 이벤트 기반, 논블로킹 I/O 모델을 구현하고 있습니다.&lt;/strong&gt;&lt;br /&gt;
노드는 스스로를 이벤트 기반, 논블로킹 I/O 모델을 사용해 가볍고 효율적이라고 표현했습니다.&lt;br /&gt;
그럼 이 모델이 무엇인지, 그리고 장단점으로는 어떤 것들이 있는지 알아봅시다.&lt;/p&gt;

</description>
        <pubDate>Sun, 07 Jun 2020 13:39:00 +0900</pubDate>
        <link>http://localhost:4000/nodebook/2020/06/07/node02.html</link>
        <guid isPermaLink="true">http://localhost:4000/nodebook/2020/06/07/node02.html</guid>
        
        
        <category>nodebook</category>
        
      </item>
    
      <item>
        <title>1. 핵심 개념 이해하기 &amp; 서버</title>
        <description>&lt;h2 id=&quot;11-핵심-개념-이해하기&quot;&gt;1.1 핵심 개념 이해하기&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Node.js&lt;/strong&gt;는 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임입니다.&lt;br /&gt;
Node.js는 이벤트 기반, 논블로킹 I/O 모델을 사용해 가볍고 효율적입니다.&lt;br /&gt;
Node.js의 패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리 생태계이기도 합니다.&lt;/p&gt;

&lt;h2 id=&quot;111-서버&quot;&gt;1.1.1 서버&lt;/h2&gt;

&lt;p&gt;노드를 통해 다양한 자바스크립트 애플리케이션을 실행할 수 있지만, 노드는 서버 애플리케이션을
실행하는 데 제일 많이 사용됩니다.&lt;/p&gt;

&lt;p&gt;그럼 서버란 무엇이며, 어떤 역할을 할까요?&lt;br /&gt;
서버는 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램을 말합니다.&lt;br /&gt;
클라이언트란 요청을 보내는 주체로, 브라우저일 수도 있고, 데스크톱 프로그램일 수도 있고, 
모바일 앱일 수도 있고, 다른 서버에 요청을 보내는 서버일 수도 있습니다.&lt;br /&gt;
여러분이 평소에 사용하는 웹 사이트나 앱을 생각해보세요.&lt;br /&gt;
웹 사이트의 화면(HTML)은 어디에서 가져올까요?&lt;br /&gt;
앱 설치 파일은 어디에서 내려받는 걸까요?&lt;/p&gt;

&lt;p&gt;예를 들어 XXX의 웹사이트를 방문한다고 생각해봅시다.&lt;br /&gt;
주소창에 XXX의 웹 사이트 주소를 입력(&lt;strong&gt;요청&lt;/strong&gt;)하면 브라우저는 그 주소에 해당하는 XXX의 컴퓨터
위치를 파악합니다.&lt;br /&gt;
그리고 그 컴퓨터에서 XXX의 웹 사이트 페이지를 받아와 요청자의 브라우저(클라이언트)에 띄워줍니다.(&lt;strong&gt;응답&lt;/strong&gt;)&lt;br /&gt;
&lt;strong&gt;이런 일을 하는 컴퓨터가 바로 서버입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;모바일 앱을 설치하는 경우를 생각해봅시다.&lt;br /&gt;
구글의 플레이 스토어나 애플의 앱스토어에서 원하는 앱을 골라서 설치 버튼을 누르면(&lt;strong&gt;요청&lt;/strong&gt;) 내려받기(&lt;strong&gt;응답&lt;/strong&gt;)가 시작됩니다.&lt;br /&gt;
앱 설치 파일은 이미 어딘가에 저장되어 있으므로 여러분이 그곳에서 데이터를 받아와 
모바일 기기에 설치할 수 있는 것입니다.&lt;br /&gt;
&lt;strong&gt;그 어딘가가 구글과 애플의 서버입니다.&lt;/strong&gt;&lt;br /&gt;
플레이 스토어와 앱스토어는 클라이언트 역할을 하는 것이고요.&lt;/p&gt;

&lt;p&gt;웹이나 앱을 사용할 때 여러분의 데이터(아이디, 비밀번호, 이메일 등)와 서비스의 데이터가 생성됩니다.&lt;br /&gt;
이 데이터를 어딘가에 저장하고, 그 어딘가에서 클라이언트로 데이터를 받아와야 합니다.&lt;br /&gt;
&lt;strong&gt;이곳이 바로 서버입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;서버라고 해서 요청에 대한 응답만 하는 것은 아닙니다.&lt;/span&gt;&lt;br /&gt;
다른 서버에 요청을 보낼 수도 있습니다.&lt;br /&gt;
&lt;strong&gt;이때는 요청을 보낸 서버가 클라이언트 역할을 합니다.&lt;/strong&gt;(&lt;strong&gt;상대적인 관점!!&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;정리하면 서버는 클라이언트의 요청에 대해 응답을 합니다.&lt;br /&gt;
응답으로 항상 YES를 해야 하는 것은 아니고, NO를 할 수도 있습니다.&lt;br /&gt;
여러분이 어떤 사이트로부터 차단 당했다면 그 사이트의 서버는 여러분의 요청에 매번 NO를 응답할 것입니다.&lt;/p&gt;

&lt;p&gt;노드는 자바스크립트 애플리케이션이 서버로서 기능하기 위한 도구를 제공하므로 서버 역할을 수행할 수 있습니다.&lt;br /&gt;
다른 언어를 사용하지 않고 왜 굳이 노드를 사용해 서버를 만드는지 의문이 들 수도 있습니다.&lt;br /&gt;
궁금증을 해결하려면 먼저 노드의 특성에 대해 알아야 합니다.&lt;br /&gt;
공식 사이트에 게시된 노드 소개글을 바탕으로 노드의 특성에 대해 알아봅시다.&lt;/p&gt;

</description>
        <pubDate>Sun, 07 Jun 2020 13:27:00 +0900</pubDate>
        <link>http://localhost:4000/nodebook/2020/06/07/node01.html</link>
        <guid isPermaLink="true">http://localhost:4000/nodebook/2020/06/07/node01.html</guid>
        
        
        <category>nodebook</category>
        
      </item>
    
      <item>
        <title>22.6 요약</title>
        <description>&lt;h2 id=&quot;226-요약&quot;&gt;22.6 요약&lt;/h2&gt;

&lt;p&gt;자바스크립트 개발자로 향하는 여정을 시작한 걸 환영합니다!&lt;br /&gt;
이 책의 내용 일부는 무척 어려웠을 수도 있지만, 이해하려고 노력한 만큼 자바스크립트의 기초를 
확고히 다질 수 있습니다.&lt;br /&gt;
어려운 부분이 많더라도 좌절할 필요는 없습니다.&lt;br /&gt;
자바스크립트는 복잡하고 강력한 언어이며 며칠 만에 배우는 건 불가능합니다.&lt;br /&gt;
1년 정도의 시간은 누구에게나 필요할 겁니다.&lt;br /&gt;
프로그래밍이 처음이라면 나중에 이 책을 다시 한번 읽어보길 권합니다.&lt;br /&gt;
처음에는 이해하지 못했던 부분에서 새로운 영감을 얻을 수 있을 겁니다.&lt;/p&gt;

&lt;p&gt;ES6와 함께 자바스크립트 개발에 새로운 물결이 밀려오고 있습니다.&lt;br /&gt;
전에는 볼 수 없었던 멋지고 기발한 아이디어도 그 물결과 함께 밀려오고 있습니다.&lt;br /&gt;
읽을 수 있는 것은 모두 읽고, 이야기를 나눌 수 있는 자바스크립트 프로그래머 모두와 이야기를 나누고, 
접하는 모든 것에서 배우십시오.&lt;br /&gt;
자바스크립트 개발 커뮤니티에는 깊은 지식과 톡톡 튀는 아이디어를 가진 사람이 정말 많습니다.&lt;br /&gt;
필자는 이 책을 읽은 여러분도 그런 사람이 되길 진심으로 바랍니다.&lt;/p&gt;
</description>
        <pubDate>Sat, 06 Jun 2020 12:44:00 +0900</pubDate>
        <link>http://localhost:4000/lj/2020/06/06/javascript310.html</link>
        <guid isPermaLink="true">http://localhost:4000/lj/2020/06/06/javascript310.html</guid>
        
        
        <category>lj</category>
        
      </item>
    
      <item>
        <title>22.5 오픈 소스 프로젝트에 참가하기</title>
        <description>&lt;h2 id=&quot;225-오픈-소스-프로젝트에-참가하기&quot;&gt;22.5 오픈 소스 프로젝트에 참가하기&lt;/h2&gt;

&lt;p&gt;오픈 소스 프로젝트에 참가해 보는 것도 아주 좋은 방법입니다.&lt;br /&gt;
머리를 싸매고 도전할 만한 과제를 풀다 보면 개발 능력이 늘어나는 것은 물론이고, 커뮤니티에서 
당신의 코드를 검증받으면서 더 나은 프로그래머가 될 수 있습니다.&lt;br /&gt;
이력서에 쓸 것이 늘어나는 것도 좋은 점이죠.&lt;/p&gt;

&lt;p&gt;초보자라면 우선 문서화에 참가해보는 것도 좋습니다.&lt;br /&gt;
문서화에 돌릴 여력이 없어 고전하는 오픈 소스 프로젝트가 많습니다.&lt;br /&gt;
초보자에게 딱 알맞은 일감이죠.&lt;br /&gt;
당신이 무언가를 배우고 이해하면, 다른 초보자의 눈높이에서 설명하기가 쉬울 겁니다.&lt;/p&gt;

&lt;p&gt;오픈 소스 커뮤니티가 낯설고 벅차게 느껴질 수도 있겠지만, 끈기를 가지고 다른 사람의 건설적 비평에도 
귀를 기울이는 열린 마음을 보인다면 어느덧 모두들 당신을 환영할 겁니다.&lt;br /&gt;
스콧한셀만(Scot Hanselman)의 블로그 포스트 ‘Bringing Kindness Back to Open Source(&lt;a href=&quot;https://goo.gl/csCc41&quot; target=&quot;_blank&quot;&gt;https://goo.gl/csCc41&lt;/a&gt;)’를 
읽어보십시오.&lt;br /&gt;
이 포스트에서는 프로그래머와 오픈 소스 프로젝트를 연결하는 웹사이느 ‘Up for Grabs’(&lt;a href=&quot;http://up-for-grabs.net/&quot; target=&quot;_blank&quot;&gt;http://up-for-grabs.net/&lt;/a&gt;)를 소개하고 있습니다.&lt;br /&gt;
사이트에 방문해서 자바스크립트 태그로 검색해 보십시오.&lt;br /&gt;
도움을 원하는 오픈 소스 프로젝트를 여럿 만날 수 있을 겁니다.&lt;/p&gt;
</description>
        <pubDate>Sat, 06 Jun 2020 12:39:00 +0900</pubDate>
        <link>http://localhost:4000/lj/2020/06/06/javascript309.html</link>
        <guid isPermaLink="true">http://localhost:4000/lj/2020/06/06/javascript309.html</guid>
        
        
        <category>lj</category>
        
      </item>
    
      <item>
        <title>22.4 스택 오버플로</title>
        <description>&lt;h2 id=&quot;224-스택-오버플로&quot;&gt;22.4 스택 오버플로&lt;/h2&gt;

&lt;p&gt;스택 오버플로에서 필요한 답을 찾은 경험이 이미 있을 겁니다.&lt;br /&gt;
스택 오버플로는 2008년 등장하자마자 온라인 질문과 답변 사이트를 평정했습니다.&lt;br /&gt;
자바스크립트는 물론이고 이 책에서 언급한 다른 기술에 대해서도 의문이 생긴다면 스택 오버플로에서
답을 찾을 수 있습니다.&lt;br /&gt;
스택 오버플로는 커뮤니티에서 관리하며 &lt;strong&gt;명성을 통해 운영되는 사이트&lt;/strong&gt;입니다.&lt;br /&gt;
스택 오버플로가 훌륭하게 유지되는 비밀은 바로 이 &lt;strong&gt;‘명성’ 모델&lt;/strong&gt;에 있다고 해도 과언이 아닙니다.&lt;br /&gt;
사용자는 자신의 질문이나 답변이 &lt;strong&gt;‘추천’&lt;/strong&gt;을 받거나, 답변이 채택될 때마다 &lt;strong&gt;명성을 얻습니다.&lt;/strong&gt;&lt;br /&gt;
물론 명성이 전혀 없어도 질문할 수 있고, 사이트에 등록하는 것도 무료입니다.&lt;br /&gt;
무작정 질문하기보다는 요령 있게 질문을 해야 답변을 받을 확률이 높아집니다.&lt;br /&gt;
이 섹션에서는 스택 오버플로에 질문하는 요령에 대해 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;명성은 스택 오버플로의 화폐라고 할 수 있습니다.&lt;br /&gt;
대가 없이 당신을 기꺼이 도와줄 사람도 많이 있지만, 좋은 답변을 통해 명성을 얻는다는 것도 강력한 
동기 부여 수단이 됩니다.&lt;br /&gt;
스택 오버플로에는 정말 똑똑한 사람들이 많이 드나들고, 그들은 첫 번째로 가장 좋은 정확한 답을 올리기 위해 
경쟁합니다(다행히, 엉뚱한 답을 빨리 달기만 하는 사람에게는 강력한 불이익이 가해집니다).&lt;br /&gt;
다음을 잘 읽고 지키면 스택 오버플로에서 원하는 답을 얻을 가능성이 커집니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;로마에선 로마법에 따라야 합니다.&lt;/strong&gt;&lt;br /&gt;
SO 투어를 읽어보고, 좋은 질문을 올리는 요령에 관한 글도 읽어보십시오.&lt;br /&gt;
원한다면 도움말 문서를 모두 읽는 것도 괜찮습니다.&lt;br /&gt;
도움말 문서를 다 읽으면 캐릭터를 장식할 배지도 줍니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;이미 답이 있는 질문을 다시 올리지 마십시오.&lt;/strong&gt;&lt;br /&gt;
누군가 스택 오버플로에서 쉽게 답을 찾을 수 있는 질문을 올리면, 그 질문은 곧 중복으로 분류되어 닫힙니다. &lt;br /&gt;
그리고 중복된 질문을 비추천하는 사람들도 많이 있는데, 비추천을 받으면 명성에도 좋지 않은 영향이 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;코드를 대신 작성해달라고 하지 마십시오.&lt;/strong&gt;&lt;br /&gt;
무턱대고 ‘이거 어떻게 해요?’하는 식의 질문을 올리면 곧 비추천을 받고 질문이 닫히게 됩니다.&lt;br /&gt;
스택 오버플로에서는 당신이 질문하기 전에 스스로 해결하기 위해 노력하길 원합니다.&lt;br /&gt;
질문할 때는 어떤 시도를 해봤는지, 왜 그게 안됐는지 설명해야 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;한 번에 질문 하나만 하십시오.&lt;/strong&gt;&lt;br /&gt;
필자는 스택 오버플로에 답변을 많이 하는 편이지만, 서너 페이지에 달하는 코드를 들이미는 질문은 
읽지도 않고 넘어가곤 합니다(때로는 그보다 더 긴 코드를 볼 때도 있습니다).&lt;br /&gt;
5000 행짜리 파일을 질문란에 붙여넣고 답변을 바란다는 건 아무래도 상식적이지 않습니다(그런데도 이렇게 하는 사람이 정말 많습니다).&lt;br /&gt;
상식적이지도 않고, 무책임하고, 답변도 없습니다.&lt;br /&gt;
무턱대고 들이밀지 말고, 코드를 읽어보면서 ‘여기는 문제가 없어’하는 부분을 잘라내는 시도부터 해보십시오.&lt;br /&gt;
그러다 보면 질문하기도 전에 문제가 해결될 때가 많습니다.&lt;br /&gt;
이런 소거법을 연습하다 보면 디버깅 요령도 늘어나고, 사고력이 좋아지고, 스택 오버플로에서 환영받는 사용자가 됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;마크다운을 익히십시오.&lt;/strong&gt;&lt;br /&gt;
스택 오버플로에서는 마크다운(Markdown)을 통해 질문과 답을 작성합니다.&lt;br /&gt;
질문이 보기 좋게 잘 정리되어 있으면 그만큼 답을 얻을 확률도 올라갑니다.&lt;br /&gt;
마크다운은 스택 오버플로 외에도 많이 사용되고 점점 더 인기를 얻고 있으니, 시간을 내서 마크다운을 익히길 권합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;답변을 채택하고 추천하십시오.&lt;/strong&gt;&lt;br /&gt;
누군가가 당신의 질문에 만족스러운 답을 올렸다면 그 답변을 채택하고 추천하십시오.&lt;br /&gt;
답을 올린 사람은 그를 통해 명성을 얻고, 명성은 스택 오버플로가 유지되는 원동력입니다.&lt;br /&gt;
여러 사람이 괜찮은 답을 제시했다면, 그중 최고라고 생각되는 것을 골라서 채택하십시오.&lt;br /&gt;
추천은 모든 답에 다 할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;자문자답이라도 상관없습니다. 먼저 알아냈다면, 답을 다십시오.&lt;/strong&gt;&lt;br /&gt;
스택 오버플로는 커뮤니티입니다.&lt;br /&gt;
당신이 뭔가 질문할 것이 생겼다면, 다른 사람이 똑같은 질문을 할 확률도 잇습니다.&lt;br /&gt;
스스로 알아냈다면 당신의 질문에 답을 달아도 됩니다.&lt;br /&gt;
누군가가 그 답을 보고 도움을 받을 수 있을 겁니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;다른 사람을 돕기를 즐긴다면 질문에 답변을 달아 보십시오.&lt;br /&gt;
다른 사람의 질문에 대답하는 것은 유쾌한 일이고, 명성도 얻을 수 있습니다.&lt;br /&gt;
질문을 올렸는데 이틀이 지나도 유용한 답이 올라오지 않으면, 당신의 명성을 걸고 답을 현상수배 할 수 있습니다.&lt;br /&gt;
현상금으로 건 명성은 계정에서 즉시 빠져나가고 취소할 수 없습니다.&lt;br /&gt;
누군가가 당신의 질문에 만족스러운 답을 올려서 당신이 그 답변을 채택한다면 현상금으로 건 명성을 그 사람이 가져가게 됩니다.&lt;br /&gt;
당연한 일이지만, 현상수배를 하려면 우선 명성이 있어야 합니다.&lt;br /&gt;
최소한의 현상금은 명성 50입니다.&lt;br /&gt;
좋은 질문을 올려도 명성을 얻을 수 있지만, 좋은 답을 올리면 더 빨리 명성을 얻을 수 있습니다.&lt;/p&gt;

&lt;p&gt;다른 사람들의 질문에 대답하다 보면 자신도 배울 것이 많습니다.&lt;br /&gt;
필자 역시, 필자가 올린 질문에 대한 답을 볼 때보다, 오히려 다른 사람에게 대답하면서 더많은 것을 배운다고 느낄 때가 많습니다.&lt;br /&gt;
어떤 기술을 정말로 마스터하고 싶다면, 우선 기초를 배운 다음 스택 오버플로에서 다른 사람과 답변 경쟁을 해 보십시오.&lt;br /&gt;
처음에는 전문가들에게 연전연패 하겠지만, 머지않아 당신 스스로가 전문가 반열에 올라 있다고 느끼게 될 겁니다.&lt;/p&gt;

&lt;p&gt;마지막으로, 명성은 꼭 스택 오버플로 안에서만 쓰인느 것은 아닙니다.&lt;br /&gt;
명성이 높다면 이력서에 적어 보십시오.&lt;br /&gt;
최소한 필자는 이력서에 명성을 적어서 성공한 케이스에 속합니다.&lt;br /&gt;
그리고 이제 필자는 다른 개발자의 면접을 보곤 하는데, 명성이 높은 지원자에게는 항상 좋은 인상을 
받습니다(개인적으로는 3000이 넘으면 좋다고 보고, 1만 이상이라면 아주 훌륭하다고 판답합니다).&lt;br /&gt;
&lt;strong&gt;명성이 높다는 것은, 그가 자신의 분야에서 경쟁력 있는 사람임은 물론, 소통에 능하고 다른 사람을 
돕는 좋은 마음가짐을 가졌다는 증거입니다.&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 06 Jun 2020 12:23:00 +0900</pubDate>
        <link>http://localhost:4000/lj/2020/06/06/javascript308.html</link>
        <guid isPermaLink="true">http://localhost:4000/lj/2020/06/06/javascript308.html</guid>
        
        
        <category>lj</category>
        
      </item>
    
  </channel>
</rss>
