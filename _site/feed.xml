<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-05-06T19:44:46+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">LHJ</title><subtitle>coding blog</subtitle><entry><title type="html">8.2.1 push, pop, shift, unshift 배열의 처음이나 끝에서 요소 하나를 추가하거나 제거하기</title><link href="http://localhost:4000/javascript/2020/05/06/javascript132/" rel="alternate" type="text/html" title="8.2.1 push, pop, shift, unshift 배열의 처음이나 끝에서 요소 하나를 추가하거나 제거하기" /><published>2020-05-06T14:05:00+09:00</published><updated>2020-05-06T14:05:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/06/javascript132</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/06/javascript132/">&lt;p&gt;배열의 처음은 첫 번째 요소,&lt;/p&gt;</content><author><name></name></author><summary type="html">배열의 처음은 첫 번째 요소,</summary></entry><entry><title type="html">8.2 배열 요소 조작</title><link href="http://localhost:4000/javascript/2020/05/06/javascript131/" rel="alternate" type="text/html" title="8.2 배열 요소 조작" /><published>2020-05-06T09:41:57+09:00</published><updated>2020-05-06T09:41:57+09:00</updated><id>http://localhost:4000/javascript/2020/05/06/javascript131</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/06/javascript131/">&lt;p&gt;메서드를 설명하기에 앞서, 자주 사용하는 &lt;strong&gt;배열 조작 메서드에 대해 짚고 넘어갈 점&lt;/strong&gt;이 있습니다.&lt;br /&gt;
애석하게도 배열 메서드 중 일부는 배열 &lt;strong&gt;‘자체를 수정&lt;/strong&gt;하며, 다른 일부는 &lt;strong&gt;새 배열을 반환&lt;/strong&gt;합니다.&lt;br /&gt;
예를 들어 push는 배열 자체를 수정하며, concat은 새 배열을 반환합니다.&lt;br /&gt;
메서드 이름에 이런 차이점에 대한 힌트가 전혀 없으므로 프로그래머가 전부 기억해야 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;NOTE_&lt;/strong&gt;&lt;br /&gt;
루비 같은 언어는 이름만 봐도 대상 자체를 수정하는지, 아니면 새로운 것을 반환하는지 알 수 있도록 만들어져 있습니다.&lt;br /&gt;
예를 들어 루비에서 문자열 str에서 str.downcase를 호출하면 소문자 버전이 반환되지만 str 자체는 바뀌지 않습니다.&lt;br /&gt;
반면 str.downcase! 를 호출하면 소문자 버전이 반환되지만 str 자체가 바뀝니다.&lt;br /&gt;
필자는 자바스크립트 표준 라이브러리에서 어떤 메서드가 데이터 자체를 수정하고 어떤 메서드가 사본을 반환하는지에 관한 아무런 단서도 제공하지 않는다는 점은 불필요한 기억을 강요하는 단점이라고 생각합니다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">메서드를 설명하기에 앞서, 자주 사용하는 배열 조작 메서드에 대해 짚고 넘어갈 점이 있습니다. 애석하게도 배열 메서드 중 일부는 배열 ‘자체를 수정하며, 다른 일부는 새 배열을 반환합니다. 예를 들어 push는 배열 자체를 수정하며, concat은 새 배열을 반환합니다. 메서드 이름에 이런 차이점에 대한 힌트가 전혀 없으므로 프로그래머가 전부 기억해야 합니다. NOTE_ 루비 같은 언어는 이름만 봐도 대상 자체를 수정하는지, 아니면 새로운 것을 반환하는지 알 수 있도록 만들어져 있습니다. 예를 들어 루비에서 문자열 str에서 str.downcase를 호출하면 소문자 버전이 반환되지만 str 자체는 바뀌지 않습니다. 반면 str.downcase! 를 호출하면 소문자 버전이 반환되지만 str 자체가 바뀝니다. 필자는 자바스크립트 표준 라이브러리에서 어떤 메서드가 데이터 자체를 수정하고 어떤 메서드가 사본을 반환하는지에 관한 아무런 단서도 제공하지 않는다는 점은 불필요한 기억을 강요하는 단점이라고 생각합니다.</summary></entry><entry><title type="html">8.1 배열의 기초</title><link href="http://localhost:4000/javascript/2020/05/05/javascript130/" rel="alternate" type="text/html" title="8.1 배열의 기초" /><published>2020-05-05T23:17:00+09:00</published><updated>2020-05-05T23:17:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/05/javascript130</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/05/javascript130/">&lt;p&gt;본격적으로 시작하기 전에 먼저 배열의 기본적인 사항을 다시 떠올려 봅시다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;배열은 객체와 달리 본질에서 순서가 있는 데이터 집합이며 0으로 시작하는 숫자형 인덱스를 사용합니다.&lt;/li&gt;
  &lt;li&gt;자바스크립트의 배열은 &lt;strong&gt;비균질적(nonhomogeneous)&lt;/strong&gt; 입니다. &lt;strong&gt;즉, 한 배열의 요소가 모두 같은 타입일 필요는 없습니다.&lt;/strong&gt; 배열은 다른 배열이나 객체도 포함할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;배열 리터럴은 대괄호로 만들고, 배열 요소에 인덱스로 접근할 때도 대괄호를 사용합니다.&lt;/li&gt;
  &lt;li&gt;모든 배열에는 요소가 몇 개 있는지 나타내는 length 프로퍼티가 있습니다.&lt;/li&gt;
  &lt;li&gt;배열에 배열 길이보다 큰 인덱스를 사용해서 요소를 할당하면 배열은 자동으로 그 인덱스에 맞게 늘어나며, 빈자리는 undefined로 채워집니다.&lt;/li&gt;
  &lt;li&gt;Array 생성자를 써서 배열을 만들 수도 있지만 그렇게 해야 하는 경우는 별로 없습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 장을 시작하기 전에, 지금까지 짚어 본 내용이 모두 익숙한지 확인하십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 배열 리터럴&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 숫자로 구성된 배열&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;one&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;three&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 비균질적 배열&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;one&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;three&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 배열을 포함한 배열&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Fred&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;luckyNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Susan&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Anthony&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
	&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;arrays can contain functions too&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
	&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;three&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 배열 요소에 접근하기&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [&quot;one&quot;, 2, &quot;three&quot;]&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// { name:&quot;Susan&quot;, type: &quot;object&quot; }&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 배열 길이&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 5&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 배열 길이 늘리기&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [1, 2, 3, undefined, 5]&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 5&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 배열의 현재 길이보다 큰 인덱스에 접근하는 것만으로 배열의 길이가 늘어나지는 않습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;arr2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Array 생성자(거의 사용하지 않습니다)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 빈 배열&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// [1, 2, 3]&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 길이가 2인 배열. 요소는 모두 undefined 입니다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// [&quot;2&quot;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image50.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">본격적으로 시작하기 전에 먼저 배열의 기본적인 사항을 다시 떠올려 봅시다. 배열은 객체와 달리 본질에서 순서가 있는 데이터 집합이며 0으로 시작하는 숫자형 인덱스를 사용합니다. 자바스크립트의 배열은 비균질적(nonhomogeneous) 입니다. 즉, 한 배열의 요소가 모두 같은 타입일 필요는 없습니다. 배열은 다른 배열이나 객체도 포함할 수 있습니다. 배열 리터럴은 대괄호로 만들고, 배열 요소에 인덱스로 접근할 때도 대괄호를 사용합니다. 모든 배열에는 요소가 몇 개 있는지 나타내는 length 프로퍼티가 있습니다. 배열에 배열 길이보다 큰 인덱스를 사용해서 요소를 할당하면 배열은 자동으로 그 인덱스에 맞게 늘어나며, 빈자리는 undefined로 채워집니다. Array 생성자를 써서 배열을 만들 수도 있지만 그렇게 해야 하는 경우는 별로 없습니다. 이 장을 시작하기 전에, 지금까지 짚어 본 내용이 모두 익숙한지 확인하십시오. // 배열 리터럴 const arr1 = [1, 2, 3]; // 숫자로 구성된 배열 const arr2 = [&quot;one&quot;, 2, &quot;three&quot;]; // 비균질적 배열 const arr3 = [[1, 2, 3], [&quot;one&quot;, 2, &quot;three&quot;]]; // 배열을 포함한 배열 const arr4 = [ { name: &quot;Fred&quot;, type: &quot;object&quot;, luckyNumbers: [5, 7, 13] }, [ { name: &quot;Susan&quot;, type: &quot;object&quot; }, { name: &quot;Anthony&quot;, type: &quot;object&quot; }, ], 1, function () { return &quot;arrays can contain functions too&quot;; }, &quot;three&quot;, ]; // 배열 요소에 접근하기 arr1[0]; // 1 arr1[2]; // 3 arr3[1]; // [&quot;one&quot;, 2, &quot;three&quot;] arr4[1][0]; // { name:&quot;Susan&quot;, type: &quot;object&quot; } // 배열 길이 arr1.length; // 3 arr4.length; // 5 arr4[1].length; // 2 arr4[0].length; // undefined // 배열 길이 늘리기 arr1[4] = 5; arr1; // [1, 2, 3, undefined, 5] arr1.length; // 5 // 배열의 현재 길이보다 큰 인덱스에 접근하는 것만으로 배열의 길이가 늘어나지는 않습니다. arr2[10]; // undefined arr2.length; // 3 // Array 생성자(거의 사용하지 않습니다) const arr5 = new Array(); // 빈 배열 const arr6 = new Array(1, 2, 3); // [1, 2, 3] const arr7 = new Array(2); // 길이가 2인 배열. 요소는 모두 undefined 입니다. const arr8 = new Array(&quot;2&quot;); // [&quot;2&quot;]</summary></entry><entry><title type="html">8. 배열과 배열 처리</title><link href="http://localhost:4000/javascript/2020/05/05/javascript129/" rel="alternate" type="text/html" title="8. 배열과 배열 처리" /><published>2020-05-05T23:13:12+09:00</published><updated>2020-05-05T23:13:12+09:00</updated><id>http://localhost:4000/javascript/2020/05/05/javascript129</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/05/javascript129/">&lt;p&gt;자바스크립트의 배열 메서드는 필자가 가장 좋아하는 기능 중 하나입니다.&lt;br /&gt;
프로그래밍을 하다보면 데이터 집합을 조작해야 할 일이 정말 많습니다.&lt;br /&gt;
자바스크립트의 배열 메서드에 익숙해지면 이런 작업을 쉽게 처리할 수 있고 자바스크립트 개발 능력이 한 단계 올라갈 겁니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">자바스크립트의 배열 메서드는 필자가 가장 좋아하는 기능 중 하나입니다. 프로그래밍을 하다보면 데이터 집합을 조작해야 할 일이 정말 많습니다. 자바스크립트의 배열 메서드에 익숙해지면 이런 작업을 쉽게 처리할 수 있고 자바스크립트 개발 능력이 한 단계 올라갈 겁니다.</summary></entry><entry><title type="html">7.12 요약</title><link href="http://localhost:4000/javascript/2020/05/05/javascript128/" rel="alternate" type="text/html" title="7.12 요약" /><published>2020-05-05T19:17:00+09:00</published><updated>2020-05-05T19:17:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/05/javascript128</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/05/javascript128/">&lt;p&gt;어떤 프로그래밍 언어에서든 스코프는 반드시 이해해야 할 중요한 부분입니다.&lt;br /&gt;
자바스크립트는 let을 도입하면서 대부분의 최신 언어와 비슷하게 동작하게 됐습니다.&lt;br /&gt;
&lt;strong&gt;자바스크립트가 &lt;span style=&quot;color:red;&quot;&gt;클로저&lt;/span&gt;를 지원한 첫 번째 언어는 아니지만, 실무에서 널리 쓰이는 언어 중에서는 매우 빨리 지원한 편&lt;/strong&gt;입니다.&lt;br /&gt;
&lt;strong&gt;자바스크립트 개발자들은 클로저를 아주 유용하게 사용하고 있으며, 클로저는 최신 자바스크립트 개발에서 중요한 위치를 차지하고 있습니다.&lt;/strong&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">어떤 프로그래밍 언어에서든 스코프는 반드시 이해해야 할 중요한 부분입니다. 자바스크립트는 let을 도입하면서 대부분의 최신 언어와 비슷하게 동작하게 됐습니다. 자바스크립트가 클로저를 지원한 첫 번째 언어는 아니지만, 실무에서 널리 쓰이는 언어 중에서는 매우 빨리 지원한 편입니다. 자바스크립트 개발자들은 클로저를 아주 유용하게 사용하고 있으며, 클로저는 최신 자바스크립트 개발에서 중요한 위치를 차지하고 있습니다.</summary></entry><entry><title type="html">7.11 스트릭트 모드</title><link href="http://localhost:4000/javascript/2020/05/05/javascript127/" rel="alternate" type="text/html" title="7.11 스트릭트 모드" /><published>2020-05-05T19:08:00+09:00</published><updated>2020-05-05T19:08:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/05/javascript127</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/05/javascript127/">&lt;p&gt;ES5 문법에서는 &lt;strong&gt;암시적 전역 변수(implicit global)&lt;/strong&gt; 라는 것이 생길 수 있었습니다.&lt;br /&gt;
암시적 전역 변수는 여러 가지 골치 아픈 에러를 일으키곤 했습니다.&lt;br /&gt;
간단히 말해 var로 변수를 선언하는 것을 잊으면 자바스크립트는 전역 변수를 참조하려 한다고 간주하고, 그런 전역 변수가 존재하지 않으면 스스로 만들었습니다.&lt;br /&gt;
수많은 문제가 발생할 것은 불 보듯 뻔한 일입니다.&lt;/p&gt;

&lt;p&gt;이런 이유로 자바스크립트에서는 &lt;strong&gt;스트릭트 모드(strict mode)&lt;/strong&gt; 를 도입했습니다.&lt;br /&gt;
&lt;strong&gt;스트릭트 모드에서는 암시적 전역 변수를 허용하지 않습니다.&lt;/strong&gt;&lt;br /&gt;
스트릭트 모드를 사용하려면 문자열 &lt;strong&gt;“use strict”&lt;/strong&gt;(작은 따옴표를 써도 됩니다) 하나만으로 이루어진 행을 코드 맨 앞에 쓰면 됩니다.&lt;br /&gt;
전역 스코프에서 “use strict”를 사용하면 스크립트 전체가 스트릭트 모드로 실행되고, 함수 안에서 “use strict”를 사용하면 해당 함수만 스트릭트 모드로 실행됩니다.&lt;/p&gt;

&lt;p&gt;전역 스코프에 스트릭트 모드를 적용하면 스크립트 전체의 동작 방식이 바뀌므로 주의해야합니다.&lt;br /&gt;
&lt;strong&gt;최신 웹사이트는 대부분 다양한 스크립트를 불러와서 사용하므로 전역 스코프에서 스트릭트 모드를 사용하면 불러온 스크립트 전체에 스트릭트 모드가 강제됩니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;모든 스크립트가 스트릭트 모드에서 정확히 동작한다면 멋진 일이겠지만 바라기 힘든 일&lt;/strong&gt;입니다.&lt;br /&gt;
&lt;strong&gt;따라서 일반적으로는 전역 스코프에서 스트릭트 모드를 사용하지 않는 편이 좋습니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;작성하는 함수 하나하나마다 전부 “use strict”를 붙이고 싶은 사람은 없을 테니, 코드 전체를 &lt;span style=&quot;color:red;&quot;&gt;즉시 실행되는 함수&lt;/span&gt; 하나로 감싸면 됩니다.&lt;/strong&gt;&lt;br /&gt;
이에 관해서는 13장에서 다시 설명할 겁니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;use strict&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	
	&lt;span class=&quot;c1&quot;&gt;// 코드를 전부 이 안에 작성합니다.&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 이 코드는 스트릭트 모드로 동작하지만,&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 이 코드와 함께 동작하는 다른 스크립트는&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 스트릭트 모드에 영향받지 않습니다.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스트릭트 모드는 대부분의 경우에 바람직하므로 필자는 스트릭트 모드를 권합니다.&lt;br /&gt;
&lt;strong&gt;린트 프로그램을 사용한다면 스트릭트 모드가 막아주는 문제를 대부분 막아주지만, 두 번 체크해서 나쁠 것은 전혀 없습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;스트릭트 모드에 대해 더 자세히 알고 싶다면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN 문서&lt;/a&gt;를 보십시오.&lt;/p&gt;</content><author><name></name></author><summary type="html">ES5 문법에서는 암시적 전역 변수(implicit global) 라는 것이 생길 수 있었습니다. 암시적 전역 변수는 여러 가지 골치 아픈 에러를 일으키곤 했습니다. 간단히 말해 var로 변수를 선언하는 것을 잊으면 자바스크립트는 전역 변수를 참조하려 한다고 간주하고, 그런 전역 변수가 존재하지 않으면 스스로 만들었습니다. 수많은 문제가 발생할 것은 불 보듯 뻔한 일입니다. 이런 이유로 자바스크립트에서는 스트릭트 모드(strict mode) 를 도입했습니다. 스트릭트 모드에서는 암시적 전역 변수를 허용하지 않습니다. 스트릭트 모드를 사용하려면 문자열 “use strict”(작은 따옴표를 써도 됩니다) 하나만으로 이루어진 행을 코드 맨 앞에 쓰면 됩니다. 전역 스코프에서 “use strict”를 사용하면 스크립트 전체가 스트릭트 모드로 실행되고, 함수 안에서 “use strict”를 사용하면 해당 함수만 스트릭트 모드로 실행됩니다. 전역 스코프에 스트릭트 모드를 적용하면 스크립트 전체의 동작 방식이 바뀌므로 주의해야합니다. 최신 웹사이트는 대부분 다양한 스크립트를 불러와서 사용하므로 전역 스코프에서 스트릭트 모드를 사용하면 불러온 스크립트 전체에 스트릭트 모드가 강제됩니다. 모든 스크립트가 스트릭트 모드에서 정확히 동작한다면 멋진 일이겠지만 바라기 힘든 일입니다. 따라서 일반적으로는 전역 스코프에서 스트릭트 모드를 사용하지 않는 편이 좋습니다. 작성하는 함수 하나하나마다 전부 “use strict”를 붙이고 싶은 사람은 없을 테니, 코드 전체를 즉시 실행되는 함수 하나로 감싸면 됩니다. 이에 관해서는 13장에서 다시 설명할 겁니다. (function () { 'use strict'; // 코드를 전부 이 안에 작성합니다. // 이 코드는 스트릭트 모드로 동작하지만, // 이 코드와 함께 동작하는 다른 스크립트는 // 스트릭트 모드에 영향받지 않습니다. })() 스트릭트 모드는 대부분의 경우에 바람직하므로 필자는 스트릭트 모드를 권합니다. 린트 프로그램을 사용한다면 스트릭트 모드가 막아주는 문제를 대부분 막아주지만, 두 번 체크해서 나쁠 것은 전혀 없습니다. 스트릭트 모드에 대해 더 자세히 알고 싶다면 MDN 문서를 보십시오.</summary></entry><entry><title type="html">7.10 사각지대</title><link href="http://localhost:4000/javascript/2020/05/05/javascript126/" rel="alternate" type="text/html" title="7.10 사각지대" /><published>2020-05-05T18:49:00+09:00</published><updated>2020-05-05T18:49:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/05/javascript126</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/05/javascript126/">&lt;p&gt;&lt;strong&gt;사각지대(temporal dead zone)&lt;/strong&gt; 란, let으로 선언하는 변수는 선언하기 전까지 존재하지 않는다는 직관적 개념을 잘 나타내는 표현입니다.&lt;br /&gt;
스코프 안에서 변수의 사각지대는 변수가 선언되기 전의 코드입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;변수를 선언하기 전에 사용할 일은 거의 없으므로 사각지대에 빠질 일도 거의 없지만, ES6 이전의 자바스크립트에 익숙한 사람이라면 주의해야할 경우가 하나 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;typeof 연산자는 변수가 선언됐는지 알아볼 때 널리 쓰이고, 존재를 확인하는 안전한 방법으로 알려져 있습니다.&lt;br /&gt;
즉, let 키워드가 도입되고 변수의 사각지대가 생기기 전에는 다음과 같은 코드는 항상 안전하며 에러가 발생하지도 않았습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;x doesn't exist or is undefined&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// x를 사용해도 안전한 코드&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 이 코드를 let으로 변수 선언하면 안전하지 않습니다.&lt;br /&gt;
다음 코드에서는 에러가 발생합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;x doesn't exist or is undefined&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// x를 사용해도 안전한 코드&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ES6에서는 typeof 연산자로 변수가 정의됐는지 확인할 필요가 거의 없으므로 typeof가 문제를 일으킬 소지도 거의 없습니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">사각지대(temporal dead zone) 란, let으로 선언하는 변수는 선언하기 전까지 존재하지 않는다는 직관적 개념을 잘 나타내는 표현입니다. 스코프 안에서 변수의 사각지대는 변수가 선언되기 전의 코드입니다. 변수를 선언하기 전에 사용할 일은 거의 없으므로 사각지대에 빠질 일도 거의 없지만, ES6 이전의 자바스크립트에 익숙한 사람이라면 주의해야할 경우가 하나 있습니다. typeof 연산자는 변수가 선언됐는지 알아볼 때 널리 쓰이고, 존재를 확인하는 안전한 방법으로 알려져 있습니다. 즉, let 키워드가 도입되고 변수의 사각지대가 생기기 전에는 다음과 같은 코드는 항상 안전하며 에러가 발생하지도 않았습니다. if (typeof x === &quot;undefined&quot;) { console.log(&quot;x doesn't exist or is undefined&quot;); } else { // x를 사용해도 안전한 코드 } 하지만 이 코드를 let으로 변수 선언하면 안전하지 않습니다. 다음 코드에서는 에러가 발생합니다. if (typeof x === &quot;undefined&quot;) { console.log(&quot;x doesn't exist or is undefined&quot;); } else { // x를 사용해도 안전한 코드 } let x = 5; ES6에서는 typeof 연산자로 변수가 정의됐는지 확인할 필요가 거의 없으므로 typeof가 문제를 일으킬 소지도 거의 없습니다.</summary></entry><entry><title type="html">7.9 함수 호이스팅</title><link href="http://localhost:4000/javascript/2020/05/05/javascript125/" rel="alternate" type="text/html" title="7.9 함수 호이스팅" /><published>2020-05-05T18:45:00+09:00</published><updated>2020-05-05T18:45:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/05/javascript125</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/05/javascript125/">&lt;p&gt;var로 선언된 변수와 마찬가지로, 함수 선언도 스코프 맨 위로 끌어올려집니다.&lt;br /&gt;
따라서 함수를 선언하기 전에 호출할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 'f'&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;잠깐, 변수에 할당한 &lt;strong&gt;함수 표현식은 끌어올려지지 않습니다.&lt;/strong&gt;&lt;br /&gt;
이들은 변수의 스코프 규칙을 그대로 따릅니다.&lt;br /&gt;
다음 예제를 보십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ReferrenceError: f는 정의되지 않았습니다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">var로 선언된 변수와 마찬가지로, 함수 선언도 스코프 맨 위로 끌어올려집니다. 따라서 함수를 선언하기 전에 호출할 수 있습니다. f(); // 'f' function f() { console.log('f'); } 잠깐, 변수에 할당한 함수 표현식은 끌어올려지지 않습니다. 이들은 변수의 스코프 규칙을 그대로 따릅니다. 다음 예제를 보십시오. f(); // ReferrenceError: f는 정의되지 않았습니다. let f = function() { console.log('f'); }</summary></entry><entry><title type="html">7.8 함수 스코프와 호이스팅</title><link href="http://localhost:4000/javascript/2020/05/05/javascript124/" rel="alternate" type="text/html" title="7.8 함수 스코프와 호이스팅" /><published>2020-05-05T18:17:00+09:00</published><updated>2020-05-05T18:17:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/05/javascript124</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/05/javascript124/">&lt;p&gt;&lt;strong&gt;ES6에서 let을 도입하기 전에는 &lt;span style=&quot;color:red;&quot;&gt;var&lt;/span&gt;를 써서 변수를 선언했고, 이렇게 선언된 변수들은 &lt;span style=&quot;color:red;&quot;&gt;함수 스코프&lt;/span&gt;로 불리는 스코프를 가졌습니다(var로 선언한 전역 변수는 명시적인 함수 안에 있지는 않지만 함수 스코프와 똑같이 동작합니다).&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;let으로 변수를 선언하면, 그 변수는 선언하기 전에는 존재하지 않습니다.&lt;br /&gt;
&lt;strong&gt;var로 선언한 변수는 현재 스코프 안이라면 어디서는 사용할 수 있으며, &lt;span style=&quot;color:red;&quot;&gt;심지어 선언하기도 전에 사용할 수 있습니다.&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;
예제를 보기 전에, 아직 선언되지 않은 변수와 값이 undefined인 변수는 다르다는 점을 상기해 봅시다.&lt;br /&gt;
아직 선언되지 않은 변수는 에러를 일으키지만, 존재하되 값이 undefined인 변수는 에러를 일으키지 않습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;var1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;var2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;var1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;var2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;undefinedVar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ReferenceError: undefinedVar는 정의되지 않았습니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;let을 쓰면, 변수를 선언하기 전 사용하려 할 때 에러가 일어납니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ReferenceError: x는 정의되지 않았습니다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 에러가 일어나서 실행이 멈췄으므로 여기에는 결코 도달할 수 없습니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;반면 var로 변수를 선언하면 선언하기 전에도 사용할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;대관절 어떻게 된 걸까요?&lt;br /&gt;
변수를 선언하지도 않았는데 그 변수에 접근할 수 있다는 건 이해할 수 없는 일입니다.&lt;br /&gt;
var로 선언한 변수는 끌어올린다는 뜻의 &lt;strong&gt;호이스팅(hoisting)&lt;/strong&gt; 이라는 매커니즘을 따릅니다.&lt;br /&gt;
&lt;strong&gt;자바스크립트는 함수나 전역 스코프 전체를 살펴보고 var로 선언한 변수를 맨 위로 끌어올립니다.&lt;/strong&gt;&lt;br /&gt;
여기서 중요한 것은 &lt;strong&gt;선언&lt;/strong&gt;만 끌어올려진다는 것이며, &lt;strong&gt;할당&lt;/strong&gt;은 끌어올려지지 않는다는 겁니다.&lt;br /&gt;
자바스크립트는 이전 예제를 다음과 같이 해석합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 선언(할당은 아닌)이 끌어올려집니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// undefined&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;좀 더 복잡한 예제를 살펴봅시다.&lt;br /&gt;
이번에는 원래 코드와 자바스크립트가 해석한 코드를 1:1로 비교하겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 원래 코드&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 자바스크립트가 해석한 코드&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원래 코드가 모범적인 자바스크립트 코드라는 것은 아닙니다.&lt;br /&gt;
변수를 선언하기도 전에 사용하면 불필요하게 혼란스럽고, 에러에도 취약합니다.&lt;br /&gt;
이렇게 해야 할 현실적인 이유가 있는 것도 아닙니다.&lt;br /&gt;
이 코드를 제시한 이유는 호이스팅이 어떻게 동작하는지 잘 보여주기 때문입니다.&lt;/p&gt;

&lt;p&gt;var를 이용해 변수를 선언하면 자바스크립트는 같은 변수를 여러 번 정의하더라도 무시합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 원래 코드&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 자바스크립트가 해석한 코드&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 예제를 보면 같은 함수나 전역 스코프 안에서는 var로 새 변수를 만들 수 없으며, let으로 가능했던 변수 숨김도 불가능함을 알 수 있습니다.&lt;br /&gt;
이 예제는 블록 안에서 두 번째 var문을 썼지만 변수 x는 &lt;strong&gt;하나뿐&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;다시 말하자면, 이런 스타일을 권하는 건 절대 아닙니다.&lt;/strong&gt;&lt;br /&gt;
이런 스타일은 혼란을 초래할 뿐입니다.&lt;br /&gt;
대부분의 독자, 특히 다른 언어에 익숙한 독자들은 이 예제를 힐끗 보고 필자가 if 문의 블록 스코프 안에 새 변수 x를 만들려 한다고 생각할 수 있지만, 그런 일은 일어나지 않습니다.&lt;/p&gt;

&lt;p&gt;var를 쓰면 혼란스럽고 쓸모없는 코드가 생길 수 있는데 &lt;strong&gt;왜 이런 키워드를 만들었는지 의문&lt;/strong&gt;이 든다면 &lt;strong&gt;let 키워드가 만들어진 이유를 이해한 겁니다.&lt;/strong&gt;&lt;br /&gt;
물론 var를 써도 명확하고 이해하기 쉬운 코드를 작성할 수 있지만, 혼란스럽고 불명확한 코드를 작성할 위험은 여전합니다.&lt;br /&gt;
var를 뜯어고치면 기존 코드가 모두 망가지므로 대신 ES6에서 let을 새로 만든 겁니다.&lt;/p&gt;

&lt;p&gt;필자는 let 대신 var를 써서 더 좋은 코드나 더 명확한 코드를 쓰는 방법을 도저히 떠올릴 수 없습니다.&lt;br /&gt;
달리 말해 var에는 let보다 나은 점이 전혀 없습니다.&lt;br /&gt;
필자를 포함해, 자바스크립트 커뮤니티에서는 대부분 let이 언젠가 var를 완전히 대체할 것으로 예상합니다.&lt;br /&gt;
언젠가는 var가 최종적으로 폐기될 날이 올 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;그럼 왜 var와 호이스팅을 이해해야 할까요?&lt;/strong&gt;&lt;br /&gt;
이유는 두 가지 입니다.&lt;br /&gt;
ES6를 어디에서는 쓸 수 있으려면 아직 시간이 더 필요하므로 ES5로 트랜스컴파일을 해야 합니다.&lt;br /&gt;
기존 코드는 전부 ES5로 작성됐다는 건 말할 필요도 없겠죠.&lt;br /&gt;
따라서 아직은 var가 어떻게 동작하는지 이해하고 있어야 합니다.&lt;br /&gt;
두 번째 이유는, 함수 선언 역시 끌어올려진다는 겁니다.&lt;br /&gt;
이제 함수 호이스팅에 대해 알아봅시다.&lt;/p&gt;</content><author><name></name></author><summary type="html">ES6에서 let을 도입하기 전에는 var를 써서 변수를 선언했고, 이렇게 선언된 변수들은 함수 스코프로 불리는 스코프를 가졌습니다(var로 선언한 전역 변수는 명시적인 함수 안에 있지는 않지만 함수 스코프와 똑같이 동작합니다). let으로 변수를 선언하면, 그 변수는 선언하기 전에는 존재하지 않습니다. var로 선언한 변수는 현재 스코프 안이라면 어디서는 사용할 수 있으며, 심지어 선언하기도 전에 사용할 수 있습니다. 예제를 보기 전에, 아직 선언되지 않은 변수와 값이 undefined인 변수는 다르다는 점을 상기해 봅시다. 아직 선언되지 않은 변수는 에러를 일으키지만, 존재하되 값이 undefined인 변수는 에러를 일으키지 않습니다. let var1; let var2 = undefined; var1; // undefined var2; // undefined undefinedVar; // ReferenceError: undefinedVar는 정의되지 않았습니다. let을 쓰면, 변수를 선언하기 전 사용하려 할 때 에러가 일어납니다. x; // ReferenceError: x는 정의되지 않았습니다. let x = 3; // 에러가 일어나서 실행이 멈췄으므로 여기에는 결코 도달할 수 없습니다. 반면 var로 변수를 선언하면 선언하기 전에도 사용할 수 있습니다. x; // undefined var x = 3; x; // 3 대관절 어떻게 된 걸까요? 변수를 선언하지도 않았는데 그 변수에 접근할 수 있다는 건 이해할 수 없는 일입니다. var로 선언한 변수는 끌어올린다는 뜻의 호이스팅(hoisting) 이라는 매커니즘을 따릅니다. 자바스크립트는 함수나 전역 스코프 전체를 살펴보고 var로 선언한 변수를 맨 위로 끌어올립니다. 여기서 중요한 것은 선언만 끌어올려진다는 것이며, 할당은 끌어올려지지 않는다는 겁니다. 자바스크립트는 이전 예제를 다음과 같이 해석합니다. var x; // 선언(할당은 아닌)이 끌어올려집니다. x; // undefined x = 3; x; // 3 좀 더 복잡한 예제를 살펴봅시다. 이번에는 원래 코드와 자바스크립트가 해석한 코드를 1:1로 비교하겠습니다. // 원래 코드 if (x !== 3) { console.log(y); var y = 5; if (y === 5) { var x = 3; } console.log(y); } if (x === 3) { console.log(y); } // 자바스크립트가 해석한 코드 var x; var y; if (x !== 3) { console.log(y); y = 5; if (y === 5) { x = 3; } console.log(y); } if (x === 3) { console.log(y); } 원래 코드가 모범적인 자바스크립트 코드라는 것은 아닙니다. 변수를 선언하기도 전에 사용하면 불필요하게 혼란스럽고, 에러에도 취약합니다. 이렇게 해야 할 현실적인 이유가 있는 것도 아닙니다. 이 코드를 제시한 이유는 호이스팅이 어떻게 동작하는지 잘 보여주기 때문입니다. var를 이용해 변수를 선언하면 자바스크립트는 같은 변수를 여러 번 정의하더라도 무시합니다. // 원래 코드 var x = 3; if (x === 3) { var x = 2; console.log(x); } console.log(x); // 자바스크립트가 해석한 코드 var x; x = 3; if (x === 3) { x = 2; console.log(x); } console.log(x); 이 예제를 보면 같은 함수나 전역 스코프 안에서는 var로 새 변수를 만들 수 없으며, let으로 가능했던 변수 숨김도 불가능함을 알 수 있습니다. 이 예제는 블록 안에서 두 번째 var문을 썼지만 변수 x는 하나뿐입니다. 다시 말하자면, 이런 스타일을 권하는 건 절대 아닙니다. 이런 스타일은 혼란을 초래할 뿐입니다. 대부분의 독자, 특히 다른 언어에 익숙한 독자들은 이 예제를 힐끗 보고 필자가 if 문의 블록 스코프 안에 새 변수 x를 만들려 한다고 생각할 수 있지만, 그런 일은 일어나지 않습니다. var를 쓰면 혼란스럽고 쓸모없는 코드가 생길 수 있는데 왜 이런 키워드를 만들었는지 의문이 든다면 let 키워드가 만들어진 이유를 이해한 겁니다. 물론 var를 써도 명확하고 이해하기 쉬운 코드를 작성할 수 있지만, 혼란스럽고 불명확한 코드를 작성할 위험은 여전합니다. var를 뜯어고치면 기존 코드가 모두 망가지므로 대신 ES6에서 let을 새로 만든 겁니다. 필자는 let 대신 var를 써서 더 좋은 코드나 더 명확한 코드를 쓰는 방법을 도저히 떠올릴 수 없습니다. 달리 말해 var에는 let보다 나은 점이 전혀 없습니다. 필자를 포함해, 자바스크립트 커뮤니티에서는 대부분 let이 언젠가 var를 완전히 대체할 것으로 예상합니다. 언젠가는 var가 최종적으로 폐기될 날이 올 수도 있습니다. 그럼 왜 var와 호이스팅을 이해해야 할까요? 이유는 두 가지 입니다. ES6를 어디에서는 쓸 수 있으려면 아직 시간이 더 필요하므로 ES5로 트랜스컴파일을 해야 합니다. 기존 코드는 전부 ES5로 작성됐다는 건 말할 필요도 없겠죠. 따라서 아직은 var가 어떻게 동작하는지 이해하고 있어야 합니다. 두 번째 이유는, 함수 선언 역시 끌어올려진다는 겁니다. 이제 함수 호이스팅에 대해 알아봅시다.</summary></entry><entry><title type="html">7.7 즉시 호출하는 함수 표현식</title><link href="http://localhost:4000/javascript/2020/05/05/javascript123/" rel="alternate" type="text/html" title="7.7 즉시 호출하는 함수 표현식" /><published>2020-05-05T17:31:00+09:00</published><updated>2020-05-05T17:31:00+09:00</updated><id>http://localhost:4000/javascript/2020/05/05/javascript123</id><content type="html" xml:base="http://localhost:4000/javascript/2020/05/05/javascript123/">&lt;p&gt;6장에서 함수 표현식에 대해 설명했습니다.&lt;br /&gt;
함수 표현식을 사용하면 &lt;strong&gt;즉시 호출하는 함수 표현식(IIFE)&lt;/strong&gt; 이란 것을 만들 수 있습니다.&lt;br /&gt;
IIFE는 함수를 선언하고 즉시 실행합니다.&lt;br /&gt;
스코프와 클로저에 대해 충분히 이해했으니 왜 IIFE를 사용해야 하는지 이해할 수 있을 겁니다.&lt;br /&gt;
IIFE는 다음과 같은 형태를 취합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// IIFE 바디&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;함수 표현식으로 익명 함수를 만들고 그 함수를 즉시 호출합니다.&lt;br /&gt;
&lt;strong&gt;IIFE의 장점&lt;/strong&gt;은 내부에 있는 것들이 모두 자신만의 스코프를 가지지만, IIFE 자체는 함수이므로 그 스코프 밖으로 무언가를 내보낼 수 있다는 겁니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;secret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;I'm secret!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`The secret is &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;secret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; characters long.`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;변수 secret은 IIFE의 스코프 안에서 안전하게 보호되며 외부에서 접근할 수 없습니다.&lt;br /&gt;
IIFE는 함수이므로 무엇이든 반환할 수 있습니다.&lt;br /&gt;
IIFE에서 배열이나 객체, 함수를 반환하는 경우도 무척 많습니다.&lt;br /&gt;
자신이 몇 번 호출됐는지 보고하는 함수를 생각해 봅시다.&lt;br /&gt;
이 함수가 몇 번 호출됐는지 저장한 값을 외부에서는 절대 손댈 수 없습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;`I have been called &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; time(s).`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;I have been called 1 time(s).&quot;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;I have been called 2 time(s).&quot;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;변수 count는 IIFE 안에 안전하게 보관되어 있으므로 손댈 방법이 없습니다.&lt;br /&gt;
f는 자신이 몇 번 호출됐는지 항상 정확히 알고 있습니다.&lt;/p&gt;

&lt;p&gt;ES6에서 블록 스코프 변수를 도입하면서 IIFE가 필요한 경우가 줄어들긴 했지만 여전히 매우 널리 쓰입니다.&lt;br /&gt;
클로저를 만들고 클로저에서 무언가 반환받을 때에는 유용하게 쓸 수 있습니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">6장에서 함수 표현식에 대해 설명했습니다. 함수 표현식을 사용하면 즉시 호출하는 함수 표현식(IIFE) 이란 것을 만들 수 있습니다. IIFE는 함수를 선언하고 즉시 실행합니다. 스코프와 클로저에 대해 충분히 이해했으니 왜 IIFE를 사용해야 하는지 이해할 수 있을 겁니다. IIFE는 다음과 같은 형태를 취합니다. (function () { // IIFE 바디 })(); 함수 표현식으로 익명 함수를 만들고 그 함수를 즉시 호출합니다. IIFE의 장점은 내부에 있는 것들이 모두 자신만의 스코프를 가지지만, IIFE 자체는 함수이므로 그 스코프 밖으로 무언가를 내보낼 수 있다는 겁니다. const message = (function() { const secret = &quot;I'm secret!&quot;; return `The secret is ${secret.length} characters long.`; })(); console.log(message); 변수 secret은 IIFE의 스코프 안에서 안전하게 보호되며 외부에서 접근할 수 없습니다. IIFE는 함수이므로 무엇이든 반환할 수 있습니다. IIFE에서 배열이나 객체, 함수를 반환하는 경우도 무척 많습니다. 자신이 몇 번 호출됐는지 보고하는 함수를 생각해 봅시다. 이 함수가 몇 번 호출됐는지 저장한 값을 외부에서는 절대 손댈 수 없습니다. const f = (function () { let count = 0; return function () { return `I have been called ${++count} time(s).`; } })(); f(); // &quot;I have been called 1 time(s).&quot; f(); // &quot;I have been called 2 time(s).&quot; // ... 변수 count는 IIFE 안에 안전하게 보관되어 있으므로 손댈 방법이 없습니다. f는 자신이 몇 번 호출됐는지 항상 정확히 알고 있습니다. ES6에서 블록 스코프 변수를 도입하면서 IIFE가 필요한 경우가 줄어들긴 했지만 여전히 매우 널리 쓰입니다. 클로저를 만들고 클로저에서 무언가 반환받을 때에는 유용하게 쓸 수 있습니다.</summary></entry></feed>