<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LEE HYUNG JU</title>
    <description>Jekyll Blog</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 09 Jun 2020 18:06:39 +0900</pubDate>
    <lastBuildDate>Tue, 09 Jun 2020 18:06:39 +0900</lastBuildDate>
    <generator>Jekyll v4.0.1</generator>
    
      <item>
        <title>git stash</title>
        <description>&lt;h2 id=&quot;git-stash&quot;&gt;git stash&lt;/h2&gt;

&lt;p&gt;임시보관(tracked 파일만)&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git stash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;임시 보관(untracked 까지 stash)&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git stash &lt;span class=&quot;nt&quot;&gt;--include-untracked&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다시 꺼내오기&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;목록확인
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git stash list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;꺼내오기
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git stash apply &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;이름&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;stash 목록 지우기&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git stash drop &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;이름&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 09 Jun 2020 18:04:00 +0900</pubDate>
        <link>http://localhost:4000/git/2020/06/09/git3.html</link>
        <guid isPermaLink="true">http://localhost:4000/git/2020/06/09/git3.html</guid>
        
        
        <category>git</category>
        
      </item>
    
      <item>
        <title>2. 알아두어야 할 자바스크립트</title>
        <description>&lt;h2 id=&quot;2-알아두어야-할-자바스크립트&quot;&gt;2. 알아두어야 할 자바스크립트&lt;/h2&gt;

&lt;p&gt;자바스크립트는 매년 새로운 버전을 출시하고 있으며, 노드는 주기적으로 버전을 올리며 변경된 자바스크립트 문법을 반영하고 있습니다.&lt;br /&gt;
이 책의 예제들은 ES2015+ 문법을 사용하므로 2.1절에서는 새로운 문법에 대해 간단히 알아보고, 2.2절에서는 서버와 통신하기 위해 프론트앤드에서 사용하는 자바스크립트 코드를 알아봅니다.&lt;/p&gt;
</description>
        <pubDate>Tue, 09 Jun 2020 14:27:00 +0900</pubDate>
        <link>http://localhost:4000/nodebook/2020/06/09/node11.html</link>
        <guid isPermaLink="true">http://localhost:4000/nodebook/2020/06/09/node11.html</guid>
        
        
        <category>nodebook</category>
        
      </item>
    
      <item>
        <title>1.5 함께 보면 좋은 자료</title>
        <description>&lt;p&gt;1.5 함께 보면 좋은 자료&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;노드 공식 사이트 : &lt;a href=&quot;https://nodejs.org/ko&quot; target=&quot;_blank&quot;&gt;https://nodejs.org/ko&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;노드 공식 사이트의 가이드 : &lt;a href=&quot;https://nodejs.org/en/docs/guides&quot; target=&quot;_blank&quot;&gt;https://nodejs.org/en/docs/guides&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;이벤트 루프에 대한 시각적 설명 : &lt;a href=&quot;http://latentflip.com/loupe&quot; target=&quot;_blank&quot;&gt;http://latentflip.com/loupe&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;이벤트 루프에 대한 설명 : &lt;a href=&quot;https://nodejs.org/ko/docs/guides/event-loop-timers-and-nexttick/&quot; target=&quot;_blank&quot;&gt;https://nodejs.org/ko/docs/guides/event-loop-timers-and-nexttick/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 09 Jun 2020 14:19:00 +0900</pubDate>
        <link>http://localhost:4000/nodebook/2020/06/09/node10.html</link>
        <guid isPermaLink="true">http://localhost:4000/nodebook/2020/06/09/node10.html</guid>
        
        
        <category>nodebook</category>
        
      </item>
    
      <item>
        <title>1.4.2 npm의 버전 업데이트하기</title>
        <description>&lt;p&gt;1.4.2 npm의 버전 업데이트하기&lt;/p&gt;

&lt;p&gt;npm의 버전이 빠른 속도로 업데이트되므로 최신 버전은 이 책에 나오는 버전과 많이 다를 수 있습니다.&lt;br /&gt;
2018년 5월 기준으로 최신 npm 버전은 6.0.0입니다.&lt;br /&gt;
npm 5 버전 이상이기만 하면 이 책을 실습하는 데 큰 문제는 없습니다.&lt;br /&gt;
하지만 최신 버전을 사용하고 싶거나, 현재 버전이 너무 낮다면 명령 프로프트 또는 터미널에 다음 명령어를 입력하여 업데이트하세요.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; npm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;맥과 리눅스의 경우에는 명령어 앞에 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt;를 붙인 후, 계정 비밀번호를 입력해야 할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;업데이트 완료 후 다시 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm -v&lt;/code&gt;를 입력하면 최신 버전의 npm이 설치되었음을 확인할 수 있습니다.&lt;br /&gt;
방금 실행한 명령어에 대해서는 5장에서 자세히 배웁니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;노드의 버전 업데이트&lt;/strong&gt;&lt;br /&gt;
노드의 버전을 최신 버전으로 업데이트하는 가장 쉬운 방법은 현재 설치된 노드를 제거했다가 최신 버전을 설치하는 것입니다.&lt;br /&gt;
하지만 버전이 바뀔 때마다 매번 지웠다 설치하는 것은 번거롭습니다.&lt;br /&gt;
이를 쉽게 해주는 도구가 있지만 npm 명령어와 패키지 개념을 알아야 하므로 지금 바로 설명하지는 않겠습니다.&lt;br /&gt;
업데이트 도구 사용 방법은 15.1.9절에 나와 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 09 Jun 2020 14:02:00 +0900</pubDate>
        <link>http://localhost:4000/nodebook/2020/06/09/node09.html</link>
        <guid isPermaLink="true">http://localhost:4000/nodebook/2020/06/09/node09.html</guid>
        
        
        <category>nodebook</category>
        
      </item>
    
      <item>
        <title>1.4 노드</title>
        <description>&lt;h2 id=&quot;14-노드&quot;&gt;1.4 노드&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt; LTS와 Current 버전의 차이&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;LTS&lt;/strong&gt;&lt;br /&gt;
 기업을 위해 3년간 지원하는 버전입니다.&lt;br /&gt;
 짝수 버전만 LTS 버전이 될 수 있습니다.&lt;br /&gt;
 서버를 안정적으로 운영해야 할 경우 선택하세요.&lt;br /&gt;
 하지만 최신 기능을 사용하지 못할 수도 있습니다.&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Current&lt;/strong&gt;&lt;br /&gt;
 최신 기능을 담고 있는 버전입니다.&lt;br /&gt;
 다소 실험적인 기능이 들어 있어 예기치 못한 에러가 발생할 수 있습니다.&lt;br /&gt;
 서버에 신기능이 필요하거나 학습용으로 사용할 때 적합합니다.&lt;br /&gt;
 단, 짝수 버전은 LTS가 되기 때문에 Current일 때부터 사용하는 것을 고려해볼 만합니다.&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;홀수버전&lt;/strong&gt;&lt;br /&gt;
 노드는 6개월마다 버전을 1씩 올립니다.&lt;br /&gt;
 따라서 10버전 이전에 9버전도 있었습니다.&lt;br /&gt;
 하지만 홀수 버전은 LTS를 지원하지 않으므로 10버전이 나오면서 9버전은 사라졌습니다.&lt;br /&gt;
 나중에 11버전이 나오면 10 버전이 LTS로 가고 11버전이 Current가 됩니다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 09 Jun 2020 12:30:00 +0900</pubDate>
        <link>http://localhost:4000/nodebook/2020/06/09/node08.html</link>
        <guid isPermaLink="true">http://localhost:4000/nodebook/2020/06/09/node08.html</guid>
        
        
        <category>nodebook</category>
        
      </item>
    
      <item>
        <title>1.3 서버 외의 노드</title>
        <description>&lt;h2 id=&quot;13-서버-외의-노드&quot;&gt;1.3 서버 외의 노드&lt;/h2&gt;

&lt;p&gt;처음에는 대부분 노드를 서버로 사용했지만, 노드는 자바스크립트 런타임이기 때문에 용도가 서버에만 한정된 것은 아닙니다.&lt;br /&gt;
사용 범위가 점점 늘어나 웹, 모바일, 데스크톱 애플리케이션 개발에도 사용되기 시작했습니다.&lt;/p&gt;

&lt;p&gt;노드 기반으로 돌아가는 대표적인 웹 프레임워크로는 Angular와 React, Vue, Meteor 등이 있습니다.&lt;br /&gt;
Angular는 구글 진영에서 프론트앤드 앱을 만들 때 주로 사용하고, React는 페이스북 진영에서 주로 사용합니다.&lt;br /&gt;
모바일 개발 도구로는 React Native와 Ionic Framework를 많이 사용합니다.&lt;br /&gt;
페이스북, 인스타그램, 에어비앤비, 월마트, 테슬라 등이 React Native를 사용하여 모바일 앱을 운영 중입니다.&lt;br /&gt;
데스크톱 개발 도구로는 Electron이 대표적입니다.&lt;br /&gt;
Electron으로 만들어진 프로그램으로는 Atom, Slack, Discord 등이 있습니다.&lt;br /&gt;
이 책에서 사용할 에디터인 비쥬얼 스튜디오 코드도 Electron으로 만들어졌습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image12.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 09 Jun 2020 12:25:00 +0900</pubDate>
        <link>http://localhost:4000/nodebook/2020/06/09/node07.html</link>
        <guid isPermaLink="true">http://localhost:4000/nodebook/2020/06/09/node07.html</guid>
        
        
        <category>nodebook</category>
        
      </item>
    
      <item>
        <title>1. ES6+ 기초편 1회차</title>
        <description>&lt;h2 id=&quot;1-es6-기초편-1회차&quot;&gt;1. ES6+ 기초편 1회차&lt;/h2&gt;

&lt;h3 id=&quot;why-did-you-do-that-도대체-코드-왜-그렇게-짰어&quot;&gt;Why did you do that? 도대체 코드 왜 그렇게 짰어?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;철학
    &lt;ul&gt;
      &lt;li&gt;합리주의&lt;/li&gt;
      &lt;li&gt;상대주의&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;상대주의, 무엇을 기준으로 판단할 것인가.&lt;br /&gt;
모두가 동의할 수 있는 기준을 만들자.&lt;br /&gt;
그 모두가 동의할 수 있는 기준을 만들 때 합리주의 철학이 사용된다.&lt;/p&gt;

&lt;p&gt;합리주의와 상대주의는 서로 상보하는 관계. 서로 대립하거나 반대되는 개념이 아니다.&lt;br /&gt;
상대주의와 대립되는 경우는 오히려 절대주의일 것.&lt;/p&gt;

&lt;p&gt;프로그래밍 세계엔 이런 개념들이 깔려있다.&lt;/p&gt;

&lt;h3 id=&quot;프로그래밍을-짤-때-왜-이렇게짰어-를-설명할-때-세-가지를-생각하자&quot;&gt;프로그래밍을 짤 때 왜 이렇게짰어? 를 설명할 때 세 가지를 생각하자.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;가치&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;의사소통 - 쉽게 알아볼 수 있다.&lt;/li&gt;
      &lt;li&gt;단순함 - 복잡해서 단순화했다.&lt;/li&gt;
      &lt;li&gt;유연함 - 여러 케이스를 고려, 플러그인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;원칙&lt;/strong&gt;&lt;br /&gt;
원칙을 지켜야 예외 현상, 오류가 생겼을 때 빠르게 알 수 있다.  &lt;br /&gt;
원칙을 정할 땐 당연히 중요한 것들만 원칙으로 정해야 한다. 항상 지켜야되기 때문에 힘들기 때문. 수고로움이 더 많이 들어간다.  &lt;br /&gt;
따라서 가치보다 원칙을 정할 때 더 신중해야 한다.&lt;br /&gt;
원칙은 최소화해라.
    &lt;ul&gt;
      &lt;li&gt;지역화 - 전역변수 쓰지마.&lt;/li&gt;
      &lt;li&gt;중복제거 - 똑같은 모듈, 함수 다 하나로 통일해. 유지보수 힘들어.&lt;/li&gt;
      &lt;li&gt;대칭성 - get/set, add/remove…쌍을 맞춰라! 되도록!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;패턴&lt;/strong&gt;&lt;br /&gt;
선배들의 경험.&lt;br /&gt;
역사상 디버깅 비용이 줄은 경우가 없다. 예전이나 지금이나 디버깅 비용은 대략 60%.&lt;br /&gt;
선배들의 조언이 유용하다는 증거.&lt;br /&gt;
경험도 반복되면 진리에 가까워진다.&lt;br /&gt;
과학기술은 연역적으로 도출되는 것이 많다. 대부분의 학문들도..&lt;br /&gt;
경험에 의해 나왔다고 해서 이론베이스 지식보다 약할거라는 생각은 하지마라.&lt;br /&gt;
오히려 더 강할 수도 있다.&lt;br /&gt;
왜냐하면 검증을 많이 했기 때문.
    &lt;ul&gt;
      &lt;li&gt;개발론 - 함수 지향 개발, 객체 지향 개발 등&lt;/li&gt;
      &lt;li&gt;설계론 - 어떻게 설계를 할 것인가&lt;/li&gt;
      &lt;li&gt;각종 적용 패턴 - 어디서 함수를 쓰고 어디서 클래스를 쓸 것인가. 함수를 두 개로 나눌것인가 말것인가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;켄트 벡의 구현 패턴&lt;/strong&gt;과 같은 책을 구입해서 읽으면 좋다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;마지막-단계&quot;&gt;마지막 단계&lt;/h3&gt;

&lt;p&gt;그래서 내가 왜 이렇게 코드를 짰는데? 라는 이유의 동기 : &lt;strong&gt;돈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;너 왜 그래프 만들랬더니 사왔어?&lt;br /&gt;
제가 직접하면 비용이 세 배로 들어요.&lt;br /&gt;
너 왜 앵귤러 썼어?&lt;br /&gt;
제가 이걸 바닥부터 만들면 지옥입니다. 앵귤러 쓰는게 훨씬 나아요.&lt;/p&gt;

&lt;p&gt;https://www.youtube.com/watch?v=0j_eGoF8Q98&amp;amp;list=PLBNdLLaRx_rIF3jAbhliedtfixePs5g2q&lt;br /&gt;
24:08&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Jun 2020 23:04:00 +0900</pubDate>
        <link>http://localhost:4000/codespitz/2020/06/08/codespitz01.html</link>
        <guid isPermaLink="true">http://localhost:4000/codespitz/2020/06/08/codespitz01.html</guid>
        
        
        <category>codespitz</category>
        
      </item>
    
      <item>
        <title>1.2 서버로서의 노드</title>
        <description>&lt;h2 id=&quot;12-서버로서의-노드&quot;&gt;1.2 서버로서의 노드&lt;/h2&gt;

&lt;p&gt;이 절에서는 노드를 서버로 사용할 때의 특징과 장단점에 대해 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;노드가 싱글 스레드, 논블로킹 모델을 사용하므로 노드 서버 또한 동일한 모델일 수밖에 없습니다.&lt;br /&gt;
따라서 노드 서버의 장단점은 싱글 스레드, 논블로킹 모델의 장단점과 크게 다르지 않습니다.&lt;br /&gt;
&lt;strong&gt;싱글 스레드여서 멀티 스레드 방식보다는 컴퓨터 자원을 적게 사용하는 장점이 있지만, CPU 코어를 하나밖에 사용하지 못하는 단점도 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;노드 서버는 I/O가 많은 작업에 적합합니다.&lt;br /&gt;
노드는 &lt;strong&gt;libuv 라이브러리&lt;/strong&gt;를 사용하여 I/O 작업을 논블로킹 방식으로 처리해줍니다.&lt;br /&gt;
따라서 스레드 하나가 많은 수의 I/O를 혼자서도 감당할 수 있습니다.&lt;br /&gt;
하지만 CPU 부하가 큰 작업에는 적합하지 않습니다.&lt;br /&gt;
여러분이 작성하는 코드는 모두 스레드 하나에서 처리됩니다.&lt;br /&gt;
여러분의 코드가 CPU 연산을 많이 요구하면 블로킹이 발생해 스레드 하나가 감당하기 어렵습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;싱글 스레드 방식의 프로그래밍은 멀티 스레드 방식보다 상대적으로 쉽습니다.&lt;/strong&gt;&lt;br /&gt;
서버 프로그래밍에 익숙하지 않은 사람도 쉽게 입문할 수 있습니다.&lt;br /&gt;
하지만 싱글 스렏이다 보니 하나뿐인 스레드가 에러로 인해 멈추지 않도록 잘 관리해야 합니다.&lt;br /&gt;
에러를 제대로 처리하지 못하면 서버 전체가 멈추기 때문입니다.&lt;/p&gt;

&lt;p&gt;또한, 웹 서버가 내장되어 있어 입문자가 쉽게 접근할 수 있습니다.&lt;br /&gt;
노드 외의 서버를 개발하다 보면 Apache, nginx, IIS 처럼 별도의 웹 서버를 설치해야 하는 경우가 많습니다.&lt;br /&gt;
심지어 Tomcat 같은 웹 애플리케이션 서버(WAS)를 추가로 설치하는 경우도 있습니다.&lt;br /&gt;
이 경우 프로그래밍 외에도 웹 서버와 WAS 사용법을 익혀야 합니다.&lt;br /&gt;
하지만 노드는 내장된 웹 서버를 사용하면 되므로 편리합니다.&lt;br /&gt;
하지만 나중에 서버 규모가 커지면 결국 nginx 등의 웹 서버를 노드 서버와 연결해야 합니다.&lt;/p&gt;

&lt;p&gt;노드 사용자들이 말하는 가장 큰 장점은 언어로 자바스크립트를 사용한다는 것입니다.&lt;br /&gt;
웹 브라우저도 자바스크립트를 사용하므로 서버까지 노드를 사용하면 하나의 언어로 웹 사이트를 개발할 수 있습니다.&lt;br /&gt;
이는 개발 생산성을 획기적으로 높여주었고, 생산성이 중요한 기업이 노드를 체택하는 이유가 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;노드는 생산성은 매우 좋지만, Go처럼 비동기에 강점을 보이는 언어나 nginx처럼 정적 파일 제공, 로드 밸런싱에 특화된 서버에 비해서는 속도가 느립니다.&lt;/strong&gt;&lt;br /&gt;
그렇긴 해도 극단적인 성능이 필요하지 않다면 이러한 단점은 노드의 생산성으로 어느 정도 극복할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;자바스크립트를 사용하기 때문에 얻을 수 있는 소소한 장점도 있습니다.&lt;/strong&gt;&lt;br /&gt;
요즘은 XML 대신 JSON을 사용해서 데이터를 주고 받는데, JSON이 자바스크립트 형식이어서 노드에서는 쉽게 처리할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;표 1-1&lt;/strong&gt; 노드의 장단점&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;장점&lt;/th&gt;
      &lt;th&gt;단점&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;멀티 스레드 방식에 비해 컴퓨터 자원을 적게 사용함&lt;/td&gt;
      &lt;td&gt;싱글 스레드라서 CPU 코어를 하나만 사용함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;I/O 작업이 많은 서버로 적합&lt;/td&gt;
      &lt;td&gt;CPU 작업이 많은 서버로는 부적합&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;멀티 스레드 방식보다 쉬움&lt;/td&gt;
      &lt;td&gt;하나뿐인 스레드가 멈추지 않도록 관리해야 함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;웹 서버가 내장되어 있음&lt;/td&gt;
      &lt;td&gt;서버 규모가 커졌을 때 서버를 관리하기 어려움&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;자바스크립트를 사용&lt;/td&gt;
      &lt;td&gt;어중간한 성능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;JSON 형식과 호환하기 쉬움&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;p&gt;이와 같은 특성을 활용하려면 노드를 어디에 사용해야 할까요?&lt;br /&gt;
개수는 많지만 크기는 작은 데이터를 실시간으로 주고 받는 데 적합합니다.&lt;br /&gt;
&lt;strong&gt;네트워크나 데이터베이스, 디스크 작업 같은 I/O에 특화되어 있기 때문입니다.&lt;/strong&gt;&lt;br /&gt;
실시간 채팅 애플리케이션이나 주식 차트, JSON 데이터를 제공하는 API 서버가 노드를 많이 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;노드가 아무리 좋다고 하더라도 추천하지 않는 경우도 있습니다.&lt;/strong&gt;&lt;br /&gt;
이미지나 비디오 처리, 대규모 데이터 처리 같이 CPU를 많이 사용하는 작업을 위한 서버로는 권장하지 않습니다.&lt;br /&gt;
노드보다 더 적합한 다른 언어 서버가 많습니다.&lt;br /&gt;
&lt;strong&gt;요즘은 AWS Lambda나 Google Cloud Functions 같은 서비스에서 &lt;span style=&quot;color:red&quot;&gt;노드로 CPU를 많이 사용하는 작업을 처리하는 것을 지원&lt;/span&gt;합니다.&lt;/strong&gt;&lt;br /&gt;
16장에서 사용해볼 것입니다.&lt;/p&gt;

&lt;p&gt;그렇다면 실생활과 밀접한 쇼핑몰, 블로그 같은 웹 사이트에는 적합할까요?&lt;br /&gt;
이런 사이트는 보통 기본적인 틀이 있고, 그 안의 내용물(텍스트, 이미지)만 조금씩 달라집니다.&lt;br /&gt;
&lt;strong&gt;노드가 다른 서버 언어에 비해 이러한 컨텐츠를 제공하는 데 장점이 뚜렷하지는 않습니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;하지만 그렇다고 적합하지 않다는 것도 아닙니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;Pug나 EJS 같은 템플릿 엔진을 통해서 다른 언어와 비슷하게 컨텐츠를 제공할 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
템플릿 엔진은 6.5절에서 다룹니다.&lt;/p&gt;

&lt;p&gt;안전성과 보안성 측면의 문제도 이미 충분히 검증되었습니다.&lt;br /&gt;
규모가 큰 곳을 꼽자면 미국항공우주국(NASA), 에어비엔비, 우버, 넷플릭스, 링크드인 등에서 노드를 사용하고 있습니다.&lt;br /&gt;
페이팔, 월마트, 이베이 같은 결제 시스템을 사용하는 대기업들도 노드로 서비스를 운영합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image11.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Jun 2020 16:09:00 +0900</pubDate>
        <link>http://localhost:4000/nodebook/2020/06/08/node06.html</link>
        <guid isPermaLink="true">http://localhost:4000/nodebook/2020/06/08/node06.html</guid>
        
        
        <category>nodebook</category>
        
      </item>
    
      <item>
        <title>1.1.5 싱글 스레드</title>
        <description>&lt;h2 id=&quot;115-싱글-스레드&quot;&gt;1.1.5 싱글 스레드&lt;/h2&gt;

&lt;p&gt;이벤트 기반, 논블로킹 모델과 더불어 노드를 설명할 때 자주 나오는 용어가 하나 더 있습니다.&lt;br /&gt;
바로 &lt;strong&gt;싱글 스레드&lt;/strong&gt;입니다.&lt;br /&gt;
스레드를 이해하기 위해서는 프로세스도 알아야 하지만, 지금은 그냥 스레드가 컴퓨터 작업을 처리할 수 있는 일손이라고 생각하면 됩니다.&lt;br /&gt;
조금 뒤에 자세히 알아봅니다.&lt;/p&gt;

&lt;p&gt;노드가 싱글 스레드라는 말을 들어보셨나요?&lt;br /&gt;
노드는 싱글 스레드이므로 주어진 작업을 혼자서 처리해야 합니다.&lt;br /&gt;
반대로 멀티 스레드인 시스템에서는 여러 개의 스레드가 일을 나눠서 처리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;자바스크립트와 노드에서 논블로킹이 중요한 이유는 바로 싱글 스레드이기 때문입니다.&lt;/strong&gt;&lt;br /&gt;
한 번에 한 가지 일밖에 처리하지 못하므로 어떠한 작업에서 블로킹이 발생하면 다음 일을 처리하지 못합니다.&lt;/p&gt;

&lt;p&gt;언뜻 보면 여러 개의 일을 동시에 처리할 수 있기 때문에 멀티 스레드가 싱글 스레드보다 좋아 보입니다.&lt;br /&gt;
하지만 꼭 그런 것만은 아닙니다.&lt;br /&gt;
이해를 돕기 위한 예시를 하나 들어보겠습니다.&lt;/p&gt;

&lt;p&gt;한 음식점에 점원이 한 명 있습니다.&lt;br /&gt;
손님은 여러 명이고요.&lt;br /&gt;
점원 한 명이 주문을 받아 주방에 넘기고, 주방에서 요리가 나오면 손님에게 서빙을 합니다.&lt;br /&gt;
그 후 다음 손님의 주문을 받습니다.&lt;br /&gt;
이런 구조라면 다음 손님은 이전 손님의 요리가 나올 때까지 아무것도 못 하고 기다리고 있어야 합니다.&lt;br /&gt;
이것이 바로 싱글 스레드(점원), 블로킹 모델입니다.&lt;br /&gt;
매우 비효율적입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image07.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 점원이 한 손님의 주문을 받고, 주방에 주문 내역을 넘긴 뒤 다음 손님의 주문을 받습니다.&lt;br /&gt;
요리가 끝나길 기다리지 않고 주문이 들어왔다는 것만 알려주는 것입니다.&lt;br /&gt;
주방에서 요리가 완료되면 완료된 순서대로 손님에게 서빙합니다.&lt;br /&gt;
주문한 순서와 서빙하는 순서가 일치하지 않을 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이것이 싱글 스레드, 논블로킹 모델입니다.&lt;/strong&gt;&lt;br /&gt;
바로 노드가 채택하고 있는 방식입니다.&lt;br /&gt;
점원은 한 명이지만 혼자서 많은 일을 처리할 수 있습니다.&lt;br /&gt;
하지만 그 점원 한 명이 아파서 쓰러지거나 하면 큰 문제가 생길 수 있습니다.&lt;br /&gt;
또한, 주문을 받거나 서빙을 하는 데 시간이 오래 걸린다면 주문이 많이 들어 왔을 때 버거울 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image08.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;멀티 스레드 방식에서는 손님이 올 때마다 점원이 한 명씩 맡아 주문을 받고 서빙합니다.&lt;br /&gt;
언뜻 보면 싱글 스레드보다 좋은 방법인 것 같지만, 장단점이 있습니다.&lt;br /&gt;
일단 손님 한 명당 점원도 한 명이면 서빙 자체는 걱정이 없습니다.&lt;br /&gt;
점원 한 명에게 문제가 생겨도 다른 점원으로 대체하면 되기 때문입니다.&lt;br /&gt;
하지만 손님의 수가 늘어날수록 점원의 수도 늘어납니다.&lt;br /&gt;
손님의 수가 줄어들었을 때 일을 하지 않고 노는 점원도 있다는 것도 문제가 됩니다.&lt;br /&gt;
점원을 새로 고용하거나 기존 직원을 해고하는 데는 비용이 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image09.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 점원 여러 명(멀티 스레드)이 모두 논블로킹 방식으로 주문을 받으면 더 좋지 않을까 하는 의문이 들 수 있습니다.&lt;br /&gt;
실제로 그렇습니다.&lt;br /&gt;
노드도 싱글 스레드 여러 개를 사용해 멀티 스레딩과 비슷한 기능을 하게 할 수 있습니다.&lt;br /&gt;
하지만 엄밀히 말하면 멀티 스레딩이라기보다는 멀티 프로세싱에 가깝습니다.&lt;br /&gt;
그럼 프로세스와 스레드의 차이에 대해 알아봅시다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;프로세스&lt;/strong&gt;는 운영체제에서 할당하는 작업의 단위입니다.&lt;br /&gt;
노드나 인터넷 브라우저 같은 프로그램은 개별적인 프로세스입니다.&lt;br /&gt;
프로세스 간에는 메모리 등의 자원을 공유하지 않습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;스레드&lt;/strong&gt;는 프로세스 내에서 실행되는 흐름의 단위입니다.&lt;br /&gt;
하나의 프로세스는 스레드를 여러 개 가질 수 있습니다.&lt;br /&gt;
스레드들은 부모 프로세스의 자원을 공유합니다.&lt;br /&gt;
즉, 같은 메모리에 접근할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스레드를 작업을 처리하는 일손으로 표현하기도 하는데, 노드 프로세스는 일손이 하나인 셈입니다.&lt;br /&gt;
요청이 많이 들어오면 한 번에 하나의 요청을 처리합니다.&lt;br /&gt;
블로킹이 심하게 일어나지만 않는다면 하나로도 충분합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;사실 노드 프로세스도 내부적으로는 스레드를 여러 개 가지고 있습니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;하지만 여러분이 직접 제어할 수 있는 스레드는 하나뿐이므로 흔히 싱글 스레드라고 부르는 것입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image10.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;노드는 스레드를 늘리는 대신, 프로세스 자체를 복사해 여러 작업을 동시에 처리하는 멀티 프로세싱 방식을 택했습니다.&lt;br /&gt;
자바스크립트 언어 자체가 싱글 스레드 특성을 띠고 있기 때문입니다.&lt;br /&gt;
4.5절의 &lt;strong&gt;cluster 모듈&lt;/strong&gt;과 15.1.5절의 &lt;strong&gt;pm2 패키지&lt;/strong&gt;에서 멀티 프로세싱을 가능하게 하는 방법에 대해 알아봅니다.&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Jun 2020 09:57:00 +0900</pubDate>
        <link>http://localhost:4000/nodebook/2020/06/08/node05.html</link>
        <guid isPermaLink="true">http://localhost:4000/nodebook/2020/06/08/node05.html</guid>
        
        
        <category>nodebook</category>
        
      </item>
    
      <item>
        <title>1.1.4 논블로킹 I/O</title>
        <description>&lt;h2 id=&quot;114-논블로킹-io&quot;&gt;1.1.4 논블로킹 I/O&lt;/h2&gt;

&lt;p&gt;이벤트 루프를 잘 활용하면 오래 걸리는 작업을 효율적으로 처리할 수 있습니다.&lt;br /&gt;
오래 걸리는 함수를 백그라운드로 보내서 다음 코드가 먼저 실행되게 하고, 그 함수가 다시 테스크 큐를 
거쳐 호출 스택으로 올라오기를 기다리는 방식입니다.&lt;br /&gt;
&lt;strong&gt;이 방식이 논블로킹 방식입니다.&lt;/strong&gt;&lt;br /&gt;
논블로킹이란 이전 작업이 완료될 때까지 멈추지 않고 다음 작업을 수행함을 뜻합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/nodebook/image06.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림 1-9를 부면 블로킹보다 논블로킹 방식이 같은 작업을 더 짧은 시간 동안 처리할 수 있음을 알 수 있습니다.&lt;br /&gt;
하지만 &lt;strong&gt;싱글 스레드&lt;/strong&gt;라는 한계 때문에 자바스크립트의 모든 코드가 이 방식으로 시간적 이득을 볼 수 있는 것은 
아닙니다.&lt;br /&gt;
&lt;strong&gt;현재 노드 프로세스 외의 &lt;span style=&quot;color:red&quot;&gt;다른 컴퓨팅 자원을 사용할 수 있는 I/O 작업&lt;/span&gt;이 주로 시간적 이득을 많이 봅니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;io-작업&quot;&gt;I/O 작업&lt;/h3&gt;

&lt;p&gt;I/O는 입력(input)/출력(output)을 의미합니다.&lt;br /&gt;
파일 시스템 접근(파일 읽기, 쓰기, 폴더 만들기 등)이나 네트워크 요청 같은 작업이 I/O의 일종입니다.&lt;br /&gt;
이러한 작업을 할 때 노드는 논블로킹 방식으로 동작합니다.&lt;/p&gt;

&lt;h3 id=&quot;블로킹논블로킹-동기비동기&quot;&gt;블로킹/논블로킹, 동기/비동기&lt;/h3&gt;

&lt;p&gt;블로킹과 논블로킹 말고도 동기와 비동기라는 개념에 대해서도 들어보았을 겁니다.&lt;br /&gt;
이 개념은 코드를 보지 않고서는 이해하기 어렵습니다.&lt;br /&gt;
동기와 비동기, 블로킹과 논블로킹의 관계는 3.6.1절에서 코드와 함께 설명합니다.&lt;br /&gt;
그 전까지는 동기와 블로킹이 유사하고, 비동기와 논블로킹이 유사하다고만 알아두면 됩니다.&lt;/p&gt;

&lt;p&gt;다음 예제는 블로킹 방식의 코드입니다.&lt;br /&gt;
콘솔 결과를 미리 예측해보세요.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;longRunningTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 오래 걸리는 작업&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;작업 끝&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;시작&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;longRunningTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;다음 작업&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;시작
작업 끝
다음 작업
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;작업을 수행하는 데 오래 걸리는 longRunningTask 함수가 있다고 가정해봅시다.&lt;br /&gt;
이 작업이 완료되기 전까지는 이어지는 &lt;strong&gt;console.log(‘다음 작업)&lt;/strong&gt;이 호출되지 않습니다.&lt;/p&gt;

&lt;p&gt;이번에는 setTimeout을 사용해서 코드를 바꿔보겠습니다.&lt;br /&gt;
&lt;strong&gt;논블로킹 방식의 코드입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;longRunningTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 오래 걸리는 작업&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;작업 끝&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;시작&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;longRunningTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;다음 작업&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;시작
다음 작업
작업 끝
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;setTimeout(콜백, 0)&lt;/strong&gt;은 코드를 논블로킹으로 만들기 위해 사용하는 기법 중 하나입니다.&lt;br /&gt;
노드에서는 &lt;strong&gt;setTimeout(콜백, 0)&lt;/strong&gt; 대신 다른 방식을 주로 사용합니다(3.4.3절 참조).&lt;br /&gt;
이벤트 루프를 이해했다면 &lt;strong&gt;setTimeout&lt;/strong&gt;의 콜백 함수가 태스크 큐로 보내지므로 순서대로 실행되지 않는다는 것을 
알 수 있습니다.&lt;br /&gt;
다음 작업이 먼저 실행된 후, 오래걸리는 작업이 완료됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;setTimeout(콜백, 0)&lt;/strong&gt;&lt;br /&gt;
밀리초를 0으로 설정했으므로 바로 실행되는 것이 아닌가 착각할 수 있습니다.&lt;br /&gt;
하지만 브라우저와 노드에서는 기본적인 지연 시간이 있으므로 바로 실행되지 않습니다.&lt;br /&gt;
HTML5 브라우저에서는 4ms, 노드에서는 1ms의 지연 시간이 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 08 Jun 2020 01:12:00 +0900</pubDate>
        <link>http://localhost:4000/nodebook/2020/06/08/node04.html</link>
        <guid isPermaLink="true">http://localhost:4000/nodebook/2020/06/08/node04.html</guid>
        
        
        <category>nodebook</category>
        
      </item>
    
  </channel>
</rss>
