<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-04-24T07:32:52+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">LHJ</title><subtitle>coding blog</subtitle><entry><title type="html">git commit 기록 변경하기</title><link href="http://localhost:4000/issue/2020/04/23/issue01/" rel="alternate" type="text/html" title="git commit 기록 변경하기" /><published>2020-04-23T19:47:19+09:00</published><updated>2020-04-23T19:47:19+09:00</updated><id>http://localhost:4000/issue/2020/04/23/issue01</id><content type="html" xml:base="http://localhost:4000/issue/2020/04/23/issue01/">&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git log &lt;span class=&quot;nt&quot;&gt;--oneline&lt;/span&gt;

5f76815 ~~ &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;HEAD -&amp;gt; master, origin/master&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
e6d6d51 ~~  // 내가 변경하고 싶은 커밋기록
68b2987 ~~
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git rebase &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; 68b2987   // 변경 원하는 커밋기록 이전 커밋번호
git rebase &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt;  HEAD~2  // HEAD가 가리키고있는 지점이 숫자 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 명령어까지 입력하면 vi 편집기가 나타나는데,&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;edit e6d6d51 ~~~
pick 5f76815 ~~~
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;변경하기 원하는 커밋기록 부분의 pick을 edit로 변경 후&lt;br /&gt;
esc 키입력 후 :wq 엔터입력&lt;/p&gt;

&lt;p&gt;여기서부터 다시 커밋기록을 쌓아나가면 된다.&lt;br /&gt;
추가할 커밋기록이 있으면 추가하고, 커밋 메시지만 수정하고 싶으면 수정하고..&lt;br /&gt;
여튼 커밋하려면&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git commit &lt;span class=&quot;nt&quot;&gt;--amend&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 명령어 입력&lt;br /&gt;
왜냐면 내가 수정하고 싶은 &lt;code class=&quot;highlighter-rouge&quot;&gt;e6d6d51&lt;/code&gt; 커밋 기록을 수정해야되므로.. 바로 이전 커밋기록 수정한다는 의미&lt;br /&gt;
그리고&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git rebase &lt;span class=&quot;nt&quot;&gt;--continue&lt;/span&gt; // 이 명령어로 원래 다음 커밋기록이었던 5f76815 커밋기록 불러옴

git status // 충돌안났는지 상태 확인 후 

git add &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; // 다시 추가 후

git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'커밋메시지'&lt;/span&gt;  // 다시 커밋
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;즉, 수정하고 싶은 내역의 커밋기록을 수정 후 ,&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;그 다음 커밋은 다시 재커밋을 실행하여 새롭게 커밋을 쌓아나가는 것이 rebase&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git push origin branch이름 &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다른 사람이 아직 보기 전, 또는 pull 받기 전이라면 얼릉 강제 푸시해서 커밋기록을 변경~!&lt;br /&gt;
그러면 끝~!&lt;/p&gt;</content><author><name></name></author><summary type="html">git log --oneline 5f76815 ~~ (HEAD -&amp;gt; master, origin/master) e6d6d51 ~~ // 내가 변경하고 싶은 커밋기록 68b2987 ~~ git rebase -i 68b2987 // 변경 원하는 커밋기록 이전 커밋번호 git rebase -i HEAD~2 // HEAD가 가리키고있는 지점이 숫자 1 위 명령어까지 입력하면 vi 편집기가 나타나는데, edit e6d6d51 ~~~ pick 5f76815 ~~~ 변경하기 원하는 커밋기록 부분의 pick을 edit로 변경 후 esc 키입력 후 :wq 엔터입력 여기서부터 다시 커밋기록을 쌓아나가면 된다. 추가할 커밋기록이 있으면 추가하고, 커밋 메시지만 수정하고 싶으면 수정하고.. 여튼 커밋하려면 git commit --amend 위 명령어 입력 왜냐면 내가 수정하고 싶은 e6d6d51 커밋 기록을 수정해야되므로.. 바로 이전 커밋기록 수정한다는 의미 그리고 git rebase --continue // 이 명령어로 원래 다음 커밋기록이었던 5f76815 커밋기록 불러옴 git status // 충돌안났는지 상태 확인 후 git add * // 다시 추가 후 git commit -m '커밋메시지' // 다시 커밋 즉, 수정하고 싶은 내역의 커밋기록을 수정 후 , 그 다음 커밋은 다시 재커밋을 실행하여 새롭게 커밋을 쌓아나가는 것이 rebase git push origin branch이름 -f 다른 사람이 아직 보기 전, 또는 pull 받기 전이라면 얼릉 강제 푸시해서 커밋기록을 변경~! 그러면 끝~!</summary></entry><entry><title type="html">svg 이미지 잘림현상</title><link href="http://localhost:4000/issue/2020/04/23/issue00/" rel="alternate" type="text/html" title="svg 이미지 잘림현상" /><published>2020-04-23T19:31:16+09:00</published><updated>2020-04-23T19:31:16+09:00</updated><id>http://localhost:4000/issue/2020/04/23/issue00</id><content type="html" xml:base="http://localhost:4000/issue/2020/04/23/issue00/">&lt;p&gt;&lt;img src=&quot;/assets/img/issue/issue02.jpg&quot; alt=&quot;이미지 잘림현상&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SVG 이미지 잘림현상입니다.&lt;br /&gt;
해당 현상은 처음 화면에선 재현되지 않으나 해당 화면을 확대 및 축소하면 특정 구간에서 나타나는 현상입니다.&lt;br /&gt;
(100% 화면일 때도 나타날지도 모릅니다.. 하지만 발견하진 못했습니다.)&lt;/p&gt;

&lt;p&gt;해당 이슈 원인을 알아보기 위해 여러 정보를 찾던 중 아래와 같은 글을 발견했습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.liquidlight.co.uk/blog/working-with-svgs-in-sprites/&quot;&gt;SVG 관련글 링크&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/issue/issue00.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당글에 위와 같은 댓글이 달려있었습니다.&lt;br /&gt;
내용은 SVG를 sprite 이미지로 background-image로 넣을 시 width와 height의 값,&lt;br /&gt;
그리고 background-position의 값이 소숫점으로 잡히는 경우가 있는데,&lt;br /&gt;
그럴 때 브라우저마다 랜더링의 차이로 인해 이미지가 잘려보일 수도 있다는 내용이었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/issue/issue01.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;즉, 그렇기 때문에 위와 같이 여유 공간을 두어 적용하자는 내용입니다.&lt;/p&gt;

&lt;p&gt;사실, 위 이슈의 정확한 원인이 무엇인지는 아직 잘 모르겠습니다.&lt;br /&gt;
직접 저런 이슈를 본 적은 없기 때문입니다.&lt;br /&gt;
그렇기에 해결법도 맞는 해결법인지를 잘 모르겠습니다.&lt;br /&gt;
해당 이슈는 좀 더 알아봐야 될 것 같습니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">SVG 이미지 잘림현상입니다. 해당 현상은 처음 화면에선 재현되지 않으나 해당 화면을 확대 및 축소하면 특정 구간에서 나타나는 현상입니다. (100% 화면일 때도 나타날지도 모릅니다.. 하지만 발견하진 못했습니다.) 해당 이슈 원인을 알아보기 위해 여러 정보를 찾던 중 아래와 같은 글을 발견했습니다. SVG 관련글 링크 해당글에 위와 같은 댓글이 달려있었습니다. 내용은 SVG를 sprite 이미지로 background-image로 넣을 시 width와 height의 값, 그리고 background-position의 값이 소숫점으로 잡히는 경우가 있는데, 그럴 때 브라우저마다 랜더링의 차이로 인해 이미지가 잘려보일 수도 있다는 내용이었습니다. 즉, 그렇기 때문에 위와 같이 여유 공간을 두어 적용하자는 내용입니다. 사실, 위 이슈의 정확한 원인이 무엇인지는 아직 잘 모르겠습니다. 직접 저런 이슈를 본 적은 없기 때문입니다. 그렇기에 해결법도 맞는 해결법인지를 잘 모르겠습니다. 해당 이슈는 좀 더 알아봐야 될 것 같습니다.</summary></entry><entry><title type="html">5.9.1 비트 연산자</title><link href="http://localhost:4000/javascript/2020/04/21/javascript94/" rel="alternate" type="text/html" title="5.9.1 비트 연산자" /><published>2020-04-21T22:37:00+09:00</published><updated>2020-04-21T22:37:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/21/javascript94</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/21/javascript94/">&lt;p&gt;&lt;strong&gt;비트 연산자는 숫자의 비트를 직접 조작합니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;C 같은 저수준 언어를 다뤄 본 경험이 없거나, 컴퓨터가 내부적으로 숫자를 어떻게 저장하는지 배운 적이 없다면 비트 연산자를 이해하기가 힘들 겁니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;비트 연산자에 대해 알고 싶다면 컴퓨터가 숫자를 저장하는 방법에 대해 먼저 알아둬야 합니다.&lt;br /&gt;
&lt;strong&gt;하지만 비트 연산자가 꼭 필요한 경우는 거의 없으므로&lt;/strong&gt;, 비트 연산자에 대한 이 섹션은 건너뛰거나 훑어보고 넘어가도 상관없습니다.&lt;/p&gt;

&lt;p&gt;비트 연산자는 피연산자를 &lt;strong&gt;2의 보수(two’s complement) 형식으로 저장된 32 비트 부호 붙은 정수(signed integer)&lt;/strong&gt; 로 간주합니다.&lt;br /&gt;
자바스크립트의 숫자는 모두 더블 형식이므로 자바스크립트는 비트 연산자를 실행하기 전에 숫자를 먼저 32 비트 정수로 변환하고, 결과를 반환할 때 다시 더블 형식으로 변환합니다.&lt;/p&gt;

&lt;p&gt;비트 연산자는 논리 연산자 AND와 OR, NOT, XOR 같은 논리 연산을 하지만 이 연산을 정수의 개별 비트에서 수행합니다.&lt;br /&gt;
이외에도 비트를 다른 위치로 옮기는 &lt;strong&gt;시프트(shift)&lt;/strong&gt; 연산자도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;표 5-7 비트 연산자&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;연산자&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
      &lt;th&gt;예제&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;amp;&lt;/td&gt;
      &lt;td&gt;비트 AND&lt;/td&gt;
      &lt;td&gt;0b1010 &amp;amp; 0b1100 // 결과 : 0b1000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;|&lt;/td&gt;
      &lt;td&gt;비트 OR&lt;/td&gt;
      &lt;td&gt;0b1010 | 0b1100 // 결과 : 0b1110&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;^&lt;/td&gt;
      &lt;td&gt;비트 XOR&lt;/td&gt;
      &lt;td&gt;0b1010 ^ 0b1100 // 결과 : 0b0110&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;~&lt;/td&gt;
      &lt;td&gt;비트 NOT&lt;/td&gt;
      &lt;td&gt;~0b1010 // 결과 : 0b0101&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;p&gt;다음은 책 내용과 무관하게 비트연산자를 공부하면서 공부한 내용입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image40.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&amp;lt; &amp;lt;&lt;/th&gt;
      &lt;th&gt;왼쪽 시프트&lt;/th&gt;
      &lt;th&gt;0b1010 &amp;lt; &amp;lt; 1 // 결과 : 0b10100  &lt;br /&gt;  0b1010 « 2 // 결과: 0b101000&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&amp;gt; &amp;gt;&lt;/td&gt;
      &lt;td&gt;부호가 따라가는(Sign-propagating) 오른쪽 시프트&lt;/td&gt;
      &lt;td&gt;아래 코드를 보십시오&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&amp;gt; &amp;gt; &amp;gt;&lt;/td&gt;
      &lt;td&gt;0으로 채우는(Zero-fit) 오른쪽 시프트&lt;/td&gt;
      &lt;td&gt;아래 코드를 보십시오&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">비트 연산자는 숫자의 비트를 직접 조작합니다. C 같은 저수준 언어를 다뤄 본 경험이 없거나, 컴퓨터가 내부적으로 숫자를 어떻게 저장하는지 배운 적이 없다면 비트 연산자를 이해하기가 힘들 겁니다. 비트 연산자에 대해 알고 싶다면 컴퓨터가 숫자를 저장하는 방법에 대해 먼저 알아둬야 합니다. 하지만 비트 연산자가 꼭 필요한 경우는 거의 없으므로, 비트 연산자에 대한 이 섹션은 건너뛰거나 훑어보고 넘어가도 상관없습니다. 비트 연산자는 피연산자를 2의 보수(two’s complement) 형식으로 저장된 32 비트 부호 붙은 정수(signed integer) 로 간주합니다. 자바스크립트의 숫자는 모두 더블 형식이므로 자바스크립트는 비트 연산자를 실행하기 전에 숫자를 먼저 32 비트 정수로 변환하고, 결과를 반환할 때 다시 더블 형식으로 변환합니다. 비트 연산자는 논리 연산자 AND와 OR, NOT, XOR 같은 논리 연산을 하지만 이 연산을 정수의 개별 비트에서 수행합니다. 이외에도 비트를 다른 위치로 옮기는 시프트(shift) 연산자도 있습니다. 표 5-7 비트 연산자 연산자 설명 예제 &amp;amp; 비트 AND 0b1010 &amp;amp; 0b1100 // 결과 : 0b1000 | 비트 OR 0b1010 | 0b1100 // 결과 : 0b1110 ^ 비트 XOR 0b1010 ^ 0b1100 // 결과 : 0b0110 ~ 비트 NOT ~0b1010 // 결과 : 0b0101 다음은 책 내용과 무관하게 비트연산자를 공부하면서 공부한 내용입니다. &amp;lt; &amp;lt; 왼쪽 시프트 0b1010 &amp;lt; &amp;lt; 1 // 결과 : 0b10100 0b1010 « 2 // 결과: 0b101000 &amp;gt; &amp;gt; 부호가 따라가는(Sign-propagating) 오른쪽 시프트 아래 코드를 보십시오 &amp;gt; &amp;gt; &amp;gt; 0으로 채우는(Zero-fit) 오른쪽 시프트 아래 코드를 보십시오</summary></entry><entry><title type="html">5.9 연산자 그룹</title><link href="http://localhost:4000/javascript/2020/04/21/javascript93/" rel="alternate" type="text/html" title="5.9 연산자 그룹" /><published>2020-04-21T22:30:00+09:00</published><updated>2020-04-21T22:30:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/21/javascript93</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/21/javascript93/">&lt;p&gt;이미 언급했듯 그룹 연산자(괄호)에는 아무 효과도 없지만 연산자 우선순위를 높이거나 명확히 표현하는 데 쓸 수 있습니다.&lt;br /&gt;
&lt;strong&gt;따라서 그룹 연산자는 연산 순서만 바꿀 뿐, 다른 부작용은 전혀 없는 안전한 연산자입니다.&lt;/strong&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">이미 언급했듯 그룹 연산자(괄호)에는 아무 효과도 없지만 연산자 우선순위를 높이거나 명확히 표현하는 데 쓸 수 있습니다. 따라서 그룹 연산자는 연산 순서만 바꿀 뿐, 다른 부작용은 전혀 없는 안전한 연산자입니다.</summary></entry><entry><title type="html">5.8.4 쉼표 연산자</title><link href="http://localhost:4000/javascript/2020/04/21/javascript92/" rel="alternate" type="text/html" title="5.8.4 쉼표 연산자" /><published>2020-04-21T22:03:00+09:00</published><updated>2020-04-21T22:03:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/21/javascript92</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/21/javascript92/">&lt;p&gt;&lt;strong&gt;쉼표 연산자는 표현식을 결합하여 두 표현식을 평가한 후, 두 번째 표현식의 결과를 반환합니다.&lt;/strong&gt;&lt;br /&gt;
표현식을 하나 이상 실행해야 하지만 값으로 필요한 것은 마지막 표현식의 결과뿐일 때 쉼표 연산자를 유용하게 쓸 수 있습니다.&lt;br /&gt;
다음 예제를 보십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 예제에서 x와 y는 모두 1만큼 늘어나지만, &lt;strong&gt;z의 값은 10, 즉 y++가 반환하는 값&lt;/strong&gt;입니다.&lt;br /&gt;
&lt;strong&gt;쉼표 연산자는 우선순위가 가장 낮은 연산자이므로 괄호를 사용했습니다.&lt;/strong&gt;&lt;br /&gt;
여기서 괄호를 사용하지 않았다면 z에는 0(x++가 반환하는 값)이 저장되고 그 다음에 y가 1만큼 늘어났을 겁니다.&lt;br /&gt;
쉼표 연산자는 for 문에서 표현식을 결합할 때 사용하거나(4장을 보십시오), 함수에서 빠져나오기 전에 여러 가지 작업을 한데 묶을 때 사용합니다(6장을 보십시오).&lt;/p&gt;

&lt;p&gt;아.. for문 표현식 쉼표 연산자 결합이라면…?&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이건가??&lt;/p&gt;</content><author><name></name></author><summary type="html">쉼표 연산자는 표현식을 결합하여 두 표현식을 평가한 후, 두 번째 표현식의 결과를 반환합니다. 표현식을 하나 이상 실행해야 하지만 값으로 필요한 것은 마지막 표현식의 결과뿐일 때 쉼표 연산자를 유용하게 쓸 수 있습니다. 다음 예제를 보십시오. let x = 0, y = 10, z; z = (x++, y++); 이 예제에서 x와 y는 모두 1만큼 늘어나지만, z의 값은 10, 즉 y++가 반환하는 값입니다. 쉼표 연산자는 우선순위가 가장 낮은 연산자이므로 괄호를 사용했습니다. 여기서 괄호를 사용하지 않았다면 z에는 0(x++가 반환하는 값)이 저장되고 그 다음에 y가 1만큼 늘어났을 겁니다. 쉼표 연산자는 for 문에서 표현식을 결합할 때 사용하거나(4장을 보십시오), 함수에서 빠져나오기 전에 여러 가지 작업을 한데 묶을 때 사용합니다(6장을 보십시오). 아.. for문 표현식 쉼표 연산자 결합이라면…? for (let i=0; i&amp;lt;arr.length; i++) { } 이건가??</summary></entry><entry><title type="html">5.8.3 조건 연산자</title><link href="http://localhost:4000/javascript/2020/04/21/javascript91/" rel="alternate" type="text/html" title="5.8.3 조건 연산자" /><published>2020-04-21T21:51:00+09:00</published><updated>2020-04-21T21:51:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/21/javascript91</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/21/javascript91/">&lt;p&gt;조건 연산자는 자바스크립트의 유일한 &lt;strong&gt;3항(ternary)&lt;/strong&gt; 연산자입니다.&lt;br /&gt;
즉, 이 연산자는 피연산자 세개를 받습니다(다른 연산자는 모두 피연산자 한 개 또는 두 개를 받습니다).&lt;br /&gt;
&lt;strong&gt;조건 연산자는 if … else 문과 동등한 표현식입니다.&lt;/strong&gt;&lt;br /&gt;
다음 예제를 보십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;doIt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;doIt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Did it!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Didn't do it.&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;물음표 앞에 있는 첫 번째 피연산자(doIt)가 참 같은 값이면, 이 표현식의 값은 두 번째 피연산자(물음표와 콜론 사이)이며, 거짓 같은 값이면 이 표현식의 값은 세 번째 피연산자(콜론 다음)입니다.&lt;br /&gt;
&lt;strong&gt;초보 프로그래머들은 3항 연산자를 if … else 문을 혼란스럽게 바꿔 놓은 것 아니냐는 식으로 생각하지만, 3항 연산자는 &lt;span style=&quot;color:red;&quot;&gt;문이 아니라 표현식&lt;/span&gt;이므로 다른 표현식과 결합하여 매우 유용하게 사용할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">조건 연산자는 자바스크립트의 유일한 3항(ternary) 연산자입니다. 즉, 이 연산자는 피연산자 세개를 받습니다(다른 연산자는 모두 피연산자 한 개 또는 두 개를 받습니다). 조건 연산자는 if … else 문과 동등한 표현식입니다. 다음 예제를 보십시오. const doIt = false; const result = doIt ? &quot;Did it!&quot; : &quot;Didn't do it.&quot;; 물음표 앞에 있는 첫 번째 피연산자(doIt)가 참 같은 값이면, 이 표현식의 값은 두 번째 피연산자(물음표와 콜론 사이)이며, 거짓 같은 값이면 이 표현식의 값은 세 번째 피연산자(콜론 다음)입니다. 초보 프로그래머들은 3항 연산자를 if … else 문을 혼란스럽게 바꿔 놓은 것 아니냐는 식으로 생각하지만, 3항 연산자는 문이 아니라 표현식이므로 다른 표현식과 결합하여 매우 유용하게 사용할 수 있습니다.</summary></entry><entry><title type="html">5.8.2 피연산자가 불리언이 아닐 때 논리 연산자가 동작하는 방법</title><link href="http://localhost:4000/javascript/2020/04/21/javascript90/" rel="alternate" type="text/html" title="5.8.2 피연산자가 불리언이 아닐 때 논리 연산자가 동작하는 방법" /><published>2020-04-21T21:37:00+09:00</published><updated>2020-04-21T21:37:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/21/javascript90</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/21/javascript90/">&lt;p&gt;불리언 피연산자를 사용하면 논리 연산자는 항상 불리언을 반환합니다.&lt;br /&gt;
피연산자가 불리언이 아니라면, &lt;strong&gt;결과를 결정한 값&lt;/strong&gt;이 반환됩니다.&lt;br /&gt;
[표 5-5]와 [표 5-6]을 보십시오.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;표 5-5 불리언이 아닌 피연산자에 대한 AND(&amp;amp;&amp;amp;)의 진위표&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;x&lt;/th&gt;
      &lt;th&gt;y&lt;/th&gt;
      &lt;th&gt;x &amp;amp;&amp;amp; y&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;거짓 같은 값&lt;/td&gt;
      &lt;td&gt;거짓 같은 값&lt;/td&gt;
      &lt;td&gt;x (거짓 같은 값)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;거짓 같은 값&lt;/td&gt;
      &lt;td&gt;참 같은 값&lt;/td&gt;
      &lt;td&gt;x (거짓 같은 값)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;참 같은 값&lt;/td&gt;
      &lt;td&gt;거짓 같은 값&lt;/td&gt;
      &lt;td&gt;y (거짓 같은 값)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;참 같은 값&lt;/td&gt;
      &lt;td&gt;참 같은 값&lt;/td&gt;
      &lt;td&gt;y (참 같은 값)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;표 5-6 불리언 아닌 피연산자에 대한 OR(||)의 진위표&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;x&lt;/th&gt;
      &lt;th&gt;y&lt;/th&gt;
      &lt;th&gt;x || y&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;거짓 같은 값&lt;/td&gt;
      &lt;td&gt;거짓 같은 값&lt;/td&gt;
      &lt;td&gt;y (거짓 같은 값)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;거짓 같은 값&lt;/td&gt;
      &lt;td&gt;참 같은 값&lt;/td&gt;
      &lt;td&gt;y (참 같은 값)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;참 같은 값&lt;/td&gt;
      &lt;td&gt;거짓 같은 값&lt;/td&gt;
      &lt;td&gt;x (참 같은 값)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;참 같은 값&lt;/td&gt;
      &lt;td&gt;참 같은 값&lt;/td&gt;
      &lt;td&gt;x (참 같은 값)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;결과를 불리언으로 변환하면 불리언 값을 제공했을 때의 진위표와 같은 결과가 됩니다.&lt;br /&gt;
논리 연산자의 이런 동작 방식을 활용하는 간편한 팁이 있습니다.&lt;br /&gt;
다음 패턴은 아주 자주 쓰고, 또 보게 될 겁니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;options&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;suppliedOptions&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Default&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;객체는 항상(빈 객체더라도) 참 같은 값으로 평가&lt;/strong&gt;됩니다.&lt;br /&gt;
따라서 suppliedOptions 가 객체이면 options는 suppliedOptions를 가리키게 됩니다.&lt;br /&gt;
옵션이 제공되지 않으면 즉 suppliedOptions 가 null이나 undefined라면 options는 기본값을 갖게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOT 은 불리언이 아닌 값을 반환할 수 없으므로 ! 연산자는 피연산자의 타입이 무엇이든 항상 불리언을 반환합니다.&lt;/strong&gt;&lt;br /&gt;
피연산자가 참 같은 값이면 false를, 거짓 같은 값이면 true를 반환합니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">불리언 피연산자를 사용하면 논리 연산자는 항상 불리언을 반환합니다. 피연산자가 불리언이 아니라면, 결과를 결정한 값이 반환됩니다. [표 5-5]와 [표 5-6]을 보십시오. 표 5-5 불리언이 아닌 피연산자에 대한 AND(&amp;amp;&amp;amp;)의 진위표 x y x &amp;amp;&amp;amp; y 거짓 같은 값 거짓 같은 값 x (거짓 같은 값) 거짓 같은 값 참 같은 값 x (거짓 같은 값) 참 같은 값 거짓 같은 값 y (거짓 같은 값) 참 같은 값 참 같은 값 y (참 같은 값) 표 5-6 불리언 아닌 피연산자에 대한 OR(||)의 진위표 x y x || y 거짓 같은 값 거짓 같은 값 y (거짓 같은 값) 거짓 같은 값 참 같은 값 y (참 같은 값) 참 같은 값 거짓 같은 값 x (참 같은 값) 참 같은 값 참 같은 값 x (참 같은 값) 결과를 불리언으로 변환하면 불리언 값을 제공했을 때의 진위표와 같은 결과가 됩니다. 논리 연산자의 이런 동작 방식을 활용하는 간편한 팁이 있습니다. 다음 패턴은 아주 자주 쓰고, 또 보게 될 겁니다. const options = suppliedOptions || { name: &quot;Default&quot; } 객체는 항상(빈 객체더라도) 참 같은 값으로 평가됩니다. 따라서 suppliedOptions 가 객체이면 options는 suppliedOptions를 가리키게 됩니다. 옵션이 제공되지 않으면 즉 suppliedOptions 가 null이나 undefined라면 options는 기본값을 갖게 됩니다. NOT 은 불리언이 아닌 값을 반환할 수 없으므로 ! 연산자는 피연산자의 타입이 무엇이든 항상 불리언을 반환합니다. 피연산자가 참 같은 값이면 false를, 거짓 같은 값이면 true를 반환합니다.</summary></entry><entry><title type="html">5.8.1 단축 평가</title><link href="http://localhost:4000/javascript/2020/04/21/javascript89/" rel="alternate" type="text/html" title="5.8.1 단축 평가" /><published>2020-04-21T21:18:00+09:00</published><updated>2020-04-21T21:18:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/21/javascript89</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/21/javascript89/">&lt;p&gt;AND 연산에 대한 진위표를 보면 두 값을 모두 평가하지 않아도 될 때가 있음을 알 수 잇ㅆ브니다.&lt;br /&gt;
&lt;strong&gt;x가 거짓 같은 값이면 x &amp;amp;&amp;amp; y는 y의 값을 평가할 필요도 없이 false입니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;마찬가지로 x || y 에서 x가 참 같은 값이면 y를 평가할 필요도 없이 true입니다.&lt;/strong&gt;&lt;br /&gt;
자바스크립트는 정확히 이런 방식으로 동작하며, 이런 동작을 &lt;strong&gt;단축 평가(short-circuit evaluation)&lt;/strong&gt; 라고 합니다.&lt;/p&gt;

&lt;p&gt;단축 평가가 중요한 이유는 뭘까요?&lt;br /&gt;
두 번째 피연산자에 &lt;strong&gt;부수 효과(side effect)&lt;/strong&gt; 가 있다 하더라도 단축 평가를 거치면 그 효과는 일어나지 않기 때문입니다.&lt;br /&gt;
부수 효과는 보통 부정적인 의미로 쓰이지만 항상 그런 건 아닙니다.&lt;br /&gt;
결과가 의도적이고 명확하다면 나쁘게 평가할 이유는 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;표현식에서 부수 효과는 증가, 감소, 할당, 함수 호출에서 일어날 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
증가와 감소 연산자는 이미 살펴봤으니 이들에 관한 예제를 봅시다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;skipIt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;skipIt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예제의 세 번째 행의 결과는 result에 저장됩니다.&lt;br /&gt;
첫 번째 피연산자가 skipIt이 true이므로 result 도 true입니다.&lt;br /&gt;
&lt;strong&gt;우리가 주목할 점은, 세 번째 행에서 단축 평가가 일어나므로 증가 연산자에 해당 표현식을 실행되지 않고 x의 값은 그대로 0이라는 겁니다.&lt;/strong&gt;&lt;br /&gt;
skipIt을 false로 바꾸면 논리 연산자의 두 피연산자를 모두 평가해야 하고, 따라서 x는 증가합니다.&lt;br /&gt;
여기서는 증가 연산이 &lt;strong&gt;부수 효과&lt;/strong&gt;입니다.&lt;br /&gt;
AND에서도 같은 일이 일어날 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;doIt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;doIt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;AND의 첫 번째 피연산자가 false이므로 이번에도 자바스크립트는 두 번째 피연산자를 평가하지 않습니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;따라서 result는 false이고, x는 늘어나지 않습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;doIt을 true로 바꾸면 어떻게 될까요?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;자바스크립트는 두 피연산자를 모두 평가해야 하므로 증가 연산이 일어나고, result는 0이 됩니다.&lt;/strong&gt;&lt;br /&gt;
잠깐, 뭐라구요?&lt;br /&gt;
&lt;strong&gt;result가 false가 아니라 0이라구요?&lt;/strong&gt;&lt;br /&gt;
이 질문에 대한 답이 다음 섹션의 내용입니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">AND 연산에 대한 진위표를 보면 두 값을 모두 평가하지 않아도 될 때가 있음을 알 수 잇ㅆ브니다. x가 거짓 같은 값이면 x &amp;amp;&amp;amp; y는 y의 값을 평가할 필요도 없이 false입니다. 마찬가지로 x || y 에서 x가 참 같은 값이면 y를 평가할 필요도 없이 true입니다. 자바스크립트는 정확히 이런 방식으로 동작하며, 이런 동작을 단축 평가(short-circuit evaluation) 라고 합니다. 단축 평가가 중요한 이유는 뭘까요? 두 번째 피연산자에 부수 효과(side effect) 가 있다 하더라도 단축 평가를 거치면 그 효과는 일어나지 않기 때문입니다. 부수 효과는 보통 부정적인 의미로 쓰이지만 항상 그런 건 아닙니다. 결과가 의도적이고 명확하다면 나쁘게 평가할 이유는 없습니다. 표현식에서 부수 효과는 증가, 감소, 할당, 함수 호출에서 일어날 수 있습니다. 증가와 감소 연산자는 이미 살펴봤으니 이들에 관한 예제를 봅시다. const skipIt = true; let x = 0; const result = skipIt || x++; 예제의 세 번째 행의 결과는 result에 저장됩니다. 첫 번째 피연산자가 skipIt이 true이므로 result 도 true입니다. 우리가 주목할 점은, 세 번째 행에서 단축 평가가 일어나므로 증가 연산자에 해당 표현식을 실행되지 않고 x의 값은 그대로 0이라는 겁니다. skipIt을 false로 바꾸면 논리 연산자의 두 피연산자를 모두 평가해야 하고, 따라서 x는 증가합니다. 여기서는 증가 연산이 부수 효과입니다. AND에서도 같은 일이 일어날 수 있습니다. const doIt = false; let x = 0; const result = doIt &amp;amp;&amp;amp; x++; AND의 첫 번째 피연산자가 false이므로 이번에도 자바스크립트는 두 번째 피연산자를 평가하지 않습니다. 따라서 result는 false이고, x는 늘어나지 않습니다. doIt을 true로 바꾸면 어떻게 될까요? 자바스크립트는 두 피연산자를 모두 평가해야 하므로 증가 연산이 일어나고, result는 0이 됩니다. 잠깐, 뭐라구요? result가 false가 아니라 0이라구요? 이 질문에 대한 답이 다음 섹션의 내용입니다.</summary></entry><entry><title type="html">5.8 AND, OR, NOT</title><link href="http://localhost:4000/javascript/2020/04/21/javascript88/" rel="alternate" type="text/html" title="5.8 AND, OR, NOT" /><published>2020-04-21T20:35:00+09:00</published><updated>2020-04-21T20:35:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/21/javascript88</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/21/javascript88/">&lt;p&gt;자바스크립트가 지원하는 논리 연산자는 AND(&amp;amp;&amp;amp;)와, OR(||), NOT(!) 세 가지입니다.&lt;br /&gt;
수학을 공부했다면 AND는 교집합(conjunction), OR은 합집합(disjunction), NOT은 부정(negation)으로 이해할 수 있을 겁니다.&lt;/p&gt;

&lt;p&gt;(거의) 무한한 숫자와 달리 불리언은 단 두 가지 밖에 없으므로 논리 연산은 &lt;strong&gt;진위표(truth table)&lt;/strong&gt; 로 나타낼 때가 많습니다.&lt;br /&gt;
[표 5-2]부터 [표 5-4]까지를 보십시오.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;표 5-2 AND(&amp;amp;&amp;amp;) 연산의 진위표&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;x&lt;/th&gt;
      &lt;th&gt;y&lt;/th&gt;
      &lt;th&gt;x &amp;amp;&amp;amp; y&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;false&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;false&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;true&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;true&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;표 5-3 OR(||) 연산의 진위표&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;x&lt;/th&gt;
      &lt;th&gt;y&lt;/th&gt;
      &lt;th&gt;x || y&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;false&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;false&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;true&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;true&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;표 5-4 NOT(!) 연산의 진위표&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;x&lt;/th&gt;
      &lt;th&gt;!x&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;false&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;true&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;테이블을 보면 AND 연산은 피연산자가 모두 true일 때만 true이고, OR 연산은 피연산자가 모두 false일 때만 false임을 알 수 있습니다.&lt;br /&gt;
NOT은 단순히 피연산자를 반대로 바꿉니다.&lt;/p&gt;

&lt;p&gt;피연산자가 모두 true이면 결과도 true이기 때문에 OR 연산자는 가끔 &lt;strong&gt;포괄적(inclusive)&lt;/strong&gt; OR이라 불리기도 합니다.&lt;br /&gt;
&lt;strong&gt;배타적(exclusive)&lt;/strong&gt; OR, 또는 &lt;strong&gt;XOR이라 불리는&lt;/strong&gt; OR도 있습니다.&lt;br /&gt;
&lt;strong&gt;이 연산자는 피연산자가 모두 true이면 false를 반환합니다.&lt;/strong&gt; &lt;br /&gt;
&lt;strong&gt;자바스크립트에는 XOR에 해당하는 논리 연산자가 없지만, 나중에 설명할 비트 XOR은 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;TIP&lt;/strong&gt;&lt;br /&gt;
변수 x와 y의 XOR 연산이 필요하다면 동등한 표현식&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;(x || y) &amp;amp;&amp;amp; x !== y&lt;/code&gt;&lt;br /&gt;
를 사용하면 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">자바스크립트가 지원하는 논리 연산자는 AND(&amp;amp;&amp;amp;)와, OR(||), NOT(!) 세 가지입니다. 수학을 공부했다면 AND는 교집합(conjunction), OR은 합집합(disjunction), NOT은 부정(negation)으로 이해할 수 있을 겁니다. (거의) 무한한 숫자와 달리 불리언은 단 두 가지 밖에 없으므로 논리 연산은 진위표(truth table) 로 나타낼 때가 많습니다. [표 5-2]부터 [표 5-4]까지를 보십시오. 표 5-2 AND(&amp;amp;&amp;amp;) 연산의 진위표 x y x &amp;amp;&amp;amp; y false false false false true false true false false true true true 표 5-3 OR(||) 연산의 진위표 x y x || y false false false false true true true false true true true true 표 5-4 NOT(!) 연산의 진위표 x !x false true true false 테이블을 보면 AND 연산은 피연산자가 모두 true일 때만 true이고, OR 연산은 피연산자가 모두 false일 때만 false임을 알 수 있습니다. NOT은 단순히 피연산자를 반대로 바꿉니다. 피연산자가 모두 true이면 결과도 true이기 때문에 OR 연산자는 가끔 포괄적(inclusive) OR이라 불리기도 합니다. 배타적(exclusive) OR, 또는 XOR이라 불리는 OR도 있습니다. 이 연산자는 피연산자가 모두 true이면 false를 반환합니다. 자바스크립트에는 XOR에 해당하는 논리 연산자가 없지만, 나중에 설명할 비트 XOR은 있습니다. TIP 변수 x와 y의 XOR 연산이 필요하다면 동등한 표현식 (x || y) &amp;amp;&amp;amp; x !== y 를 사용하면 됩니다.</summary></entry><entry><title type="html">5.7.1 참 같은 값과 거짓 같은 값</title><link href="http://localhost:4000/javascript/2020/04/21/javascript87/" rel="alternate" type="text/html" title="5.7.1 참 같은 값과 거짓 같은 값" /><published>2020-04-21T18:09:00+09:00</published><updated>2020-04-21T18:09:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/21/javascript87</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/21/javascript87/">&lt;p&gt;‘참 같은 값’과 ‘거짓 같은 값’이란 개념이 있는 언어도 많고, &lt;strong&gt;C 언어처럼 불리언 타입이 아예 존재하지 않는 언어&lt;/strong&gt;도 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;C 언어에서 숫자 0은 false이고다른 숫자형 값은 모두 true입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자바스크립트는 이들을 적절히 혼합한 방식을 취합니다.&lt;br /&gt;
&lt;strong&gt;자바스크립트에서는 모든 데이터 타입을 참 같은 값과 거짓 같은 값으로 나눌 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
자바스크립트에서 &lt;strong&gt;거짓 같은 값&lt;/strong&gt;은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;undefined&lt;/li&gt;
  &lt;li&gt;null&lt;/li&gt;
  &lt;li&gt;false&lt;/li&gt;
  &lt;li&gt;0&lt;/li&gt;
  &lt;li&gt;NaN&lt;/li&gt;
  &lt;li&gt;’’ (빈문자열)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이들 외에는 모두 참 같은 값입니다.&lt;br /&gt;
참 같은 값은 정말 많으므로 전부 나열할 수 없지만 몇 가지는 염두에 두어야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 객체, &lt;strong&gt;valueOf()&lt;/strong&gt; 메서드를 호출했을 때 false를 반환하는 객체도 참 같은 값에 속합니다. &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf&quot;&gt;valueOf() 설명&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;배열, 빈 배열도 참 같은 값에 속합니다.&lt;br /&gt;
&lt;strong&gt;(역주_ 빈 배열은 참 같은 값이지만, [] == false는 true입니다.)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;공백만 있는 문자열 (“ “) 등&lt;/li&gt;
  &lt;li&gt;문자열 “false”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문자열 “false”가 true라는 사실에 놀라는 사람들이 있지만, 이를 제외하면 대부분 직관적으로 이해할 수 있고 기억하기도 쉬운 편입니다.&lt;br /&gt;
한 가지 예외를 더 들자면 빈 배열이 참 같은 값이라는 사실입니다.&lt;br /&gt;
&lt;strong&gt;빈 배열 arr이 거짓 같은 값으로 평가되길 원한다면 arr.length를 쓰십시오.&lt;/strong&gt;&lt;br /&gt;
빈 배열에서 이 프로퍼티를 호출하면 0을 반환하며 이는 거짓 같은 값입니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">‘참 같은 값’과 ‘거짓 같은 값’이란 개념이 있는 언어도 많고, C 언어처럼 불리언 타입이 아예 존재하지 않는 언어도 있습니다. C 언어에서 숫자 0은 false이고다른 숫자형 값은 모두 true입니다. 자바스크립트는 이들을 적절히 혼합한 방식을 취합니다. 자바스크립트에서는 모든 데이터 타입을 참 같은 값과 거짓 같은 값으로 나눌 수 있습니다. 자바스크립트에서 거짓 같은 값은 다음과 같습니다. undefined null false 0 NaN ’’ (빈문자열) 이들 외에는 모두 참 같은 값입니다. 참 같은 값은 정말 많으므로 전부 나열할 수 없지만 몇 가지는 염두에 두어야 합니다. 모든 객체, valueOf() 메서드를 호출했을 때 false를 반환하는 객체도 참 같은 값에 속합니다. valueOf() 설명 배열, 빈 배열도 참 같은 값에 속합니다. (역주_ 빈 배열은 참 같은 값이지만, [] == false는 true입니다.) 공백만 있는 문자열 (“ “) 등 문자열 “false” 문자열 “false”가 true라는 사실에 놀라는 사람들이 있지만, 이를 제외하면 대부분 직관적으로 이해할 수 있고 기억하기도 쉬운 편입니다. 한 가지 예외를 더 들자면 빈 배열이 참 같은 값이라는 사실입니다. 빈 배열 arr이 거짓 같은 값으로 평가되길 원한다면 arr.length를 쓰십시오. 빈 배열에서 이 프로퍼티를 호출하면 0을 반환하며 이는 거짓 같은 값입니다.</summary></entry></feed>