<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-04-21T18:19:16+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">LHJ</title><subtitle>coding blog</subtitle><entry><title type="html">5.7.1 참 같은 값과 거짓 같은 값</title><link href="http://localhost:4000/javascript/2020/04/21/javascript87/" rel="alternate" type="text/html" title="5.7.1 참 같은 값과 거짓 같은 값" /><published>2020-04-21T18:09:00+09:00</published><updated>2020-04-21T18:09:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/21/javascript87</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/21/javascript87/">&lt;p&gt;‘참 같은 값’과 ‘거짓 같은 값’이란 개념이 있는 언어도 많고, &lt;strong&gt;C 언어처럼 불리언 타입이 아예 존재하지 않는 언어&lt;/strong&gt;도 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;C 언어에서 숫자 0은 false이고다른 숫자형 값은 모두 true입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자바스크립트는 이들을 적절히 혼합한 방식을 취합니다.&lt;br /&gt;
&lt;strong&gt;자바스크립트에서는 모든 데이터 타입을 참 같은 값과 거짓 같은 값으로 나눌 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
자바스크립트에서 &lt;strong&gt;거짓 같은 값&lt;/strong&gt;은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;undefined&lt;/li&gt;
  &lt;li&gt;null&lt;/li&gt;
  &lt;li&gt;false&lt;/li&gt;
  &lt;li&gt;0&lt;/li&gt;
  &lt;li&gt;NaN&lt;/li&gt;
  &lt;li&gt;’’ (빈문자열)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이들 외에는 모두 참 같은 값입니다.&lt;br /&gt;
참 같은 값은 정말 많으므로 전부 나열할 수 없지만 몇 가지는 염두에 두어야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 객체, &lt;strong&gt;valueOf()&lt;/strong&gt; 메서드를 호출했을 때 false를 반환하는 객체도 참 같은 값에 속합니다. &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf&quot;&gt;valueOf() 설명&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;배열, 빈 배열도 참 같은 값에 속합니다.&lt;/li&gt;
  &lt;li&gt;공백만 있는 문자열 (“ “) 등&lt;/li&gt;
  &lt;li&gt;문자열 “false”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문자열 “false”가 true라는 사실에 놀라는 사람들이 있지만, 이를 제외하면 대부분 직관적으로 이해할 수 있고 기억하기도 쉬운 편입니다.&lt;br /&gt;
한 가지 예외를 더 들자면 빈 배열이 참 같은 값이라는 사실입니다.&lt;br /&gt;
&lt;strong&gt;빈 배열 arr이 거짓 같은 값으로 평가되길 원한다면 arr.length를 쓰십시오.&lt;/strong&gt;&lt;br /&gt;
빈 배열에서 이 프로퍼티를 호출하면 0을 반환하며 이는 거짓 같은 값입니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">‘참 같은 값’과 ‘거짓 같은 값’이란 개념이 있는 언어도 많고, C 언어처럼 불리언 타입이 아예 존재하지 않는 언어도 있습니다. C 언어에서 숫자 0은 false이고다른 숫자형 값은 모두 true입니다. 자바스크립트는 이들을 적절히 혼합한 방식을 취합니다. 자바스크립트에서는 모든 데이터 타입을 참 같은 값과 거짓 같은 값으로 나눌 수 있습니다. 자바스크립트에서 거짓 같은 값은 다음과 같습니다. undefined null false 0 NaN ’’ (빈문자열) 이들 외에는 모두 참 같은 값입니다. 참 같은 값은 정말 많으므로 전부 나열할 수 없지만 몇 가지는 염두에 두어야 합니다. 모든 객체, valueOf() 메서드를 호출했을 때 false를 반환하는 객체도 참 같은 값에 속합니다. valueOf() 설명 배열, 빈 배열도 참 같은 값에 속합니다. 공백만 있는 문자열 (“ “) 등 문자열 “false” 문자열 “false”가 true라는 사실에 놀라는 사람들이 있지만, 이를 제외하면 대부분 직관적으로 이해할 수 있고 기억하기도 쉬운 편입니다. 한 가지 예외를 더 들자면 빈 배열이 참 같은 값이라는 사실입니다. 빈 배열 arr이 거짓 같은 값으로 평가되길 원한다면 arr.length를 쓰십시오. 빈 배열에서 이 프로퍼티를 호출하면 0을 반환하며 이는 거짓 같은 값입니다.</summary></entry><entry><title type="html">5.7 논리 연산자</title><link href="http://localhost:4000/javascript/2020/04/21/javascript86/" rel="alternate" type="text/html" title="5.7 논리 연산자" /><published>2020-04-21T18:02:00+09:00</published><updated>2020-04-21T18:02:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/21/javascript86</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/21/javascript86/">&lt;p&gt;우리가 익숙한 산술 연산자는 무한히 많은(컴퓨터의 메모리는 유한하므로 정확히 말한다면 아주 많은) 숫자를 다룰 수 있지만, &lt;strong&gt;논리 연산자는 불리언 값만 다룰 수 있으며 불리언에는 false와 true 두 가지 값밖에 없습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;수학에서, 그리고 대부분의 프로그래밍 언어에서 논리 연산자는 불리언 값에서만 동작하며 불리언 값만 반환&lt;/strong&gt;합니다.&lt;br /&gt;
&lt;strong&gt;반면 자바스크립트의 논리 연산자는 불리언이 아닌 값도 다룰 수 있고, 놀랍게도 불리언이 아닌 값을 반환하기도 합니다.&lt;/strong&gt;&lt;br /&gt;
자바스크립트의 논리 연산자가 잘못 만들어져 있거나 엉성한 것은 아닙니다.&lt;br /&gt;
논리 연산자를 불리언 값에 사용하면 결과는 불리언 값뿐입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;연산자에 대해 설명하기 전에 자바스크립트가 불리언이 아닌 값을 불리언 값으로 바꾸는 방법에 익숙해져야 합니다.&lt;/strong&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">우리가 익숙한 산술 연산자는 무한히 많은(컴퓨터의 메모리는 유한하므로 정확히 말한다면 아주 많은) 숫자를 다룰 수 있지만, 논리 연산자는 불리언 값만 다룰 수 있으며 불리언에는 false와 true 두 가지 값밖에 없습니다. 수학에서, 그리고 대부분의 프로그래밍 언어에서 논리 연산자는 불리언 값에서만 동작하며 불리언 값만 반환합니다. 반면 자바스크립트의 논리 연산자는 불리언이 아닌 값도 다룰 수 있고, 놀랍게도 불리언이 아닌 값을 반환하기도 합니다. 자바스크립트의 논리 연산자가 잘못 만들어져 있거나 엉성한 것은 아닙니다. 논리 연산자를 불리언 값에 사용하면 결과는 불리언 값뿐입니다. 연산자에 대해 설명하기 전에 자바스크립트가 불리언이 아닌 값을 불리언 값으로 바꾸는 방법에 익숙해져야 합니다.</summary></entry><entry><title type="html">5.6 문자열 병합</title><link href="http://localhost:4000/javascript/2020/04/21/javascript85/" rel="alternate" type="text/html" title="5.6 문자열 병합" /><published>2020-04-21T17:54:00+09:00</published><updated>2020-04-21T17:54:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/21/javascript85</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/21/javascript85/">&lt;p&gt;&lt;strong&gt;자바스크립트에서 + 연산자는 덧셈과 문자열 병합에 모두 사용됩니다&lt;/strong&gt;(이렇게 하는 언어가 매우 많습니다. 펄과 PHP는 문자열 병합을 병합할 때 + 연산자를 &lt;strong&gt;쓰지 않는&lt;/strong&gt; 몇 안되는 언어입니다).&lt;/p&gt;

&lt;p&gt;자바스크립트는 피연산자의 타입을 보고 덧셈을 할지 문자열 병합을 할지 판단합니다.&lt;br /&gt;
&lt;strong&gt;덧셈과 병합은 모두 왼쪽에서 오른쪽으로 평가&lt;/strong&gt;합니다.&lt;br /&gt;
자바스크립트는 두 피연산자를 왼쪽에서 오른쪽으로 평가한 후, 피연산자 중 하나라도 문자열이면 문자열 병합을 수행합니다.&lt;br /&gt;
두 값이 모두 숫자형이면 덧셈을 합니다.&lt;br /&gt;
다음 두 행을 보십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 문자열 &quot;88&quot;이 됩니다.&lt;/span&gt;
&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 문자열 &quot;358&quot;이 됩니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;첫 행에서 자바스크립트는 먼저 3 + 5가 덧셈이라고 판단합니다.&lt;br /&gt;
그 다음에는 8 + “8”을 문자열 병합이라고 판단합니다.&lt;br /&gt;
두 번째 행에서는 먼저 “3” + 5 를 병합이라고 판단하고,&lt;br /&gt;
“35” + 8 역시 병합이라고 판단합니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">자바스크립트에서 + 연산자는 덧셈과 문자열 병합에 모두 사용됩니다(이렇게 하는 언어가 매우 많습니다. 펄과 PHP는 문자열 병합을 병합할 때 + 연산자를 쓰지 않는 몇 안되는 언어입니다). 자바스크립트는 피연산자의 타입을 보고 덧셈을 할지 문자열 병합을 할지 판단합니다. 덧셈과 병합은 모두 왼쪽에서 오른쪽으로 평가합니다. 자바스크립트는 두 피연산자를 왼쪽에서 오른쪽으로 평가한 후, 피연산자 중 하나라도 문자열이면 문자열 병합을 수행합니다. 두 값이 모두 숫자형이면 덧셈을 합니다. 다음 두 행을 보십시오. 3 + 5 + &quot;8&quot; // 문자열 &quot;88&quot;이 됩니다. &quot;3&quot; + 5 + 8 // 문자열 &quot;358&quot;이 됩니다. 첫 행에서 자바스크립트는 먼저 3 + 5가 덧셈이라고 판단합니다. 그 다음에는 8 + “8”을 문자열 병합이라고 판단합니다. 두 번째 행에서는 먼저 “3” + 5 를 병합이라고 판단하고, “35” + 8 역시 병합이라고 판단합니다.</summary></entry><entry><title type="html">5.5 숫자비교</title><link href="http://localhost:4000/javascript/2020/04/21/javascript84/" rel="alternate" type="text/html" title="5.5 숫자비교" /><published>2020-04-21T17:09:00+09:00</published><updated>2020-04-21T17:09:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/21/javascript84</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/21/javascript84/">&lt;p&gt;숫자를 비교할 때는 염두에 두어야 할 것이 있습니다.&lt;/p&gt;

&lt;p&gt;먼저, 특별한 숫자형 값 NaN은 그 자신을 포함하여 무엇과도 같지 않습니다.&lt;br /&gt;
즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;NaN === NaN&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;NaN == NaN&lt;/code&gt;은 모두 &lt;strong&gt;false&lt;/strong&gt;입니다.&lt;br /&gt;
숫자가 NaN인지 알아보려면 내장된 &lt;strong&gt;isNaN&lt;/strong&gt; 함수를 사용하십시오.&lt;br /&gt;
&lt;strong&gt;isNaN(x)&lt;/strong&gt; 은 x가 NaN일 때 true를 반환하고 그렇지 않다면 false를 반환합니다.&lt;/p&gt;

&lt;p&gt;자주 얘기하지만, 자바스크립트의 숫자는 모두 &lt;strong&gt;더블 형식&lt;/strong&gt;입니다.&lt;br /&gt;
&lt;strong&gt;그리고 더블 형식은 근사치이므로, 자바스크립트에서 숫자를 비교하다 보면 경악스러운 결과를 볼 때가 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;자바스크립트에서 정수를 비교할 때, 그 정수가 안전한 범위라면(&lt;strong&gt;Number.MIN_SAFE_INTEGER 이상, Number.MAX_SAFE_INTEGER 이하)&lt;/strong&gt; 안심하고 일치 연산자를 사용할 수 있습니다.&lt;br /&gt;
&lt;strong&gt;하지만 소수점이 있는 숫자를 비교할 때&lt;/strong&gt;는 &lt;strong&gt;관계 연산자를 써서 테스트하는 숫자가 대상 숫자에 ‘충분히 가까운지’ 확인&lt;/strong&gt;하는 편이 좋습니다.&lt;br /&gt;
충분히 가깝다는 게 무슨 말이냐고요?&lt;br /&gt;
때에 따라 다릅니다.&lt;br /&gt;
자바스크립트에는 특별히 숫자형 상수 &lt;strong&gt;Number.EPSILOW&lt;/strong&gt;이 있습니다.&lt;br /&gt;
이것은 매우 작은 값(약 2.22e-16)이며, 일반적으로 숫자 두 개를 구별하는 기준으로 사용합니다.&lt;br /&gt;
다음 예제를 보십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`Stopped at &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드를 실행하면 예상 외의 결과에 놀랄 겁니다.&lt;br /&gt;
&lt;strong&gt;이 루프는 0.3에서 멈추지 않고 그 값을 살짝 피한 다음 영원히 실행됩니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;이 결과는 0.1이 더블 형식으로 저확히 나타낼 수 없는 값이기 때문입니다.&lt;/strong&gt;&lt;br /&gt;
0.1은 이진 표현으로나타낼 수 있는 숫자들 사이에 걸쳐 있습니다.&lt;br /&gt;
따라서 이 루프를 세 번째 반복할 때 n의 값은 &lt;strong&gt;0.30000000000000004&lt;/strong&gt;이므로 테스트는 false이고, 유일한 종료 조건이 실패하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Number.EPSILON&lt;/strong&gt;과 관계 연산자를 사용해서 ‘느슨하게’ 비교하고 성공적으로 루프를 빠져나갈 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;EPSILON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`Stopped at &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image39.jpg&quot; alt=&quot;더블형식&quot; /&gt;&lt;/p&gt;

&lt;p&gt;테스트하는 숫자(n)에서 비교 대상(0.3)을 뺀 다음 절댓값을 취하는 방식을 썼습니다(Math.abs는 16장에서 설명합니다).&lt;br /&gt;
그냥 n이 0.3보다 큰지 확인하는 간단한 방법도 있지만, 여기서 사용한 방법은 두 개의 더블 형식이 같다고 할 수 있을 만큼 가까운 숫자인지 판단할 때 일반적으로 사용하는 방법입니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">숫자를 비교할 때는 염두에 두어야 할 것이 있습니다. 먼저, 특별한 숫자형 값 NaN은 그 자신을 포함하여 무엇과도 같지 않습니다. 즉, NaN === NaN과 NaN == NaN은 모두 false입니다. 숫자가 NaN인지 알아보려면 내장된 isNaN 함수를 사용하십시오. isNaN(x) 은 x가 NaN일 때 true를 반환하고 그렇지 않다면 false를 반환합니다. 자주 얘기하지만, 자바스크립트의 숫자는 모두 더블 형식입니다. 그리고 더블 형식은 근사치이므로, 자바스크립트에서 숫자를 비교하다 보면 경악스러운 결과를 볼 때가 있습니다. 자바스크립트에서 정수를 비교할 때, 그 정수가 안전한 범위라면(Number.MIN_SAFE_INTEGER 이상, Number.MAX_SAFE_INTEGER 이하) 안심하고 일치 연산자를 사용할 수 있습니다. 하지만 소수점이 있는 숫자를 비교할 때는 관계 연산자를 써서 테스트하는 숫자가 대상 숫자에 ‘충분히 가까운지’ 확인하는 편이 좋습니다. 충분히 가깝다는 게 무슨 말이냐고요? 때에 따라 다릅니다. 자바스크립트에는 특별히 숫자형 상수 Number.EPSILOW이 있습니다. 이것은 매우 작은 값(약 2.22e-16)이며, 일반적으로 숫자 두 개를 구별하는 기준으로 사용합니다. 다음 예제를 보십시오. let n = 0; while(true) { n += 0.1; if (n === 0.3) break; } console.log(`Stopped at ${n}`); 이 코드를 실행하면 예상 외의 결과에 놀랄 겁니다. 이 루프는 0.3에서 멈추지 않고 그 값을 살짝 피한 다음 영원히 실행됩니다. 이 결과는 0.1이 더블 형식으로 저확히 나타낼 수 없는 값이기 때문입니다. 0.1은 이진 표현으로나타낼 수 있는 숫자들 사이에 걸쳐 있습니다. 따라서 이 루프를 세 번째 반복할 때 n의 값은 0.30000000000000004이므로 테스트는 false이고, 유일한 종료 조건이 실패하게 됩니다. Number.EPSILON과 관계 연산자를 사용해서 ‘느슨하게’ 비교하고 성공적으로 루프를 빠져나갈 수 있습니다. let n = 0; while(true) { n += 0.1; if (Math.abs(n - 0.3) &amp;lt; Number.EPSILON) break; } console.log(`Stopped at ${n}`); 테스트하는 숫자(n)에서 비교 대상(0.3)을 뺀 다음 절댓값을 취하는 방식을 썼습니다(Math.abs는 16장에서 설명합니다). 그냥 n이 0.3보다 큰지 확인하는 간단한 방법도 있지만, 여기서 사용한 방법은 두 개의 더블 형식이 같다고 할 수 있을 만큼 가까운 숫자인지 판단할 때 일반적으로 사용하는 방법입니다.</summary></entry><entry><title type="html">5.4 비교 연산자</title><link href="http://localhost:4000/javascript/2020/04/21/javascript83/" rel="alternate" type="text/html" title="5.4 비교 연산자" /><published>2020-04-21T00:41:39+09:00</published><updated>2020-04-21T00:41:39+09:00</updated><id>http://localhost:4000/javascript/2020/04/21/javascript83</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/21/javascript83/">&lt;p&gt;비교 연산자는 이름처럼 두 개의 값을 비교합니다.&lt;br /&gt;
크게 말해 비교 연산자는 &lt;strong&gt;일치함(strict equality(===), 동등함(loose equality(==)), 대소 관계&lt;/strong&gt;의 세 가지 타입으로 나뉩니다(불일치는 일치의 한 종류라고 보기 때문에 다른 타입으로 나누지는 않습니다).&lt;/p&gt;

&lt;p&gt;초보자들은 &lt;strong&gt;일치&lt;/strong&gt;와 &lt;strong&gt;동등&lt;/strong&gt;의 차이를 이해하지 못하는 경우가 많습니다.&lt;br /&gt;
먼저 일치에 대해 이해해보기로 합시다.&lt;br /&gt;
&lt;strong&gt;두 값이 같은 객체를 가리키거나, 같은 타입이고 값도 같다면(원시 타입) 이 값을 일치한다고 합니다.&lt;/strong&gt;&lt;br /&gt;
일치 관계는 아주 단순하고 이해하기 쉬우므로 버그나 오해를 낳는 경우가 거의 없습니다.&lt;br /&gt;
&lt;strong&gt;두 값이 일치하는지 확인할 때는 === 연산자를 쓰거나 그 반대인 !== 연산자를 씁니다.&lt;/strong&gt;&lt;br /&gt;
예제를 살펴보기 전에 먼저 동등 관계를 알아봅시다.&lt;/p&gt;

&lt;p&gt;한편, 두 값이 같은 객체를 가리키거나 &lt;strong&gt;같은 값을 갖도록 변환할 수 있다면&lt;/strong&gt; 두 값을 동등하다고 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;역주_&lt;/strong&gt; 두 값이 같은 객체를 가리킬 때 일치한다고도 하고 동등하다고도 했는데, 좀 이상하게 읽힐 수도 있지만 저자의 설명이 틀린 것은 아닙니다.&lt;br /&gt;
두 값이 일치하면 당연히 두 값은 동등하기도 합니다.&lt;br /&gt;
예를 들어 2 === 2는 true이고 2 == 2도 true입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞 부분은 괜찮지만, 두 번째 부분은 수 많은 골칫거리와 혼란을 발생시켰습니다.&lt;br /&gt;
이따금은 편리할 때도 있습니다.&lt;br /&gt;
&lt;strong&gt;문자열 “33”은 숫자 33으로 변환할 수 있으므로 이 둘은 동등합니다.&lt;/strong&gt;&lt;br /&gt;
하지만 타입이 다르므로 일치하지는 않습니다.&lt;br /&gt;
동등 비교가 편리할 때도 있지만, 이런 편리함 때문에 수많은 부작용이 생길 수 있습니다.&lt;br /&gt;
따라서 문자열은 미리 숫자로 변환해서 일치하는지 비교하길 권합니다.&lt;br /&gt;
&lt;strong&gt;동등한지 아닌지 비교할 때는 == 연산자나 != 연산자를 사용합니다.&lt;/strong&gt;&lt;br /&gt;
동등 연산자 때문에 생기는 문제와 함정을 자세히 알고 싶다면 더글러스 크록포드의 &lt;strong&gt;자바스크립트 핵심 가이드(한빛미디어, 2008)&lt;/strong&gt; 를 권합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;TIP&lt;/strong&gt;&lt;br /&gt;
동등 연산자 때문에 문제가 생기는 경우는 대개 &lt;strong&gt;null과 undefined, 빈 문자열, 숫자 0&lt;/strong&gt; 때문입니다.&lt;br /&gt;
위 네 가지 경우에 해당하지 않는 값을 비교한다면 동등 연산자를 써도 안전할 때가 많습니다.&lt;br /&gt;
하지만 기계적으로 동등 연산자를 쓰는 습관은 빨리 버릴수록 좋습니다.&lt;br /&gt;
필자가 권하는 대로 일치 연산자만 사용한다면 &lt;strong&gt;이런 문제에 대해 생각할 필요도 없습니다.&lt;/strong&gt;&lt;br /&gt;
동등 연산자를 써도 안전한지, 아니면 (미세한) 이득이 있는지 생각하느라 중요한 흐름을 방해받지 않아도 됩니다.&lt;br /&gt;
그냥 일치 연산자를 사용하고 계속 진행하면 됩니다.&lt;br /&gt;
일치 연산자를 사용했을 때 원하는 결과가 나오지 않으면, &lt;strong&gt;말썽꾸러기인 동등 연산자로 바꾸지 말고 그냥 데이터 타입을 변환하면 됩니다.&lt;/strong&gt;&lt;br /&gt;
프로그래밍은 그 자체로도 충분히 힘든 작업입니다.&lt;br /&gt;
동등 연산자를 써서 불필요한 문제를 초래하지 마십시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다음은 일치 연산자와 동등 연산자의 예입니다.&lt;br /&gt;
객체 a와 b에 같은 정보가 들어 있더라도 그들은 &lt;strong&gt;서로 다른 객체&lt;/strong&gt;이며, 일치하지도 않고 동등하지도 않습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//false -- 타입이 다릅니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// true -- 문자열 &quot;5&quot;를 숫자 5로 변환했습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// false&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// true; 권장하지 않습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// false; 권장하지 않습니다.&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;an object&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;an object&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// false -- 객체는 항상 다릅니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// false; 권장하지 않습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true; 권장하지 않습니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;관계 연산자는 &lt;strong&gt;관계가 있는 값&lt;/strong&gt;을 비교하며, 문자열이나 숫자처럼 원래 순서가 있는 데이터 타입에만 사용할 수 있습니다(‘a’는 항상 ‘b’보다 앞에 있습니다).&lt;/p&gt;

&lt;p&gt;관계 연산자에는 작다(&amp;lt;), 작거나 같다(&amp;lt;=), 크다(&amp;gt;), 크거나 같다(&amp;gt;=) 네 가지가 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// false&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// false&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;

&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// false&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// false&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">비교 연산자는 이름처럼 두 개의 값을 비교합니다. 크게 말해 비교 연산자는 일치함(strict equality(===), 동등함(loose equality(==)), 대소 관계의 세 가지 타입으로 나뉩니다(불일치는 일치의 한 종류라고 보기 때문에 다른 타입으로 나누지는 않습니다). 초보자들은 일치와 동등의 차이를 이해하지 못하는 경우가 많습니다. 먼저 일치에 대해 이해해보기로 합시다. 두 값이 같은 객체를 가리키거나, 같은 타입이고 값도 같다면(원시 타입) 이 값을 일치한다고 합니다. 일치 관계는 아주 단순하고 이해하기 쉬우므로 버그나 오해를 낳는 경우가 거의 없습니다. 두 값이 일치하는지 확인할 때는 === 연산자를 쓰거나 그 반대인 !== 연산자를 씁니다. 예제를 살펴보기 전에 먼저 동등 관계를 알아봅시다. 한편, 두 값이 같은 객체를 가리키거나 같은 값을 갖도록 변환할 수 있다면 두 값을 동등하다고 합니다. 역주_ 두 값이 같은 객체를 가리킬 때 일치한다고도 하고 동등하다고도 했는데, 좀 이상하게 읽힐 수도 있지만 저자의 설명이 틀린 것은 아닙니다. 두 값이 일치하면 당연히 두 값은 동등하기도 합니다. 예를 들어 2 === 2는 true이고 2 == 2도 true입니다. 앞 부분은 괜찮지만, 두 번째 부분은 수 많은 골칫거리와 혼란을 발생시켰습니다. 이따금은 편리할 때도 있습니다. 문자열 “33”은 숫자 33으로 변환할 수 있으므로 이 둘은 동등합니다. 하지만 타입이 다르므로 일치하지는 않습니다. 동등 비교가 편리할 때도 있지만, 이런 편리함 때문에 수많은 부작용이 생길 수 있습니다. 따라서 문자열은 미리 숫자로 변환해서 일치하는지 비교하길 권합니다. 동등한지 아닌지 비교할 때는 == 연산자나 != 연산자를 사용합니다. 동등 연산자 때문에 생기는 문제와 함정을 자세히 알고 싶다면 더글러스 크록포드의 자바스크립트 핵심 가이드(한빛미디어, 2008) 를 권합니다. TIP 동등 연산자 때문에 문제가 생기는 경우는 대개 null과 undefined, 빈 문자열, 숫자 0 때문입니다. 위 네 가지 경우에 해당하지 않는 값을 비교한다면 동등 연산자를 써도 안전할 때가 많습니다. 하지만 기계적으로 동등 연산자를 쓰는 습관은 빨리 버릴수록 좋습니다. 필자가 권하는 대로 일치 연산자만 사용한다면 이런 문제에 대해 생각할 필요도 없습니다. 동등 연산자를 써도 안전한지, 아니면 (미세한) 이득이 있는지 생각하느라 중요한 흐름을 방해받지 않아도 됩니다. 그냥 일치 연산자를 사용하고 계속 진행하면 됩니다. 일치 연산자를 사용했을 때 원하는 결과가 나오지 않으면, 말썽꾸러기인 동등 연산자로 바꾸지 말고 그냥 데이터 타입을 변환하면 됩니다. 프로그래밍은 그 자체로도 충분히 힘든 작업입니다. 동등 연산자를 써서 불필요한 문제를 초래하지 마십시오. 다음은 일치 연산자와 동등 연산자의 예입니다. 객체 a와 b에 같은 정보가 들어 있더라도 그들은 서로 다른 객체이며, 일치하지도 않고 동등하지도 않습니다. const n = 5; const s = &quot;5&quot;; n === s; //false -- 타입이 다릅니다. n !== s; // true n === Number(s); // true -- 문자열 &quot;5&quot;를 숫자 5로 변환했습니다. n !== Number(s); // false n == s; // true; 권장하지 않습니다. n != s; // false; 권장하지 않습니다. const a = { name: &quot;an object&quot; }; const b = { name: &quot;an object&quot; }; a === b; // false -- 객체는 항상 다릅니다. a !== b; // true a == b; // false; 권장하지 않습니다. a != b; // true; 권장하지 않습니다. 관계 연산자는 관계가 있는 값을 비교하며, 문자열이나 숫자처럼 원래 순서가 있는 데이터 타입에만 사용할 수 있습니다(‘a’는 항상 ‘b’보다 앞에 있습니다). 관계 연산자에는 작다(&amp;lt;), 작거나 같다(&amp;lt;=), 크다(&amp;gt;), 크거나 같다(&amp;gt;=) 네 가지가 있습니다. 3 &amp;gt; 5; // false 3 &amp;gt;= 5; // false 3 &amp;lt; 5; // true 3 &amp;lt;= 5; // true 5 &amp;gt; 5; // false 5 &amp;gt;= 5; // true 5 &amp;lt; 5; // false 5 &amp;lt;= 5; //true</summary></entry><entry><title type="html">5.3 연산자 우선순위</title><link href="http://localhost:4000/javascript/2020/04/21/javascript82/" rel="alternate" type="text/html" title="5.3 연산자 우선순위" /><published>2020-04-21T00:27:00+09:00</published><updated>2020-04-21T00:27:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/21/javascript82</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/21/javascript82/">&lt;p&gt;모든 표현식은 값이 된다는 걸 이해했으면, 그 다음은 연산자 우선순위를 이해해야 합니다.&lt;br /&gt;
연산자 우선순위를 이해해야 자바스크립트 프로그램이 어떻게 동작하는지 이해할 수 있습니다.&lt;/p&gt;

&lt;p&gt;산술 연산자를 설명했으니 자바스크립트의 여러 연산자에 대한 설명을 잠시 멈추고 연산자 우선순위에 대해 생각해 봅시다.&lt;br /&gt;
초등 교육을 받았다면 연산자 우선순위에 대해 배웠을 겁니다.&lt;/p&gt;

&lt;p&gt;다음 문제는 어렵지 않게 풀 수 있을 겁니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;25라고 답했으면 연산자 우선순위를 정확히 적용한 겁니다.&lt;br /&gt;
괄호가 제일 먼저고, 그 다음에 곱셈과 나눗셈을 하고, 마지막으로 덧셈과 뺄셈을 합니다.&lt;/p&gt;

&lt;p&gt;자바스크립트는 표현식을 평가할 때도 비슷한 규칙을 적용합니다.&lt;br /&gt;
산수에만 쓰는 것은 아닙니다.&lt;br /&gt;
자바스크립트에서 표현식을 평가하는 순서도 초등학교에서 배웠던 것과 같습니다.&lt;/p&gt;

&lt;p&gt;물론 자바스크립트에는 연산자가 훨씬 더 많으니 기억할 것이 늘어나기는 합니다.&lt;br /&gt;
다행히, 산수와 마찬가지로 괄호가 최우선입니다.&lt;br /&gt;
표현식 순서가 잘 기억나지 않으면, 가장 먼저 이루어져야 하는 순서대로 괄호를 쓰면 그대로 이루어질 겁니다.&lt;/p&gt;

&lt;p&gt;현재 자바스크립트에는 &lt;strong&gt;56개&lt;/strong&gt;의 연산자가 있고, 우선순위를 기준으로 &lt;strong&gt;19개&lt;/strong&gt;의 그룹으로 묶을 수 있습니다.&lt;br /&gt;
연산자의 우선순위가 높을수록 먼저 실행됩니다.&lt;br /&gt;
부록 B에 연산자 우선순위 테이블이 있습니다.&lt;br /&gt;
필자는 이 테이블을 몇 해에 걸쳐 자연스럽게 기억하게 됐지만, 여전히 가끔 찾아보면서 기억을 되살리기도 하고, 새로운 기능을 배우게 되면 어떤 우선순위가 적용되는지 찾아보기도 합니다.&lt;/p&gt;

&lt;p&gt;우선순위가 같은 연산자들은 &lt;strong&gt;오른쪽에서 왼쪽으로&lt;/strong&gt; 또는 &lt;strong&gt;왼쪽에서 오른쪽으로&lt;/strong&gt; 평가합니다.&lt;br /&gt;
예를 들어 곱셈과 나눗셈의 우선순위는 둘 다 14이고, 이들은 왼쪽에서 오른쪽으로 평가합니다.&lt;br /&gt;
곱셈과 나눗셈이 끝나면 우선순위가 3인 할당 연산자를, 오른쪽에서 왼쪽으로 평가하는 식입니다.&lt;br /&gt;
이 내용을 염두에 두고 다음 예제의 순서를 생각해 봅시다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 이 표현식을 우선순위에 따라 다음에 일어날 행동에 괄호를 치겠습니다.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 곱셈과 나눗셈, 우선순위 14, 왼쪽에서 오른쪽으로&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// x += y = (6*5)/2&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// x += y = (30)/2&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// x += y = 15&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 할당, 우선순위 3, 오른쪽에서 왼쪽으로&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// x += (y = 15)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// x += 15    y는 이제 15입니다.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 18    x는 이제 18입니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;연산자 우선순위를 이해하는 게 처음에는 벅차 보이겠지만, 곧 숨을 쉬듯 자연스러워질 겁니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">모든 표현식은 값이 된다는 걸 이해했으면, 그 다음은 연산자 우선순위를 이해해야 합니다. 연산자 우선순위를 이해해야 자바스크립트 프로그램이 어떻게 동작하는지 이해할 수 있습니다. 산술 연산자를 설명했으니 자바스크립트의 여러 연산자에 대한 설명을 잠시 멈추고 연산자 우선순위에 대해 생각해 봅시다. 초등 교육을 받았다면 연산자 우선순위에 대해 배웠을 겁니다. 다음 문제는 어렵지 않게 풀 수 있을 겁니다. 8 / 2 + 3 x (4 x 2 - 1) 25라고 답했으면 연산자 우선순위를 정확히 적용한 겁니다. 괄호가 제일 먼저고, 그 다음에 곱셈과 나눗셈을 하고, 마지막으로 덧셈과 뺄셈을 합니다. 자바스크립트는 표현식을 평가할 때도 비슷한 규칙을 적용합니다. 산수에만 쓰는 것은 아닙니다. 자바스크립트에서 표현식을 평가하는 순서도 초등학교에서 배웠던 것과 같습니다. 물론 자바스크립트에는 연산자가 훨씬 더 많으니 기억할 것이 늘어나기는 합니다. 다행히, 산수와 마찬가지로 괄호가 최우선입니다. 표현식 순서가 잘 기억나지 않으면, 가장 먼저 이루어져야 하는 순서대로 괄호를 쓰면 그대로 이루어질 겁니다. 현재 자바스크립트에는 56개의 연산자가 있고, 우선순위를 기준으로 19개의 그룹으로 묶을 수 있습니다. 연산자의 우선순위가 높을수록 먼저 실행됩니다. 부록 B에 연산자 우선순위 테이블이 있습니다. 필자는 이 테이블을 몇 해에 걸쳐 자연스럽게 기억하게 됐지만, 여전히 가끔 찾아보면서 기억을 되살리기도 하고, 새로운 기능을 배우게 되면 어떤 우선순위가 적용되는지 찾아보기도 합니다. 우선순위가 같은 연산자들은 오른쪽에서 왼쪽으로 또는 왼쪽에서 오른쪽으로 평가합니다. 예를 들어 곱셈과 나눗셈의 우선순위는 둘 다 14이고, 이들은 왼쪽에서 오른쪽으로 평가합니다. 곱셈과 나눗셈이 끝나면 우선순위가 3인 할당 연산자를, 오른쪽에서 왼쪽으로 평가하는 식입니다. 이 내용을 염두에 두고 다음 예제의 순서를 생각해 봅시다. let x = 3, y; x += y = 6*5/2; // 이 표현식을 우선순위에 따라 다음에 일어날 행동에 괄호를 치겠습니다. // // 곱셈과 나눗셈, 우선순위 14, 왼쪽에서 오른쪽으로 // x += y = (6*5)/2 // x += y = (30)/2 // x += y = 15 // 할당, 우선순위 3, 오른쪽에서 왼쪽으로 // x += (y = 15) // x += 15 y는 이제 15입니다. // 18 x는 이제 18입니다. 연산자 우선순위를 이해하는 게 처음에는 벅차 보이겠지만, 곧 숨을 쉬듯 자연스러워질 겁니다.</summary></entry><entry><title type="html">5.2 산술 연산자</title><link href="http://localhost:4000/javascript/2020/04/20/javascript81/" rel="alternate" type="text/html" title="5.2 산술 연산자" /><published>2020-04-20T22:21:00+09:00</published><updated>2020-04-20T22:21:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/20/javascript81</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/20/javascript81/">&lt;p&gt;[표 5-1]은 자바스크립트의 산술 연산자입니다.&lt;br /&gt;
&lt;strong&gt;표 5-1 산술 연산자&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;연산자&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
      &lt;th&gt;예제&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;덧셈(문자열 병합에도 쓰입니다.)&lt;/td&gt;
      &lt;td&gt;3 + 2 // 5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;뺄셈&lt;/td&gt;
      &lt;td&gt;3 - 2 // 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/&lt;/td&gt;
      &lt;td&gt;나눗셈&lt;/td&gt;
      &lt;td&gt;3/2 // 1.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;*&lt;/td&gt;
      &lt;td&gt;곱셈&lt;/td&gt;
      &lt;td&gt;3 * 2 // 6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;%&lt;/td&gt;
      &lt;td&gt;나머지&lt;/td&gt;
      &lt;td&gt;3 % 2 // 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;단항 부정&lt;/td&gt;
      &lt;td&gt;-x // x의 부호를 바꿉니다. x가 50이면 -x는 -5입니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;단항 플러스&lt;/td&gt;
      &lt;td&gt;+x // x가 숫자가 아니면 &lt;strong&gt;숫자로 변환을 시도&lt;/strong&gt;합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;++&lt;/td&gt;
      &lt;td&gt;전위 증가&lt;/td&gt;
      &lt;td&gt;++x // &lt;strong&gt;x에 1을 더한 다음 평가&lt;/strong&gt;합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;++&lt;/td&gt;
      &lt;td&gt;후위 증가&lt;/td&gt;
      &lt;td&gt;x++ // &lt;strong&gt;x를 평가한 다음 1을 더합&lt;/strong&gt;니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–&lt;/td&gt;
      &lt;td&gt;전위 감소&lt;/td&gt;
      &lt;td&gt;–x // &lt;strong&gt;x에서 1을 뺀 다음 평가&lt;/strong&gt;합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–&lt;/td&gt;
      &lt;td&gt;후위 감소&lt;/td&gt;
      &lt;td&gt;x– // &lt;strong&gt;x의 값을 평가한 다음 1을 뺍니다.&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;자바스크립트의-숫자는-모두-더블-형식&quot;&gt;자바스크립트의 숫자는 모두 더블 형식&lt;/h2&gt;

&lt;p&gt;자바스크립트의 숫자는 모두 &lt;strong&gt;더블 형식&lt;/strong&gt;이므로 3/2처럼 정수를 연산한 결과도 더블 형식입니다.&lt;/p&gt;

&lt;h2 id=&quot;단항부정과-단항플러스&quot;&gt;단항부정과 단항플러스&lt;/h2&gt;

&lt;p&gt;뺄셈과 단항 부정은 모두 - 기호를 사용합니다.&lt;br /&gt;
그러면 자바스크립트는 둘을 어떻게 구별할까요?&lt;br /&gt;
답은 매우 복잡하고, 이 책에서 다룰 만한 내용은 아닙니다.&lt;br /&gt;
&lt;strong&gt;우리가 알아야 할 것은 단항 부정이 먼저 이루어지고 그 다음에 뺄셈을 한다는 겁니다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// y는 8입니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;같은 규칙이 단항 플러스에도 적용됩니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;단항 플러스 연산자는 자주 사용하는 연산자는 아닙니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;보통 이 연산자를 사용한다면 문자열을 숫자로 강제 변환하는 경우이며, 드물게는 세로로 줄을 맞추고 싶을 때 사용합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// y는 8입니다. 단항 플러스를 사용하지 않았다면&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 문자열 병합이 일어나서 결과는 &quot;35&quot;가 됩니다.&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 여기서는 굳이 단항 플러스가 필요하지 않지만 줄을 잘 맞출 수 있습니다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;6.33&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;필자가 이 예제에서 &lt;strong&gt;단항 부정과 단항 플러스를 변수에만 사용한 이유&lt;/strong&gt;는, &lt;strong&gt;숫자형 리터럴 앞에 있는 -기호는 실제 숫자형 리터럴의 일부로 해석되므로 연산자가 아니기 때문&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h2 id=&quot;나머지&quot;&gt;나머지&lt;/h2&gt;

&lt;p&gt;나머지(remainder) 연산자는 나눗셈을 한 나머지를 반환합니다.&lt;br /&gt;
표현식의 x % y의 결과는 &lt;strong&gt;피제수dividend(x)&lt;/strong&gt; 를 &lt;strong&gt;제수divisor(y)&lt;/strong&gt; 로 나눈 나머지입니다.&lt;br /&gt;
예를 들어 10 % 3은 1입니다.&lt;br /&gt;
&lt;strong&gt;음수에 적용하면 결과는 제수가 아니라 피제수의 부호를 따라가므로 이 연산자를 진정한 나머지(modulo) 연산자라 할 수는 없습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;역주_&lt;/strong&gt; 자바스크립트에는 mod 연산자가 없지만, -10 mod 3은 -1이 아니라 2입니다(구글에서 검색하면 바로 답이 나옵니다.)&lt;br /&gt;
mod 연산자의 결과가 제수의 부호를 따르는 이유가 궁금하다면 &lt;a href=&quot;https://goo.gl/FjPtQd&quot;&gt;https://goo.gl/FjPtQd&lt;/a&gt;를 읽어보시기 바랍니다.&lt;br /&gt;
번역이 다 된 문서는 아니지만, 문서 중간쯤의 그림을 보시면 무슨 뜻인지 금방 알 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;나머지 연산자는 &lt;strong&gt;보통 전수 피연산자에만 사용하지만, 자바스크립트에서는 피연산자에 소수점이 있어도 잘 동작&lt;/strong&gt;합니다.&lt;br /&gt;
예를 들어 10 % 3.6은 2.8입니다.&lt;/p&gt;

&lt;h2 id=&quot;증가연산자-감소연산자&quot;&gt;증가연산자, 감소연산자&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;증가 연산자 ++는 할당 연산자와 덧셈 연산자를 하나로 합친 거나 다름없습니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;마찬가지로 감소 연산자 –는 할당 연산자와 뺄셈 연산자를 하나로 합친 거나 다름없습니다.&lt;/strong&gt;&lt;br /&gt;
이들은 간결하고 쓰기 쉽지만 주의해야 합니다.&lt;br /&gt;
이 연산자가 표현식 깊숙이 묻혀 있다면, 연산자의 부작용을 파악하기 어렵게 될 수 있습니다.&lt;/p&gt;

&lt;p&gt;전위(prefix)와 후위(postfix)의 차이도 이해해야 합니다.&lt;br /&gt;
전위 연산자는 먼저 변수의 값을 바꾼 다음에 평가합니다.&lt;br /&gt;
후위 연산자는 값을 바꾸기 전에 평가합니다.&lt;/p&gt;

&lt;p&gt;다음 코드를 읽어보고 결과를 맞혀 보십시오.&lt;br /&gt;
&lt;strong&gt;힌트는, 증가와 감소 연산자는 덧셈보다 먼저 실행되며, 이 예제의 표현식은 모두 왼쪽에서 오른쪽으로 진행합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;계산을 끝냈으면 자바스크립트 콘솔에서 실행해 보십시오.&lt;br /&gt;
r1과 r8을 모두 맞혔는지, 각 단계에서 x와 y의 값을 맞혔는지 확인해 보십시오.&lt;br /&gt;
이 연습문제가 어렵게 느껴진다면 종이에 적은 다음, 괄호를 써서 계산 순서를 표시해 보십시오.&lt;br /&gt;
그리고 그 순서대로 계산한다면 맞출 수 있을 겁니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image37.jpg&quot; alt=&quot;과정&quot; /&gt;
&lt;img src=&quot;/assets/img/learningjs/image38.jpg&quot; alt=&quot;과정&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">[표 5-1]은 자바스크립트의 산술 연산자입니다. 표 5-1 산술 연산자 연산자 설명 예제 + 덧셈(문자열 병합에도 쓰입니다.) 3 + 2 // 5 - 뺄셈 3 - 2 // 1 / 나눗셈 3/2 // 1.5 * 곱셈 3 * 2 // 6 % 나머지 3 % 2 // 1 - 단항 부정 -x // x의 부호를 바꿉니다. x가 50이면 -x는 -5입니다. + 단항 플러스 +x // x가 숫자가 아니면 숫자로 변환을 시도합니다. ++ 전위 증가 ++x // x에 1을 더한 다음 평가합니다. ++ 후위 증가 x++ // x를 평가한 다음 1을 더합니다. – 전위 감소 –x // x에서 1을 뺀 다음 평가합니다. – 후위 감소 x– // x의 값을 평가한 다음 1을 뺍니다. 자바스크립트의 숫자는 모두 더블 형식 자바스크립트의 숫자는 모두 더블 형식이므로 3/2처럼 정수를 연산한 결과도 더블 형식입니다. 단항부정과 단항플러스 뺄셈과 단항 부정은 모두 - 기호를 사용합니다. 그러면 자바스크립트는 둘을 어떻게 구별할까요? 답은 매우 복잡하고, 이 책에서 다룰 만한 내용은 아닙니다. 우리가 알아야 할 것은 단항 부정이 먼저 이루어지고 그 다음에 뺄셈을 한다는 겁니다. const x = 5; const y = 3 - -x; // y는 8입니다. 같은 규칙이 단항 플러스에도 적용됩니다. 단항 플러스 연산자는 자주 사용하는 연산자는 아닙니다. 보통 이 연산자를 사용한다면 문자열을 숫자로 강제 변환하는 경우이며, 드물게는 세로로 줄을 맞추고 싶을 때 사용합니다. const s = &quot;5&quot;; const y = 3 + +s; // y는 8입니다. 단항 플러스를 사용하지 않았다면 // 문자열 병합이 일어나서 결과는 &quot;35&quot;가 됩니다. // 여기서는 굳이 단항 플러스가 필요하지 않지만 줄을 잘 맞출 수 있습니다. const x1 = 0, x2 = 3, x3 = -1.5, x4 = -6.33; const p1 = -x1*1; const p2 = +x2*2; const p3 = +x3*3; const p4 = -x4*4; 필자가 이 예제에서 단항 부정과 단항 플러스를 변수에만 사용한 이유는, 숫자형 리터럴 앞에 있는 -기호는 실제 숫자형 리터럴의 일부로 해석되므로 연산자가 아니기 때문입니다. 나머지 나머지(remainder) 연산자는 나눗셈을 한 나머지를 반환합니다. 표현식의 x % y의 결과는 피제수dividend(x) 를 제수divisor(y) 로 나눈 나머지입니다. 예를 들어 10 % 3은 1입니다. 음수에 적용하면 결과는 제수가 아니라 피제수의 부호를 따라가므로 이 연산자를 진정한 나머지(modulo) 연산자라 할 수는 없습니다. 역주_ 자바스크립트에는 mod 연산자가 없지만, -10 mod 3은 -1이 아니라 2입니다(구글에서 검색하면 바로 답이 나옵니다.) mod 연산자의 결과가 제수의 부호를 따르는 이유가 궁금하다면 https://goo.gl/FjPtQd를 읽어보시기 바랍니다. 번역이 다 된 문서는 아니지만, 문서 중간쯤의 그림을 보시면 무슨 뜻인지 금방 알 수 있습니다. 나머지 연산자는 보통 전수 피연산자에만 사용하지만, 자바스크립트에서는 피연산자에 소수점이 있어도 잘 동작합니다. 예를 들어 10 % 3.6은 2.8입니다. 증가연산자, 감소연산자 증가 연산자 ++는 할당 연산자와 덧셈 연산자를 하나로 합친 거나 다름없습니다. 마찬가지로 감소 연산자 –는 할당 연산자와 뺄셈 연산자를 하나로 합친 거나 다름없습니다. 이들은 간결하고 쓰기 쉽지만 주의해야 합니다. 이 연산자가 표현식 깊숙이 묻혀 있다면, 연산자의 부작용을 파악하기 어렵게 될 수 있습니다. 전위(prefix)와 후위(postfix)의 차이도 이해해야 합니다. 전위 연산자는 먼저 변수의 값을 바꾼 다음에 평가합니다. 후위 연산자는 값을 바꾸기 전에 평가합니다. 다음 코드를 읽어보고 결과를 맞혀 보십시오. 힌트는, 증가와 감소 연산자는 덧셈보다 먼저 실행되며, 이 예제의 표현식은 모두 왼쪽에서 오른쪽으로 진행합니다. let x = 2; const r1 = x++ + x++; const r2 = ++x + ++x; const r3 = x++ + ++x; const r4 = ++x + x++; let y = 10; const r5 = y-- + y--; const r6 = --y + --y; const r7 = y-- + --y; const r8 = --y + y--; 계산을 끝냈으면 자바스크립트 콘솔에서 실행해 보십시오. r1과 r8을 모두 맞혔는지, 각 단계에서 x와 y의 값을 맞혔는지 확인해 보십시오. 이 연습문제가 어렵게 느껴진다면 종이에 적은 다음, 괄호를 써서 계산 순서를 표시해 보십시오. 그리고 그 순서대로 계산한다면 맞출 수 있을 겁니다.</summary></entry><entry><title type="html">5.1 연산자</title><link href="http://localhost:4000/javascript/2020/04/20/javascript80/" rel="alternate" type="text/html" title="5.1 연산자" /><published>2020-04-20T22:16:00+09:00</published><updated>2020-04-20T22:16:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/20/javascript80</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/20/javascript80/">&lt;p&gt;연산자를 표현식의 &lt;strong&gt;‘명사(noun)’&lt;/strong&gt; 에 대한 &lt;strong&gt;‘동사(verb)’&lt;/strong&gt; 라고 생각해도 좋습니다.&lt;br /&gt;
표현식이 &lt;strong&gt;값이 되는 것&lt;/strong&gt;이라면 연산자는 &lt;strong&gt;값을 만드는 행동&lt;/strong&gt;이라는 뜻입니다.&lt;br /&gt;
연산자에 대한 설명은 산술 연산자로 시작하겠습니다.&lt;br /&gt;
산술 연산자에 대한 경험이 없는 사람은 거의 없으니 직관적으로 이해하기 쉬울 겁니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;NOTE_&lt;/strong&gt; 연산자는 하나 이상의 &lt;strong&gt;피연산자&lt;/strong&gt;가 있어야 결과를 낼 수 있습니다.&lt;br /&gt;
예를 들어 1 + 2라는 표현식에서 1과 2는 &lt;strong&gt;피연산자&lt;/strong&gt;이고 +는 &lt;strong&gt;연산자&lt;/strong&gt;입니다.&lt;br /&gt;
엄격히 말하면 &lt;strong&gt;피연산자&lt;/strong&gt;가 맞는 말이지만 피연산자를 &lt;strong&gt;매개변수(argument)&lt;/strong&gt; 라 부르는 경우도 많이 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">연산자를 표현식의 ‘명사(noun)’ 에 대한 ‘동사(verb)’ 라고 생각해도 좋습니다. 표현식이 값이 되는 것이라면 연산자는 값을 만드는 행동이라는 뜻입니다. 연산자에 대한 설명은 산술 연산자로 시작하겠습니다. 산술 연산자에 대한 경험이 없는 사람은 거의 없으니 직관적으로 이해하기 쉬울 겁니다. NOTE_ 연산자는 하나 이상의 피연산자가 있어야 결과를 낼 수 있습니다. 예를 들어 1 + 2라는 표현식에서 1과 2는 피연산자이고 +는 연산자입니다. 엄격히 말하면 피연산자가 맞는 말이지만 피연산자를 매개변수(argument) 라 부르는 경우도 많이 있습니다.</summary></entry><entry><title type="html">5. 표현식과 연산자</title><link href="http://localhost:4000/javascript/2020/04/20/javascript79/" rel="alternate" type="text/html" title="5. 표현식과 연산자" /><published>2020-04-20T20:13:55+09:00</published><updated>2020-04-20T20:13:55+09:00</updated><id>http://localhost:4000/javascript/2020/04/20/javascript79</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/20/javascript79/">&lt;p&gt;&lt;strong&gt;표현식(expression)&lt;/strong&gt; 은 값으로 평가될 수 있는 문입니다.&lt;br /&gt;
&lt;strong&gt;즉 결과가 값인 문과, 표현식이 아닌 문의 차이를 이해하는 것이 매우 중요합니다.&lt;/strong&gt;&lt;br /&gt;
이 차이를 이해해야만 자바스크립트의 요소들을 효과적으로 조합할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;표현식이 아닌 문(statement)&lt;/strong&gt; 은 일종의 &lt;strong&gt;지시&lt;/strong&gt;라고 생각할 수 있고, &lt;strong&gt;표현식&lt;/strong&gt;은 &lt;strong&gt;무언가를 요청하는 것&lt;/strong&gt;이라고 생각할 수 있습니다.&lt;br /&gt;
자, 직장에 첫 출근했다고 상상해 봅시다.&lt;br /&gt;
상사가 다가와서 “당신이 할 일은 볼트 A를 너트 B에 끼우는 일입니다.”라고 말합니다.&lt;br /&gt;
상사가 한 말은 &lt;strong&gt;표현식이 아닌&lt;/strong&gt; 문입니다.&lt;br /&gt;
&lt;strong&gt;상사는 당신에게 조립한 결과물을 요청한 것이 아니라, 그저 조립할 것을 지시했을 뿐입니다.&lt;/strong&gt;&lt;br /&gt;
상사가 “볼트 A를 너트 B에 끼우고, 내가 검사할 수 있도록 가져오세요.” 라고 말했다면 그건 &lt;strong&gt;표현식&lt;/strong&gt;입니다.&lt;br /&gt;
당신은 지시를 받았고, 그 결과를 반환해야 합니다.&lt;/p&gt;

&lt;p&gt;“어떻든 결과는 마찬가지 아닌가? 조립한 결과를 그냥 두든, 상사에게 가져가든 조립된 건 마찬가지인데.” 라고 생각할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어라고 상황이 180도 달라지는 건 아닙니다.&lt;br /&gt;
&lt;strong&gt;표현식&lt;/strong&gt;이 아닌 &lt;strong&gt;문&lt;/strong&gt;도 &lt;strong&gt;뭔가&lt;/strong&gt;를 합니다.&lt;br /&gt;
&lt;strong&gt;하지만 그 결과를 명시적으로 반환하는 것은 표현식입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;표현식은 값이 됩니다.&lt;br /&gt;
&lt;strong&gt;그 결과를 다른 표현식에 결합해서 다른 값을 얻을 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
그 값을 또 다른 표현식에 결합해서 또 다른 값을 얻는 식으로 이어질 수 있습니다.&lt;br /&gt;
표현식이 아닌 문은 이런 식으로 결합할 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;표현식은 값이 되므로 할당에 쓸 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
즉, 표현식의 결과를 변수나 상수, 프로퍼티에 할당할 수 있습니다.&lt;br /&gt;
표현식의 예를 하나 들어 봅시다.&lt;br /&gt;
&lt;strong&gt;곱셈은 표현식입니다.&lt;/strong&gt;&lt;br /&gt;
이해하기 쉽겠죠?&lt;br /&gt;
두 숫자를 곱하면 결과가 나옵니다.&lt;br /&gt;
매우 단순한 문 두 개를 봅시다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;첫 번째 행은 &lt;strong&gt;선언문&lt;/strong&gt;입니다.&lt;br /&gt;
우리는 변수 x가 있다고 선언했습니다.&lt;br /&gt;
물론 두 행을 결합할 수 있지만, 그렇게 하면 요점이 잘 드러나지 않습니다.&lt;br /&gt;
두 번째 행을 잘 봅시다.&lt;br /&gt;
이 행에는 사실 표현식이 두 개 있습니다.&lt;br /&gt;
첫 번째 표현식은 3 * 5 입니다.&lt;br /&gt;
곱셈 표현식이고, 결과는 15입니다.&lt;br /&gt;
그 다음은 값 15를 변수 x에 할당한 표현식입니다.&lt;br /&gt;
&lt;strong&gt;할당은 그 자체가 표현식입니다.&lt;/strong&gt;&lt;br /&gt;
음? 표현식은 값이 된다고 했는데, 그럼 할당 표현식은 어떤 값이 되는 걸까요?&lt;br /&gt;
물론 할당 표현식도 값이 됩니다.&lt;br /&gt;
x만 값 15를 할당 받는 것이 아니라, &lt;strong&gt;전체 표현식&lt;/strong&gt;의 결과도 값 15입니다.&lt;br /&gt;
&lt;strong&gt;할당은 표현식이고, 따라서 값이 되므로, 다른 변수에 다시 할당할 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
좀 우스꽝스럽지만, 다음 예제를 보십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 x와 y 두 변수가 있고 값은 모두 15입니다.&lt;br /&gt;
&lt;strong&gt;이런 일이 가능한 것은 곱셈과 할당이 모두 표현식이기 때문입니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;자바스크립트는 이렇게 표현식이 결합된 것을 보면 쪼갤 수 있는 만큼 쪼개서 한 부분씩 실행합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//원래 문&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 곱셈 표현식을 평가했습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;// 첫 번째 할당을 평가했습니다. x는 이제 15이고, &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//y는 아직 undefined입니다.&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;// 두 번째 할당을 평가했습니다. y는 이제 15입니다. &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//전체 문의 결과는 15입니다. 이 값은 사용하지도 않았고 &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//어딘가에 할당하지도 않았으니 그냥 버려집니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러면 이제 자바스크립트는 어떤 원칙으로 표현식을 그런 순서로 실행하는가 하는 의문이 들겁니다.&lt;br /&gt;
즉, y = x를 먼저 실행해서 y에 값을 undefined를 할당하고 &lt;strong&gt;그 다음에&lt;/strong&gt; 곱셈을 해서 y는 undefined로 남고 x는 15가 될 수도 있지 않느냐는 의문 말입니다.&lt;br /&gt;
자바스크립트가 표현식을 평가하는 순서를 &lt;strong&gt;연산자 우선순위&lt;/strong&gt;라 부르며, 이 장에서 설명할 겁니다.&lt;/p&gt;

&lt;p&gt;표현식은 대부분 &lt;strong&gt;연산자(operator)&lt;/strong&gt; 표현식입니다.&lt;br /&gt;
즉 곱셈 표현식은 &lt;strong&gt;곱셈 연산자(*)&lt;/strong&gt; 와 &lt;strong&gt;피연산자(operand)&lt;/strong&gt; 두 개로 이루어집니다. &lt;br /&gt;
&lt;strong&gt;피연산자는 서로 곱하는 두 숫자&lt;/strong&gt;이며 피연산자 자체도 표현식입니다.&lt;/p&gt;

&lt;p&gt;연산자 표현식이 아닌 표현식에는 &lt;strong&gt;식별자 표현식&lt;/strong&gt;(변수와 상수 이름)과 &lt;strong&gt;리터럴 표현식&lt;/strong&gt; 두 가지가 있습니다.&lt;br /&gt;
이름만 봐도 알 수 있을 겁니다.&lt;br /&gt;
변수와 상수, 리터럴은 그 자체가 표현식입니다.&lt;br /&gt;
표현식은 모두 평등합니다.&lt;br /&gt;
값이 되는 것은 모두 표현식이므로, 변수와 상수, 리터럴이 모두 표현식인 것은 당연합니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">표현식(expression) 은 값으로 평가될 수 있는 문입니다. 즉 결과가 값인 문과, 표현식이 아닌 문의 차이를 이해하는 것이 매우 중요합니다. 이 차이를 이해해야만 자바스크립트의 요소들을 효과적으로 조합할 수 있습니다. 표현식이 아닌 문(statement) 은 일종의 지시라고 생각할 수 있고, 표현식은 무언가를 요청하는 것이라고 생각할 수 있습니다. 자, 직장에 첫 출근했다고 상상해 봅시다. 상사가 다가와서 “당신이 할 일은 볼트 A를 너트 B에 끼우는 일입니다.”라고 말합니다. 상사가 한 말은 표현식이 아닌 문입니다. 상사는 당신에게 조립한 결과물을 요청한 것이 아니라, 그저 조립할 것을 지시했을 뿐입니다. 상사가 “볼트 A를 너트 B에 끼우고, 내가 검사할 수 있도록 가져오세요.” 라고 말했다면 그건 표현식입니다. 당신은 지시를 받았고, 그 결과를 반환해야 합니다. “어떻든 결과는 마찬가지 아닌가? 조립한 결과를 그냥 두든, 상사에게 가져가든 조립된 건 마찬가지인데.” 라고 생각할 수도 있습니다. 프로그래밍 언어라고 상황이 180도 달라지는 건 아닙니다. 표현식이 아닌 문도 뭔가를 합니다. 하지만 그 결과를 명시적으로 반환하는 것은 표현식입니다. 표현식은 값이 됩니다. 그 결과를 다른 표현식에 결합해서 다른 값을 얻을 수 있습니다. 그 값을 또 다른 표현식에 결합해서 또 다른 값을 얻는 식으로 이어질 수 있습니다. 표현식이 아닌 문은 이런 식으로 결합할 수 없습니다. 표현식은 값이 되므로 할당에 쓸 수 있습니다. 즉, 표현식의 결과를 변수나 상수, 프로퍼티에 할당할 수 있습니다. 표현식의 예를 하나 들어 봅시다. 곱셈은 표현식입니다. 이해하기 쉽겠죠? 두 숫자를 곱하면 결과가 나옵니다. 매우 단순한 문 두 개를 봅시다. let x; x = 3 * 5; 첫 번째 행은 선언문입니다. 우리는 변수 x가 있다고 선언했습니다. 물론 두 행을 결합할 수 있지만, 그렇게 하면 요점이 잘 드러나지 않습니다. 두 번째 행을 잘 봅시다. 이 행에는 사실 표현식이 두 개 있습니다. 첫 번째 표현식은 3 * 5 입니다. 곱셈 표현식이고, 결과는 15입니다. 그 다음은 값 15를 변수 x에 할당한 표현식입니다. 할당은 그 자체가 표현식입니다. 음? 표현식은 값이 된다고 했는데, 그럼 할당 표현식은 어떤 값이 되는 걸까요? 물론 할당 표현식도 값이 됩니다. x만 값 15를 할당 받는 것이 아니라, 전체 표현식의 결과도 값 15입니다. 할당은 표현식이고, 따라서 값이 되므로, 다른 변수에 다시 할당할 수 있습니다. 좀 우스꽝스럽지만, 다음 예제를 보십시오. let x, y; y = x = 3 * 5; 이제 x와 y 두 변수가 있고 값은 모두 15입니다. 이런 일이 가능한 것은 곱셈과 할당이 모두 표현식이기 때문입니다. 자바스크립트는 이렇게 표현식이 결합된 것을 보면 쪼갤 수 있는 만큼 쪼개서 한 부분씩 실행합니다. let x, y; y = x = 3 * 5; //원래 문 y = x = 15; // 곱셈 표현식을 평가했습니다. y = 15; // 첫 번째 할당을 평가했습니다. x는 이제 15이고, //y는 아직 undefined입니다. 15; // 두 번째 할당을 평가했습니다. y는 이제 15입니다. //전체 문의 결과는 15입니다. 이 값은 사용하지도 않았고 //어딘가에 할당하지도 않았으니 그냥 버려집니다. 그러면 이제 자바스크립트는 어떤 원칙으로 표현식을 그런 순서로 실행하는가 하는 의문이 들겁니다. 즉, y = x를 먼저 실행해서 y에 값을 undefined를 할당하고 그 다음에 곱셈을 해서 y는 undefined로 남고 x는 15가 될 수도 있지 않느냐는 의문 말입니다. 자바스크립트가 표현식을 평가하는 순서를 연산자 우선순위라 부르며, 이 장에서 설명할 겁니다. 표현식은 대부분 연산자(operator) 표현식입니다. 즉 곱셈 표현식은 곱셈 연산자(*) 와 피연산자(operand) 두 개로 이루어집니다. 피연산자는 서로 곱하는 두 숫자이며 피연산자 자체도 표현식입니다. 연산자 표현식이 아닌 표현식에는 식별자 표현식(변수와 상수 이름)과 리터럴 표현식 두 가지가 있습니다. 이름만 봐도 알 수 있을 겁니다. 변수와 상수, 리터럴은 그 자체가 표현식입니다. 표현식은 모두 평등합니다. 값이 되는 것은 모두 표현식이므로, 변수와 상수, 리터럴이 모두 표현식인 것은 당연합니다.</summary></entry><entry><title type="html">4.4 요약</title><link href="http://localhost:4000/javascript/2020/04/20/javascript78/" rel="alternate" type="text/html" title="4.4 요약" /><published>2020-04-20T00:39:50+09:00</published><updated>2020-04-20T00:39:50+09:00</updated><id>http://localhost:4000/javascript/2020/04/20/javascript78</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/20/javascript78/">&lt;p&gt;&lt;strong&gt;제어문은 실제로 프로그램이 동작하게 하는 가장 중요한 열쇠&lt;/strong&gt;입니다.&lt;br /&gt;
변수와 상수에 중요한 정보가 아무리 많이 들어있다 해도 제어문을 써야 그 데이터에 따라 필요한 선택을 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;순서도는 프로그램의 흐름을 시각적으로 표현하는 좋은 방법&lt;/strong&gt;이고, 코드를 작성하기 전에 추상적인 순서도를 그려 보면 문제를 어떻게 해결할지 결정하는 데 도움이 될 수 있습니다.&lt;br /&gt;
하지만 순서도는 간단하게 그리기가 어려우며, 충분히 훈련된 사람은 프로그램의 흐름을 코드만으로도 자연스럽게 표현할 수 있습니다.&lt;br /&gt;
&lt;strong&gt;사실 순서도를 그리듯, 레고 블록을 조립하듯 시각적으로 프로그램을 만드는 언어를 만들려는 시도는 여러 가지가 있었지만, 텍스트 기반 프로그래밍 언어가 이런 시도에 위협받았던 적은 한 번도 없습니다.&lt;/strong&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">제어문은 실제로 프로그램이 동작하게 하는 가장 중요한 열쇠입니다. 변수와 상수에 중요한 정보가 아무리 많이 들어있다 해도 제어문을 써야 그 데이터에 따라 필요한 선택을 할 수 있습니다. 순서도는 프로그램의 흐름을 시각적으로 표현하는 좋은 방법이고, 코드를 작성하기 전에 추상적인 순서도를 그려 보면 문제를 어떻게 해결할지 결정하는 데 도움이 될 수 있습니다. 하지만 순서도는 간단하게 그리기가 어려우며, 충분히 훈련된 사람은 프로그램의 흐름을 코드만으로도 자연스럽게 표현할 수 있습니다. 사실 순서도를 그리듯, 레고 블록을 조립하듯 시각적으로 프로그램을 만드는 언어를 만들려는 시도는 여러 가지가 있었지만, 텍스트 기반 프로그래밍 언어가 이런 시도에 위협받았던 적은 한 번도 없습니다.</summary></entry></feed>