<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-04-21T00:59:01+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">LHJ</title><subtitle>coding blog</subtitle><entry><title type="html">5.4 비교 연산자</title><link href="http://localhost:4000/javascript/2020/04/21/javascript83/" rel="alternate" type="text/html" title="5.4 비교 연산자" /><published>2020-04-21T00:41:39+09:00</published><updated>2020-04-21T00:41:39+09:00</updated><id>http://localhost:4000/javascript/2020/04/21/javascript83</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/21/javascript83/">&lt;p&gt;비교 연산자는 이름처럼 두 개의 값을 비교합니다.&lt;br /&gt;
크게 말해 비교 연산자는 &lt;strong&gt;일치함(strict equality(===), 동등함(loose equality(==)), 대소 관계&lt;/strong&gt;의 세 가지 타입으로 나뉩니다(불일치는 일치의 한 종류라고 보기 때문에 다른 타입으로 나누지는 않습니다).&lt;/p&gt;

&lt;p&gt;초보자들은 &lt;strong&gt;일치&lt;/strong&gt;와 &lt;strong&gt;동등&lt;/strong&gt;의 차이를 이해하지 못하는 경우가 많습니다.&lt;br /&gt;
먼저 일치에 대해 이해해보기로 합시다.&lt;br /&gt;
&lt;strong&gt;두 값이 같은 객체를 가리키거나, 같은 타입이고 값도 같다면(원시 타입) 이 값을 일치한다고 합니다.&lt;/strong&gt;&lt;br /&gt;
일치 관계는 아주 단순하고 이해하기 쉬우므로 버그나 오해를 낳는 경우가 거의 없습니다.&lt;br /&gt;
&lt;strong&gt;두 값이 일치하는지 확인할 때는 === 연산자를 쓰거나 그 반대인 !== 연산자를 씁니다.&lt;/strong&gt;&lt;br /&gt;
예제를 살펴보기 전에 먼저 동등 관계를 알아봅시다.&lt;/p&gt;

&lt;p&gt;한편, 두 값이 같은 객체를 가리키거나 &lt;strong&gt;같은 값을 갖도록 변환할 수 있다면&lt;/strong&gt; 두 값을 동등하다고 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;역주_&lt;/strong&gt; 두 값이 같은 객체를 가리킬 때 일치한다고도 하고 동등하다고도 했는데, 좀 이상하게 읽힐 수도 있지만 저자의 설명이 틀린 것은 아닙니다.&lt;br /&gt;
두 값이 일치하면 당연히 두 값은 동등하기도 합니다.&lt;br /&gt;
예를 들어 2 === 2는 true이고 2 == 2도 true입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞 부분은 괜찮지만, 두 번째 부분은 수 많은 골칫거리와 혼란을 발생시켰습니다.&lt;br /&gt;
이따금은 편리할 때도 있습니다.&lt;br /&gt;
&lt;strong&gt;문자열 “33”은 숫자 33으로 변환할 수 있으므로 이 둘은 동등합니다.&lt;/strong&gt;&lt;br /&gt;
하지만 타입이 다르므로 일치하지는 않습니다.&lt;br /&gt;
동등 비교가 편리할 때도 있지만, 이런 편리함 때문에 수많은 부작용이 생길 수 있습니다.&lt;br /&gt;
따라서 문자열은 미리 숫자로 변환해서 일치하는지 비교하길 권합니다.&lt;br /&gt;
&lt;strong&gt;동등한지 아닌지 비교할 때는 == 연산자나 != 연산자를 사용합니다.&lt;/strong&gt;&lt;br /&gt;
동등 연산자 때문에 생기는 문제와 함정을 자세히 알고 싶다면 더글러스 크록포드의 &lt;strong&gt;자바스크립트 핵심 가이드(한빛미디어, 2008)&lt;/strong&gt; 를 권합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;TIP&lt;/strong&gt;&lt;br /&gt;
동등 연산자 때문에 문제가 생기는 경우는 대개 &lt;strong&gt;null과 undefined, 빈 문자열, 숫자 0&lt;/strong&gt; 때문입니다.&lt;br /&gt;
위 네 가지 경우에 해당하지 않는 값을 비교한다면 동등 연산자를 써도 안전할 때가 많습니다.&lt;br /&gt;
하지만 기계적으로 동등 연산자를 쓰는 습관은 빨리 버릴수록 좋습니다.&lt;br /&gt;
필자가 권하는 대로 일치 연산자만 사용한다면 &lt;strong&gt;이런 문제에 대해 생각할 필요도 없습니다.&lt;/strong&gt;&lt;br /&gt;
동등 연산자를 써도 안전한지, 아니면 (미세한) 이득이 있는지 생각하느라 중요한 흐름을 방해받지 않아도 됩니다.&lt;br /&gt;
그냥 일치 연산자를 사용하고 계속 진행하면 됩니다.&lt;br /&gt;
일치 연산자를 사용했을 때 원하는 결과가 나오지 않으면, &lt;strong&gt;말썽꾸러기인 동등 연산자로 바꾸지 말고 그냥 데이터 타입을 변환하면 됩니다.&lt;/strong&gt;&lt;br /&gt;
프로그래밍은 그 자체로도 충분히 힘든 작업입니다.&lt;br /&gt;
동등 연산자를 써서 불필요한 문제를 초래하지 마십시오.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다음은 일치 연산자와 동등 연산자의 예입니다.&lt;br /&gt;
객체 a와 b에 같은 정보가 들어 있더라도 그들은 &lt;strong&gt;서로 다른 객체&lt;/strong&gt;이며, 일치하지도 않고 동등하지도 않습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//false -- 타입이 다릅니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// true -- 문자열 &quot;5&quot;를 숫자 5로 변환했습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// false&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// true; 권장하지 않습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// false; 권장하지 않습니다.&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;an object&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;an object&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// false -- 객체는 항상 다릅니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// false; 권장하지 않습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true; 권장하지 않습니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;관계 연산자는 &lt;strong&gt;관계가 있는 값&lt;/strong&gt;을 비교하며, 문자열이나 숫자처럼 원래 순서가 있는 데이터 타입에만 사용할 수 있습니다(‘a’는 항상 ‘b’보다 앞에 있습니다).&lt;/p&gt;

&lt;p&gt;관계 연산자에는 작다(&amp;lt;), 작거나 같다(&amp;lt;=), 크다(&amp;gt;), 크거나 같다(&amp;gt;=) 네 가지가 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// false&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// false&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;

&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// false&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// true&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// false&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//true&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">비교 연산자는 이름처럼 두 개의 값을 비교합니다. 크게 말해 비교 연산자는 일치함(strict equality(===), 동등함(loose equality(==)), 대소 관계의 세 가지 타입으로 나뉩니다(불일치는 일치의 한 종류라고 보기 때문에 다른 타입으로 나누지는 않습니다). 초보자들은 일치와 동등의 차이를 이해하지 못하는 경우가 많습니다. 먼저 일치에 대해 이해해보기로 합시다. 두 값이 같은 객체를 가리키거나, 같은 타입이고 값도 같다면(원시 타입) 이 값을 일치한다고 합니다. 일치 관계는 아주 단순하고 이해하기 쉬우므로 버그나 오해를 낳는 경우가 거의 없습니다. 두 값이 일치하는지 확인할 때는 === 연산자를 쓰거나 그 반대인 !== 연산자를 씁니다. 예제를 살펴보기 전에 먼저 동등 관계를 알아봅시다. 한편, 두 값이 같은 객체를 가리키거나 같은 값을 갖도록 변환할 수 있다면 두 값을 동등하다고 합니다. 역주_ 두 값이 같은 객체를 가리킬 때 일치한다고도 하고 동등하다고도 했는데, 좀 이상하게 읽힐 수도 있지만 저자의 설명이 틀린 것은 아닙니다. 두 값이 일치하면 당연히 두 값은 동등하기도 합니다. 예를 들어 2 === 2는 true이고 2 == 2도 true입니다. 앞 부분은 괜찮지만, 두 번째 부분은 수 많은 골칫거리와 혼란을 발생시켰습니다. 이따금은 편리할 때도 있습니다. 문자열 “33”은 숫자 33으로 변환할 수 있으므로 이 둘은 동등합니다. 하지만 타입이 다르므로 일치하지는 않습니다. 동등 비교가 편리할 때도 있지만, 이런 편리함 때문에 수많은 부작용이 생길 수 있습니다. 따라서 문자열은 미리 숫자로 변환해서 일치하는지 비교하길 권합니다. 동등한지 아닌지 비교할 때는 == 연산자나 != 연산자를 사용합니다. 동등 연산자 때문에 생기는 문제와 함정을 자세히 알고 싶다면 더글러스 크록포드의 자바스크립트 핵심 가이드(한빛미디어, 2008) 를 권합니다. TIP 동등 연산자 때문에 문제가 생기는 경우는 대개 null과 undefined, 빈 문자열, 숫자 0 때문입니다. 위 네 가지 경우에 해당하지 않는 값을 비교한다면 동등 연산자를 써도 안전할 때가 많습니다. 하지만 기계적으로 동등 연산자를 쓰는 습관은 빨리 버릴수록 좋습니다. 필자가 권하는 대로 일치 연산자만 사용한다면 이런 문제에 대해 생각할 필요도 없습니다. 동등 연산자를 써도 안전한지, 아니면 (미세한) 이득이 있는지 생각하느라 중요한 흐름을 방해받지 않아도 됩니다. 그냥 일치 연산자를 사용하고 계속 진행하면 됩니다. 일치 연산자를 사용했을 때 원하는 결과가 나오지 않으면, 말썽꾸러기인 동등 연산자로 바꾸지 말고 그냥 데이터 타입을 변환하면 됩니다. 프로그래밍은 그 자체로도 충분히 힘든 작업입니다. 동등 연산자를 써서 불필요한 문제를 초래하지 마십시오. 다음은 일치 연산자와 동등 연산자의 예입니다. 객체 a와 b에 같은 정보가 들어 있더라도 그들은 서로 다른 객체이며, 일치하지도 않고 동등하지도 않습니다. const n = 5; const s = &quot;5&quot;; n === s; //false -- 타입이 다릅니다. n !== s; // true n === Number(s); // true -- 문자열 &quot;5&quot;를 숫자 5로 변환했습니다. n !== Number(s); // false n == s; // true; 권장하지 않습니다. n != s; // false; 권장하지 않습니다. const a = { name: &quot;an object&quot; }; const b = { name: &quot;an object&quot; }; a === b; // false -- 객체는 항상 다릅니다. a !== b; // true a == b; // false; 권장하지 않습니다. a != b; // true; 권장하지 않습니다. 관계 연산자는 관계가 있는 값을 비교하며, 문자열이나 숫자처럼 원래 순서가 있는 데이터 타입에만 사용할 수 있습니다(‘a’는 항상 ‘b’보다 앞에 있습니다). 관계 연산자에는 작다(&amp;lt;), 작거나 같다(&amp;lt;=), 크다(&amp;gt;), 크거나 같다(&amp;gt;=) 네 가지가 있습니다. 3 &amp;gt; 5; // false 3 &amp;gt;= 5; // false 3 &amp;lt; 5; // true 3 &amp;lt;= 5; // true 5 &amp;gt; 5; // false 5 &amp;gt;= 5; // true 5 &amp;lt; 5; // false 5 &amp;lt;= 5; //true</summary></entry><entry><title type="html">5.3 연산자 우선순위</title><link href="http://localhost:4000/javascript/2020/04/21/javascript82/" rel="alternate" type="text/html" title="5.3 연산자 우선순위" /><published>2020-04-21T00:27:00+09:00</published><updated>2020-04-21T00:27:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/21/javascript82</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/21/javascript82/">&lt;p&gt;모든 표현식은 값이 된다는 걸 이해했으면, 그 다음은 연산자 우선순위를 이해해야 합니다.&lt;br /&gt;
연산자 우선순위를 이해해야 자바스크립트 프로그램이 어떻게 동작하는지 이해할 수 있습니다.&lt;/p&gt;

&lt;p&gt;산술 연산자를 설명했으니 자바스크립트의 여러 연산자에 대한 설명을 잠시 멈추고 연산자 우선순위에 대해 생각해 봅시다.&lt;br /&gt;
초등 교육을 받았다면 연산자 우선순위에 대해 배웠을 겁니다.&lt;/p&gt;

&lt;p&gt;다음 문제는 어렵지 않게 풀 수 있을 겁니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;25라고 답했으면 연산자 우선순위를 정확히 적용한 겁니다.&lt;br /&gt;
괄호가 제일 먼저고, 그 다음에 곱셈과 나눗셈을 하고, 마지막으로 덧셈과 뺄셈을 합니다.&lt;/p&gt;

&lt;p&gt;자바스크립트는 표현식을 평가할 때도 비슷한 규칙을 적용합니다.&lt;br /&gt;
산수에만 쓰는 것은 아닙니다.&lt;br /&gt;
자바스크립트에서 표현식을 평가하는 순서도 초등학교에서 배웠던 것과 같습니다.&lt;/p&gt;

&lt;p&gt;물론 자바스크립트에는 연산자가 훨씬 더 많으니 기억할 것이 늘어나기는 합니다.&lt;br /&gt;
다행히, 산수와 마찬가지로 괄호가 최우선입니다.&lt;br /&gt;
표현식 순서가 잘 기억나지 않으면, 가장 먼저 이루어져야 하는 순서대로 괄호를 쓰면 그대로 이루어질 겁니다.&lt;/p&gt;

&lt;p&gt;현재 자바스크립트에는 &lt;strong&gt;56개&lt;/strong&gt;의 연산자가 있고, 우선순위를 기준으로 &lt;strong&gt;19개&lt;/strong&gt;의 그룹으로 묶을 수 있습니다.&lt;br /&gt;
연산자의 우선순위가 높을수록 먼저 실행됩니다.&lt;br /&gt;
부록 B에 연산자 우선순위 테이블이 있습니다.&lt;br /&gt;
필자는 이 테이블을 몇 해에 걸쳐 자연스럽게 기억하게 됐지만, 여전히 가끔 찾아보면서 기억을 되살리기도 하고, 새로운 기능을 배우게 되면 어떤 우선순위가 적용되는지 찾아보기도 합니다.&lt;/p&gt;

&lt;p&gt;우선순위가 같은 연산자들은 &lt;strong&gt;오른쪽에서 왼쪽으로&lt;/strong&gt; 또는 &lt;strong&gt;왼쪽에서 오른쪽으로&lt;/strong&gt; 평가합니다.&lt;br /&gt;
예를 들어 곱셈과 나눗셈의 우선순위는 둘 다 14이고, 이들은 왼쪽에서 오른쪽으로 평가합니다.&lt;br /&gt;
곱셈과 나눗셈이 끝나면 우선순위가 3인 할당 연산자를, 오른쪽에서 왼쪽으로 평가하는 식입니다.&lt;br /&gt;
이 내용을 염두에 두고 다음 예제의 순서를 생각해 봅시다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 이 표현식을 우선순위에 따라 다음에 일어날 행동에 괄호를 치겠습니다.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 곱셈과 나눗셈, 우선순위 14, 왼쪽에서 오른쪽으로&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// x += y = (6*5)/2&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// x += y = (30)/2&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// x += y = 15&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 할당, 우선순위 3, 오른쪽에서 왼쪽으로&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// x += (y = 15)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// x += 15    y는 이제 15입니다.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 18    x는 이제 18입니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;연산자 우선순위를 이해하는 게 처음에는 벅차 보이겠지만, 곧 숨을 쉬듯 자연스러워질 겁니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">모든 표현식은 값이 된다는 걸 이해했으면, 그 다음은 연산자 우선순위를 이해해야 합니다. 연산자 우선순위를 이해해야 자바스크립트 프로그램이 어떻게 동작하는지 이해할 수 있습니다. 산술 연산자를 설명했으니 자바스크립트의 여러 연산자에 대한 설명을 잠시 멈추고 연산자 우선순위에 대해 생각해 봅시다. 초등 교육을 받았다면 연산자 우선순위에 대해 배웠을 겁니다. 다음 문제는 어렵지 않게 풀 수 있을 겁니다. 8 / 2 + 3 x (4 x 2 - 1) 25라고 답했으면 연산자 우선순위를 정확히 적용한 겁니다. 괄호가 제일 먼저고, 그 다음에 곱셈과 나눗셈을 하고, 마지막으로 덧셈과 뺄셈을 합니다. 자바스크립트는 표현식을 평가할 때도 비슷한 규칙을 적용합니다. 산수에만 쓰는 것은 아닙니다. 자바스크립트에서 표현식을 평가하는 순서도 초등학교에서 배웠던 것과 같습니다. 물론 자바스크립트에는 연산자가 훨씬 더 많으니 기억할 것이 늘어나기는 합니다. 다행히, 산수와 마찬가지로 괄호가 최우선입니다. 표현식 순서가 잘 기억나지 않으면, 가장 먼저 이루어져야 하는 순서대로 괄호를 쓰면 그대로 이루어질 겁니다. 현재 자바스크립트에는 56개의 연산자가 있고, 우선순위를 기준으로 19개의 그룹으로 묶을 수 있습니다. 연산자의 우선순위가 높을수록 먼저 실행됩니다. 부록 B에 연산자 우선순위 테이블이 있습니다. 필자는 이 테이블을 몇 해에 걸쳐 자연스럽게 기억하게 됐지만, 여전히 가끔 찾아보면서 기억을 되살리기도 하고, 새로운 기능을 배우게 되면 어떤 우선순위가 적용되는지 찾아보기도 합니다. 우선순위가 같은 연산자들은 오른쪽에서 왼쪽으로 또는 왼쪽에서 오른쪽으로 평가합니다. 예를 들어 곱셈과 나눗셈의 우선순위는 둘 다 14이고, 이들은 왼쪽에서 오른쪽으로 평가합니다. 곱셈과 나눗셈이 끝나면 우선순위가 3인 할당 연산자를, 오른쪽에서 왼쪽으로 평가하는 식입니다. 이 내용을 염두에 두고 다음 예제의 순서를 생각해 봅시다. let x = 3, y; x += y = 6*5/2; // 이 표현식을 우선순위에 따라 다음에 일어날 행동에 괄호를 치겠습니다. // // 곱셈과 나눗셈, 우선순위 14, 왼쪽에서 오른쪽으로 // x += y = (6*5)/2 // x += y = (30)/2 // x += y = 15 // 할당, 우선순위 3, 오른쪽에서 왼쪽으로 // x += (y = 15) // x += 15 y는 이제 15입니다. // 18 x는 이제 18입니다. 연산자 우선순위를 이해하는 게 처음에는 벅차 보이겠지만, 곧 숨을 쉬듯 자연스러워질 겁니다.</summary></entry><entry><title type="html">5.2 산술 연산자</title><link href="http://localhost:4000/javascript/2020/04/20/javascript81/" rel="alternate" type="text/html" title="5.2 산술 연산자" /><published>2020-04-20T22:21:00+09:00</published><updated>2020-04-20T22:21:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/20/javascript81</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/20/javascript81/">&lt;p&gt;[표 5-1]은 자바스크립트의 산술 연산자입니다.&lt;br /&gt;
&lt;strong&gt;표 5-1 산술 연산자&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;연산자&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
      &lt;th&gt;예제&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;덧셈(문자열 병합에도 쓰입니다.)&lt;/td&gt;
      &lt;td&gt;3 + 2 // 5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;뺄셈&lt;/td&gt;
      &lt;td&gt;3 - 2 // 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/&lt;/td&gt;
      &lt;td&gt;나눗셈&lt;/td&gt;
      &lt;td&gt;3/2 // 1.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;*&lt;/td&gt;
      &lt;td&gt;곱셈&lt;/td&gt;
      &lt;td&gt;3 * 2 // 6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;%&lt;/td&gt;
      &lt;td&gt;나머지&lt;/td&gt;
      &lt;td&gt;3 % 2 // 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;단항 부정&lt;/td&gt;
      &lt;td&gt;-x // x의 부호를 바꿉니다. x가 50이면 -x는 -5입니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;단항 플러스&lt;/td&gt;
      &lt;td&gt;+x // x가 숫자가 아니면 &lt;strong&gt;숫자로 변환을 시도&lt;/strong&gt;합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;++&lt;/td&gt;
      &lt;td&gt;전위 증가&lt;/td&gt;
      &lt;td&gt;++x // &lt;strong&gt;x에 1을 더한 다음 평가&lt;/strong&gt;합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;++&lt;/td&gt;
      &lt;td&gt;후위 증가&lt;/td&gt;
      &lt;td&gt;x++ // &lt;strong&gt;x를 평가한 다음 1을 더합&lt;/strong&gt;니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–&lt;/td&gt;
      &lt;td&gt;전위 감소&lt;/td&gt;
      &lt;td&gt;–x // &lt;strong&gt;x에서 1을 뺀 다음 평가&lt;/strong&gt;합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–&lt;/td&gt;
      &lt;td&gt;후위 감소&lt;/td&gt;
      &lt;td&gt;x– // &lt;strong&gt;x의 값을 평가한 다음 1을 뺍니다.&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;자바스크립트의-숫자는-모두-더블-형식&quot;&gt;자바스크립트의 숫자는 모두 더블 형식&lt;/h2&gt;

&lt;p&gt;자바스크립트의 숫자는 모두 &lt;strong&gt;더블 형식&lt;/strong&gt;이므로 3/2처럼 정수를 연산한 결과도 더블 형식입니다.&lt;/p&gt;

&lt;h2 id=&quot;단항부정과-단항플러스&quot;&gt;단항부정과 단항플러스&lt;/h2&gt;

&lt;p&gt;뺄셈과 단항 부정은 모두 - 기호를 사용합니다.&lt;br /&gt;
그러면 자바스크립트는 둘을 어떻게 구별할까요?&lt;br /&gt;
답은 매우 복잡하고, 이 책에서 다룰 만한 내용은 아닙니다.&lt;br /&gt;
&lt;strong&gt;우리가 알아야 할 것은 단항 부정이 먼저 이루어지고 그 다음에 뺄셈을 한다는 겁니다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// y는 8입니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;같은 규칙이 단항 플러스에도 적용됩니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;단항 플러스 연산자는 자주 사용하는 연산자는 아닙니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;보통 이 연산자를 사용한다면 문자열을 숫자로 강제 변환하는 경우이며, 드물게는 세로로 줄을 맞추고 싶을 때 사용합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// y는 8입니다. 단항 플러스를 사용하지 않았다면&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 문자열 병합이 일어나서 결과는 &quot;35&quot;가 됩니다.&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 여기서는 굳이 단항 플러스가 필요하지 않지만 줄을 잘 맞출 수 있습니다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;6.33&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;p4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;필자가 이 예제에서 &lt;strong&gt;단항 부정과 단항 플러스를 변수에만 사용한 이유&lt;/strong&gt;는, &lt;strong&gt;숫자형 리터럴 앞에 있는 -기호는 실제 숫자형 리터럴의 일부로 해석되므로 연산자가 아니기 때문&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;h2 id=&quot;나머지&quot;&gt;나머지&lt;/h2&gt;

&lt;p&gt;나머지(remainder) 연산자는 나눗셈을 한 나머지를 반환합니다.&lt;br /&gt;
표현식의 x % y의 결과는 &lt;strong&gt;피제수dividend(x)&lt;/strong&gt; 를 &lt;strong&gt;제수divisor(y)&lt;/strong&gt; 로 나눈 나머지입니다.&lt;br /&gt;
예를 들어 10 % 3은 1입니다.&lt;br /&gt;
&lt;strong&gt;음수에 적용하면 결과는 제수가 아니라 피제수의 부호를 따라가므로 이 연산자를 진정한 나머지(modulo) 연산자라 할 수는 없습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;역주_&lt;/strong&gt; 자바스크립트에는 mod 연산자가 없지만, -10 mod 3은 -1이 아니라 2입니다(구글에서 검색하면 바로 답이 나옵니다.)&lt;br /&gt;
mod 연산자의 결과가 제수의 부호를 따르는 이유가 궁금하다면 &lt;a href=&quot;https://goo.gl/FjPtQd&quot;&gt;https://goo.gl/FjPtQd&lt;/a&gt;를 읽어보시기 바랍니다.&lt;br /&gt;
번역이 다 된 문서는 아니지만, 문서 중간쯤의 그림을 보시면 무슨 뜻인지 금방 알 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;나머지 연산자는 &lt;strong&gt;보통 전수 피연산자에만 사용하지만, 자바스크립트에서는 피연산자에 소수점이 있어도 잘 동작&lt;/strong&gt;합니다.&lt;br /&gt;
예를 들어 10 % 3.6은 2.8입니다.&lt;/p&gt;

&lt;h2 id=&quot;증가연산자-감소연산자&quot;&gt;증가연산자, 감소연산자&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;증가 연산자 ++는 할당 연산자와 덧셈 연산자를 하나로 합친 거나 다름없습니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;마찬가지로 감소 연산자 –는 할당 연산자와 뺄셈 연산자를 하나로 합친 거나 다름없습니다.&lt;/strong&gt;&lt;br /&gt;
이들은 간결하고 쓰기 쉽지만 주의해야 합니다.&lt;br /&gt;
이 연산자가 표현식 깊숙이 묻혀 있다면, 연산자의 부작용을 파악하기 어렵게 될 수 있습니다.&lt;/p&gt;

&lt;p&gt;전위(prefix)와 후위(postfix)의 차이도 이해해야 합니다.&lt;br /&gt;
전위 연산자는 먼저 변수의 값을 바꾼 다음에 평가합니다.&lt;br /&gt;
후위 연산자는 값을 바꾸기 전에 평가합니다.&lt;/p&gt;

&lt;p&gt;다음 코드를 읽어보고 결과를 맞혀 보십시오.&lt;br /&gt;
&lt;strong&gt;힌트는, 증가와 감소 연산자는 덧셈보다 먼저 실행되며, 이 예제의 표현식은 모두 왼쪽에서 오른쪽으로 진행합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;r8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;계산을 끝냈으면 자바스크립트 콘솔에서 실행해 보십시오.&lt;br /&gt;
r1과 r8을 모두 맞혔는지, 각 단계에서 x와 y의 값을 맞혔는지 확인해 보십시오.&lt;br /&gt;
이 연습문제가 어렵게 느껴진다면 종이에 적은 다음, 괄호를 써서 계산 순서를 표시해 보십시오.&lt;br /&gt;
그리고 그 순서대로 계산한다면 맞출 수 있을 겁니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/learningjs/image37.jpg&quot; alt=&quot;과정&quot; /&gt;
&lt;img src=&quot;/assets/img/learningjs/image38.jpg&quot; alt=&quot;과정&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">[표 5-1]은 자바스크립트의 산술 연산자입니다. 표 5-1 산술 연산자 연산자 설명 예제 + 덧셈(문자열 병합에도 쓰입니다.) 3 + 2 // 5 - 뺄셈 3 - 2 // 1 / 나눗셈 3/2 // 1.5 * 곱셈 3 * 2 // 6 % 나머지 3 % 2 // 1 - 단항 부정 -x // x의 부호를 바꿉니다. x가 50이면 -x는 -5입니다. + 단항 플러스 +x // x가 숫자가 아니면 숫자로 변환을 시도합니다. ++ 전위 증가 ++x // x에 1을 더한 다음 평가합니다. ++ 후위 증가 x++ // x를 평가한 다음 1을 더합니다. – 전위 감소 –x // x에서 1을 뺀 다음 평가합니다. – 후위 감소 x– // x의 값을 평가한 다음 1을 뺍니다. 자바스크립트의 숫자는 모두 더블 형식 자바스크립트의 숫자는 모두 더블 형식이므로 3/2처럼 정수를 연산한 결과도 더블 형식입니다. 단항부정과 단항플러스 뺄셈과 단항 부정은 모두 - 기호를 사용합니다. 그러면 자바스크립트는 둘을 어떻게 구별할까요? 답은 매우 복잡하고, 이 책에서 다룰 만한 내용은 아닙니다. 우리가 알아야 할 것은 단항 부정이 먼저 이루어지고 그 다음에 뺄셈을 한다는 겁니다. const x = 5; const y = 3 - -x; // y는 8입니다. 같은 규칙이 단항 플러스에도 적용됩니다. 단항 플러스 연산자는 자주 사용하는 연산자는 아닙니다. 보통 이 연산자를 사용한다면 문자열을 숫자로 강제 변환하는 경우이며, 드물게는 세로로 줄을 맞추고 싶을 때 사용합니다. const s = &quot;5&quot;; const y = 3 + +s; // y는 8입니다. 단항 플러스를 사용하지 않았다면 // 문자열 병합이 일어나서 결과는 &quot;35&quot;가 됩니다. // 여기서는 굳이 단항 플러스가 필요하지 않지만 줄을 잘 맞출 수 있습니다. const x1 = 0, x2 = 3, x3 = -1.5, x4 = -6.33; const p1 = -x1*1; const p2 = +x2*2; const p3 = +x3*3; const p4 = -x4*4; 필자가 이 예제에서 단항 부정과 단항 플러스를 변수에만 사용한 이유는, 숫자형 리터럴 앞에 있는 -기호는 실제 숫자형 리터럴의 일부로 해석되므로 연산자가 아니기 때문입니다. 나머지 나머지(remainder) 연산자는 나눗셈을 한 나머지를 반환합니다. 표현식의 x % y의 결과는 피제수dividend(x) 를 제수divisor(y) 로 나눈 나머지입니다. 예를 들어 10 % 3은 1입니다. 음수에 적용하면 결과는 제수가 아니라 피제수의 부호를 따라가므로 이 연산자를 진정한 나머지(modulo) 연산자라 할 수는 없습니다. 역주_ 자바스크립트에는 mod 연산자가 없지만, -10 mod 3은 -1이 아니라 2입니다(구글에서 검색하면 바로 답이 나옵니다.) mod 연산자의 결과가 제수의 부호를 따르는 이유가 궁금하다면 https://goo.gl/FjPtQd를 읽어보시기 바랍니다. 번역이 다 된 문서는 아니지만, 문서 중간쯤의 그림을 보시면 무슨 뜻인지 금방 알 수 있습니다. 나머지 연산자는 보통 전수 피연산자에만 사용하지만, 자바스크립트에서는 피연산자에 소수점이 있어도 잘 동작합니다. 예를 들어 10 % 3.6은 2.8입니다. 증가연산자, 감소연산자 증가 연산자 ++는 할당 연산자와 덧셈 연산자를 하나로 합친 거나 다름없습니다. 마찬가지로 감소 연산자 –는 할당 연산자와 뺄셈 연산자를 하나로 합친 거나 다름없습니다. 이들은 간결하고 쓰기 쉽지만 주의해야 합니다. 이 연산자가 표현식 깊숙이 묻혀 있다면, 연산자의 부작용을 파악하기 어렵게 될 수 있습니다. 전위(prefix)와 후위(postfix)의 차이도 이해해야 합니다. 전위 연산자는 먼저 변수의 값을 바꾼 다음에 평가합니다. 후위 연산자는 값을 바꾸기 전에 평가합니다. 다음 코드를 읽어보고 결과를 맞혀 보십시오. 힌트는, 증가와 감소 연산자는 덧셈보다 먼저 실행되며, 이 예제의 표현식은 모두 왼쪽에서 오른쪽으로 진행합니다. let x = 2; const r1 = x++ + x++; const r2 = ++x + ++x; const r3 = x++ + ++x; const r4 = ++x + x++; let y = 10; const r5 = y-- + y--; const r6 = --y + --y; const r7 = y-- + --y; const r8 = --y + y--; 계산을 끝냈으면 자바스크립트 콘솔에서 실행해 보십시오. r1과 r8을 모두 맞혔는지, 각 단계에서 x와 y의 값을 맞혔는지 확인해 보십시오. 이 연습문제가 어렵게 느껴진다면 종이에 적은 다음, 괄호를 써서 계산 순서를 표시해 보십시오. 그리고 그 순서대로 계산한다면 맞출 수 있을 겁니다.</summary></entry><entry><title type="html">5.1 연산자</title><link href="http://localhost:4000/javascript/2020/04/20/javascript80/" rel="alternate" type="text/html" title="5.1 연산자" /><published>2020-04-20T22:16:00+09:00</published><updated>2020-04-20T22:16:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/20/javascript80</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/20/javascript80/">&lt;p&gt;연산자를 표현식의 &lt;strong&gt;‘명사(noun)’&lt;/strong&gt; 에 대한 &lt;strong&gt;‘동사(verb)’&lt;/strong&gt; 라고 생각해도 좋습니다.&lt;br /&gt;
표현식이 &lt;strong&gt;값이 되는 것&lt;/strong&gt;이라면 연산자는 &lt;strong&gt;값을 만드는 행동&lt;/strong&gt;이라는 뜻입니다.&lt;br /&gt;
연산자에 대한 설명은 산술 연산자로 시작하겠습니다.&lt;br /&gt;
산술 연산자에 대한 경험이 없는 사람은 거의 없으니 직관적으로 이해하기 쉬울 겁니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;NOTE_&lt;/strong&gt; 연산자는 하나 이상의 &lt;strong&gt;피연산자&lt;/strong&gt;가 있어야 결과를 낼 수 있습니다.&lt;br /&gt;
예를 들어 1 + 2라는 표현식에서 1과 2는 &lt;strong&gt;피연산자&lt;/strong&gt;이고 +는 &lt;strong&gt;연산자&lt;/strong&gt;입니다.&lt;br /&gt;
엄격히 말하면 &lt;strong&gt;피연산자&lt;/strong&gt;가 맞는 말이지만 피연산자를 &lt;strong&gt;매개변수(argument)&lt;/strong&gt; 라 부르는 경우도 많이 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">연산자를 표현식의 ‘명사(noun)’ 에 대한 ‘동사(verb)’ 라고 생각해도 좋습니다. 표현식이 값이 되는 것이라면 연산자는 값을 만드는 행동이라는 뜻입니다. 연산자에 대한 설명은 산술 연산자로 시작하겠습니다. 산술 연산자에 대한 경험이 없는 사람은 거의 없으니 직관적으로 이해하기 쉬울 겁니다. NOTE_ 연산자는 하나 이상의 피연산자가 있어야 결과를 낼 수 있습니다. 예를 들어 1 + 2라는 표현식에서 1과 2는 피연산자이고 +는 연산자입니다. 엄격히 말하면 피연산자가 맞는 말이지만 피연산자를 매개변수(argument) 라 부르는 경우도 많이 있습니다.</summary></entry><entry><title type="html">5. 표현식과 연산자</title><link href="http://localhost:4000/javascript/2020/04/20/javascript79/" rel="alternate" type="text/html" title="5. 표현식과 연산자" /><published>2020-04-20T20:13:55+09:00</published><updated>2020-04-20T20:13:55+09:00</updated><id>http://localhost:4000/javascript/2020/04/20/javascript79</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/20/javascript79/">&lt;p&gt;&lt;strong&gt;표현식(expression)&lt;/strong&gt; 은 값으로 평가될 수 있는 문입니다.&lt;br /&gt;
&lt;strong&gt;즉 결과가 값인 문과, 표현식이 아닌 문의 차이를 이해하는 것이 매우 중요합니다.&lt;/strong&gt;&lt;br /&gt;
이 차이를 이해해야만 자바스크립트의 요소들을 효과적으로 조합할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;표현식이 아닌 문(statement)&lt;/strong&gt; 은 일종의 &lt;strong&gt;지시&lt;/strong&gt;라고 생각할 수 있고, &lt;strong&gt;표현식&lt;/strong&gt;은 &lt;strong&gt;무언가를 요청하는 것&lt;/strong&gt;이라고 생각할 수 있습니다.&lt;br /&gt;
자, 직장에 첫 출근했다고 상상해 봅시다.&lt;br /&gt;
상사가 다가와서 “당신이 할 일은 볼트 A를 너트 B에 끼우는 일입니다.”라고 말합니다.&lt;br /&gt;
상사가 한 말은 &lt;strong&gt;표현식이 아닌&lt;/strong&gt; 문입니다.&lt;br /&gt;
&lt;strong&gt;상사는 당신에게 조립한 결과물을 요청한 것이 아니라, 그저 조립할 것을 지시했을 뿐입니다.&lt;/strong&gt;&lt;br /&gt;
상사가 “볼트 A를 너트 B에 끼우고, 내가 검사할 수 있도록 가져오세요.” 라고 말했다면 그건 &lt;strong&gt;표현식&lt;/strong&gt;입니다.&lt;br /&gt;
당신은 지시를 받았고, 그 결과를 반환해야 합니다.&lt;/p&gt;

&lt;p&gt;“어떻든 결과는 마찬가지 아닌가? 조립한 결과를 그냥 두든, 상사에게 가져가든 조립된 건 마찬가지인데.” 라고 생각할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어라고 상황이 180도 달라지는 건 아닙니다.&lt;br /&gt;
&lt;strong&gt;표현식&lt;/strong&gt;이 아닌 &lt;strong&gt;문&lt;/strong&gt;도 &lt;strong&gt;뭔가&lt;/strong&gt;를 합니다.&lt;br /&gt;
&lt;strong&gt;하지만 그 결과를 명시적으로 반환하는 것은 표현식입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;표현식은 값이 됩니다.&lt;br /&gt;
&lt;strong&gt;그 결과를 다른 표현식에 결합해서 다른 값을 얻을 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
그 값을 또 다른 표현식에 결합해서 또 다른 값을 얻는 식으로 이어질 수 있습니다.&lt;br /&gt;
표현식이 아닌 문은 이런 식으로 결합할 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;표현식은 값이 되므로 할당에 쓸 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
즉, 표현식의 결과를 변수나 상수, 프로퍼티에 할당할 수 있습니다.&lt;br /&gt;
표현식의 예를 하나 들어 봅시다.&lt;br /&gt;
&lt;strong&gt;곱셈은 표현식입니다.&lt;/strong&gt;&lt;br /&gt;
이해하기 쉽겠죠?&lt;br /&gt;
두 숫자를 곱하면 결과가 나옵니다.&lt;br /&gt;
매우 단순한 문 두 개를 봅시다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;첫 번째 행은 &lt;strong&gt;선언문&lt;/strong&gt;입니다.&lt;br /&gt;
우리는 변수 x가 있다고 선언했습니다.&lt;br /&gt;
물론 두 행을 결합할 수 있지만, 그렇게 하면 요점이 잘 드러나지 않습니다.&lt;br /&gt;
두 번째 행을 잘 봅시다.&lt;br /&gt;
이 행에는 사실 표현식이 두 개 있습니다.&lt;br /&gt;
첫 번째 표현식은 3 * 5 입니다.&lt;br /&gt;
곱셈 표현식이고, 결과는 15입니다.&lt;br /&gt;
그 다음은 값 15를 변수 x에 할당한 표현식입니다.&lt;br /&gt;
&lt;strong&gt;할당은 그 자체가 표현식입니다.&lt;/strong&gt;&lt;br /&gt;
음? 표현식은 값이 된다고 했는데, 그럼 할당 표현식은 어떤 값이 되는 걸까요?&lt;br /&gt;
물론 할당 표현식도 값이 됩니다.&lt;br /&gt;
x만 값 15를 할당 받는 것이 아니라, &lt;strong&gt;전체 표현식&lt;/strong&gt;의 결과도 값 15입니다.&lt;br /&gt;
&lt;strong&gt;할당은 표현식이고, 따라서 값이 되므로, 다른 변수에 다시 할당할 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
좀 우스꽝스럽지만, 다음 예제를 보십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 x와 y 두 변수가 있고 값은 모두 15입니다.&lt;br /&gt;
&lt;strong&gt;이런 일이 가능한 것은 곱셈과 할당이 모두 표현식이기 때문입니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;자바스크립트는 이렇게 표현식이 결합된 것을 보면 쪼갤 수 있는 만큼 쪼개서 한 부분씩 실행합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//원래 문&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 곱셈 표현식을 평가했습니다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;// 첫 번째 할당을 평가했습니다. x는 이제 15이고, &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//y는 아직 undefined입니다.&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;// 두 번째 할당을 평가했습니다. y는 이제 15입니다. &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//전체 문의 결과는 15입니다. 이 값은 사용하지도 않았고 &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//어딘가에 할당하지도 않았으니 그냥 버려집니다.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러면 이제 자바스크립트는 어떤 원칙으로 표현식을 그런 순서로 실행하는가 하는 의문이 들겁니다.&lt;br /&gt;
즉, y = x를 먼저 실행해서 y에 값을 undefined를 할당하고 &lt;strong&gt;그 다음에&lt;/strong&gt; 곱셈을 해서 y는 undefined로 남고 x는 15가 될 수도 있지 않느냐는 의문 말입니다.&lt;br /&gt;
자바스크립트가 표현식을 평가하는 순서를 &lt;strong&gt;연산자 우선순위&lt;/strong&gt;라 부르며, 이 장에서 설명할 겁니다.&lt;/p&gt;

&lt;p&gt;표현식은 대부분 &lt;strong&gt;연산자(operator)&lt;/strong&gt; 표현식입니다.&lt;br /&gt;
즉 곱셈 표현식은 &lt;strong&gt;곱셈 연산자(*)&lt;/strong&gt; 와 &lt;strong&gt;피연산자(operand)&lt;/strong&gt; 두 개로 이루어집니다. &lt;br /&gt;
&lt;strong&gt;피연산자는 서로 곱하는 두 숫자&lt;/strong&gt;이며 피연산자 자체도 표현식입니다.&lt;/p&gt;

&lt;p&gt;연산자 표현식이 아닌 표현식에는 &lt;strong&gt;식별자 표현식&lt;/strong&gt;(변수와 상수 이름)과 &lt;strong&gt;리터럴 표현식&lt;/strong&gt; 두 가지가 있습니다.&lt;br /&gt;
이름만 봐도 알 수 있을 겁니다.&lt;br /&gt;
변수와 상수, 리터럴은 그 자체가 표현식입니다.&lt;br /&gt;
표현식은 모두 평등합니다.&lt;br /&gt;
값이 되는 것은 모두 표현식이므로, 변수와 상수, 리터럴이 모두 표현식인 것은 당연합니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">표현식(expression) 은 값으로 평가될 수 있는 문입니다. 즉 결과가 값인 문과, 표현식이 아닌 문의 차이를 이해하는 것이 매우 중요합니다. 이 차이를 이해해야만 자바스크립트의 요소들을 효과적으로 조합할 수 있습니다. 표현식이 아닌 문(statement) 은 일종의 지시라고 생각할 수 있고, 표현식은 무언가를 요청하는 것이라고 생각할 수 있습니다. 자, 직장에 첫 출근했다고 상상해 봅시다. 상사가 다가와서 “당신이 할 일은 볼트 A를 너트 B에 끼우는 일입니다.”라고 말합니다. 상사가 한 말은 표현식이 아닌 문입니다. 상사는 당신에게 조립한 결과물을 요청한 것이 아니라, 그저 조립할 것을 지시했을 뿐입니다. 상사가 “볼트 A를 너트 B에 끼우고, 내가 검사할 수 있도록 가져오세요.” 라고 말했다면 그건 표현식입니다. 당신은 지시를 받았고, 그 결과를 반환해야 합니다. “어떻든 결과는 마찬가지 아닌가? 조립한 결과를 그냥 두든, 상사에게 가져가든 조립된 건 마찬가지인데.” 라고 생각할 수도 있습니다. 프로그래밍 언어라고 상황이 180도 달라지는 건 아닙니다. 표현식이 아닌 문도 뭔가를 합니다. 하지만 그 결과를 명시적으로 반환하는 것은 표현식입니다. 표현식은 값이 됩니다. 그 결과를 다른 표현식에 결합해서 다른 값을 얻을 수 있습니다. 그 값을 또 다른 표현식에 결합해서 또 다른 값을 얻는 식으로 이어질 수 있습니다. 표현식이 아닌 문은 이런 식으로 결합할 수 없습니다. 표현식은 값이 되므로 할당에 쓸 수 있습니다. 즉, 표현식의 결과를 변수나 상수, 프로퍼티에 할당할 수 있습니다. 표현식의 예를 하나 들어 봅시다. 곱셈은 표현식입니다. 이해하기 쉽겠죠? 두 숫자를 곱하면 결과가 나옵니다. 매우 단순한 문 두 개를 봅시다. let x; x = 3 * 5; 첫 번째 행은 선언문입니다. 우리는 변수 x가 있다고 선언했습니다. 물론 두 행을 결합할 수 있지만, 그렇게 하면 요점이 잘 드러나지 않습니다. 두 번째 행을 잘 봅시다. 이 행에는 사실 표현식이 두 개 있습니다. 첫 번째 표현식은 3 * 5 입니다. 곱셈 표현식이고, 결과는 15입니다. 그 다음은 값 15를 변수 x에 할당한 표현식입니다. 할당은 그 자체가 표현식입니다. 음? 표현식은 값이 된다고 했는데, 그럼 할당 표현식은 어떤 값이 되는 걸까요? 물론 할당 표현식도 값이 됩니다. x만 값 15를 할당 받는 것이 아니라, 전체 표현식의 결과도 값 15입니다. 할당은 표현식이고, 따라서 값이 되므로, 다른 변수에 다시 할당할 수 있습니다. 좀 우스꽝스럽지만, 다음 예제를 보십시오. let x, y; y = x = 3 * 5; 이제 x와 y 두 변수가 있고 값은 모두 15입니다. 이런 일이 가능한 것은 곱셈과 할당이 모두 표현식이기 때문입니다. 자바스크립트는 이렇게 표현식이 결합된 것을 보면 쪼갤 수 있는 만큼 쪼개서 한 부분씩 실행합니다. let x, y; y = x = 3 * 5; //원래 문 y = x = 15; // 곱셈 표현식을 평가했습니다. y = 15; // 첫 번째 할당을 평가했습니다. x는 이제 15이고, //y는 아직 undefined입니다. 15; // 두 번째 할당을 평가했습니다. y는 이제 15입니다. //전체 문의 결과는 15입니다. 이 값은 사용하지도 않았고 //어딘가에 할당하지도 않았으니 그냥 버려집니다. 그러면 이제 자바스크립트는 어떤 원칙으로 표현식을 그런 순서로 실행하는가 하는 의문이 들겁니다. 즉, y = x를 먼저 실행해서 y에 값을 undefined를 할당하고 그 다음에 곱셈을 해서 y는 undefined로 남고 x는 15가 될 수도 있지 않느냐는 의문 말입니다. 자바스크립트가 표현식을 평가하는 순서를 연산자 우선순위라 부르며, 이 장에서 설명할 겁니다. 표현식은 대부분 연산자(operator) 표현식입니다. 즉 곱셈 표현식은 곱셈 연산자(*) 와 피연산자(operand) 두 개로 이루어집니다. 피연산자는 서로 곱하는 두 숫자이며 피연산자 자체도 표현식입니다. 연산자 표현식이 아닌 표현식에는 식별자 표현식(변수와 상수 이름)과 리터럴 표현식 두 가지가 있습니다. 이름만 봐도 알 수 있을 겁니다. 변수와 상수, 리터럴은 그 자체가 표현식입니다. 표현식은 모두 평등합니다. 값이 되는 것은 모두 표현식이므로, 변수와 상수, 리터럴이 모두 표현식인 것은 당연합니다.</summary></entry><entry><title type="html">4.4 요약</title><link href="http://localhost:4000/javascript/2020/04/20/javascript78/" rel="alternate" type="text/html" title="4.4 요약" /><published>2020-04-20T00:39:50+09:00</published><updated>2020-04-20T00:39:50+09:00</updated><id>http://localhost:4000/javascript/2020/04/20/javascript78</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/20/javascript78/">&lt;p&gt;&lt;strong&gt;제어문은 실제로 프로그램이 동작하게 하는 가장 중요한 열쇠&lt;/strong&gt;입니다.&lt;br /&gt;
변수와 상수에 중요한 정보가 아무리 많이 들어있다 해도 제어문을 써야 그 데이터에 따라 필요한 선택을 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;순서도는 프로그램의 흐름을 시각적으로 표현하는 좋은 방법&lt;/strong&gt;이고, 코드를 작성하기 전에 추상적인 순서도를 그려 보면 문제를 어떻게 해결할지 결정하는 데 도움이 될 수 있습니다.&lt;br /&gt;
하지만 순서도는 간단하게 그리기가 어려우며, 충분히 훈련된 사람은 프로그램의 흐름을 코드만으로도 자연스럽게 표현할 수 있습니다.&lt;br /&gt;
&lt;strong&gt;사실 순서도를 그리듯, 레고 블록을 조립하듯 시각적으로 프로그램을 만드는 언어를 만들려는 시도는 여러 가지가 있었지만, 텍스트 기반 프로그래밍 언어가 이런 시도에 위협받았던 적은 한 번도 없습니다.&lt;/strong&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">제어문은 실제로 프로그램이 동작하게 하는 가장 중요한 열쇠입니다. 변수와 상수에 중요한 정보가 아무리 많이 들어있다 해도 제어문을 써야 그 데이터에 따라 필요한 선택을 할 수 있습니다. 순서도는 프로그램의 흐름을 시각적으로 표현하는 좋은 방법이고, 코드를 작성하기 전에 추상적인 순서도를 그려 보면 문제를 어떻게 해결할지 결정하는 데 도움이 될 수 있습니다. 하지만 순서도는 간단하게 그리기가 어려우며, 충분히 훈련된 사람은 프로그램의 흐름을 코드만으로도 자연스럽게 표현할 수 있습니다. 사실 순서도를 그리듯, 레고 블록을 조립하듯 시각적으로 프로그램을 만드는 언어를 만들려는 시도는 여러 가지가 있었지만, 텍스트 기반 프로그래밍 언어가 이런 시도에 위협받았던 적은 한 번도 없습니다.</summary></entry><entry><title type="html">4.3.4 배열을 수정할 때 감소하는 인덱스 사용하기</title><link href="http://localhost:4000/javascript/2020/04/20/javascript77/" rel="alternate" type="text/html" title="4.3.4 배열을 수정할 때 감소하는 인덱스 사용하기" /><published>2020-04-20T00:24:39+09:00</published><updated>2020-04-20T00:24:39+09:00</updated><id>http://localhost:4000/javascript/2020/04/20/javascript77</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/20/javascript77/">&lt;p&gt;&lt;strong&gt;배열에 루프를 실행하면서 루프 바디에서 배열을 수정하는 건 위험할 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
뜻하지 않게 종료 조건을 바꿀 수도 있으니까요.&lt;br /&gt;
운이 좋다면 원하지 않는 결과가 나오는 정도겠지만, 운이 나쁘면 무한 루프가 발생할 겁니다.&lt;br /&gt;
이런 경우 널리 쓰이는 패턴은 &lt;strong&gt;감소하는 인덱스&lt;/strong&gt;를 써서, &lt;strong&gt;배열 마지막 요소에서 루프를 시작하는 방법&lt;/strong&gt;입니다.&lt;br /&gt;
이렇게 하면 배열에 요소를 추가하거나 제거해도 종료 조건이 바뀌는 일은 없습니다.&lt;/p&gt;

&lt;p&gt;예를 들어 bitArrayOfNumbers 에서 찾은 모든 소수를 제거하고 싶다고 합시다.&lt;br /&gt;
8장에서 배우겠지만, 다음 코드의 &lt;strong&gt;splice 메서드&lt;/strong&gt;는 배열 요소를 추가하거나 제거할 때 사용합니다.&lt;br /&gt;
이 예제는 예상대로 동작하지 않습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bigArrayOfNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isPrime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bigArrayOfNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bigArrayOfNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;splice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;인덱스는 점점 커지는데 우리는 요소를 제거하고 있으므로, 소수가 연달아 존재한다면 그중 일부를 제거하지 않고 넘어갈 가능성이 있습니다.&lt;/strong&gt;&lt;br /&gt;
감소하는 인덱스를 쓰면 이 문제는 간단히 해결됩니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bigArrayOfNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isPrime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bigArrayOfNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bigArrayOfNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;splice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;초기 조건과 종료 조건을 봅시다.&lt;br /&gt;
배열의 인덱스는 0에서 시작하므로 &lt;strong&gt;배열 길이보다 1 작은 값&lt;/strong&gt;으로 시작해야 합니다.&lt;br /&gt;
그리고 루프의 &lt;strong&gt;종료 조건을 i가 0보다 크거나 같을 때&lt;/strong&gt;로 정했습니다.&lt;br /&gt;
그렇지 않다면 이 루프는 배열의 첫 번째 요소에서는 실행되지 않으므로, 첫 번째 요소가 소수라면 문제가 생길 겁니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">배열에 루프를 실행하면서 루프 바디에서 배열을 수정하는 건 위험할 수 있습니다. 뜻하지 않게 종료 조건을 바꿀 수도 있으니까요. 운이 좋다면 원하지 않는 결과가 나오는 정도겠지만, 운이 나쁘면 무한 루프가 발생할 겁니다. 이런 경우 널리 쓰이는 패턴은 감소하는 인덱스를 써서, 배열 마지막 요소에서 루프를 시작하는 방법입니다. 이렇게 하면 배열에 요소를 추가하거나 제거해도 종료 조건이 바뀌는 일은 없습니다. 예를 들어 bitArrayOfNumbers 에서 찾은 모든 소수를 제거하고 싶다고 합시다. 8장에서 배우겠지만, 다음 코드의 splice 메서드는 배열 요소를 추가하거나 제거할 때 사용합니다. 이 예제는 예상대로 동작하지 않습니다. for(let i=0; i&amp;lt;bigArrayOfNumbers.length; i++) { if(isPrime(bigArrayOfNumbers[i])) bigArrayOfNumbers.splice(i, 1); } 인덱스는 점점 커지는데 우리는 요소를 제거하고 있으므로, 소수가 연달아 존재한다면 그중 일부를 제거하지 않고 넘어갈 가능성이 있습니다. 감소하는 인덱스를 쓰면 이 문제는 간단히 해결됩니다. for(let i = bigArrayOfNumbers.length-1; i&amp;gt;=0; i--){ if(isPrime(bigArrayOfNumbers[i])) bigArrayOfNumbers.splice(i, 1); } 초기 조건과 종료 조건을 봅시다. 배열의 인덱스는 0에서 시작하므로 배열 길이보다 1 작은 값으로 시작해야 합니다. 그리고 루프의 종료 조건을 i가 0보다 크거나 같을 때로 정했습니다. 그렇지 않다면 이 루프는 배열의 첫 번째 요소에서는 실행되지 않으므로, 첫 번째 요소가 소수라면 문제가 생길 겁니다.</summary></entry><entry><title type="html">4.3.3 루프를 완료한 뒤 인덱스 값 사용하기</title><link href="http://localhost:4000/javascript/2020/04/20/javascript76/" rel="alternate" type="text/html" title="4.3.3 루프를 완료한 뒤 인덱스 값 사용하기" /><published>2020-04-20T00:17:00+09:00</published><updated>2020-04-20T00:17:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/20/javascript76</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/20/javascript76/">&lt;p&gt;break 문을 써서 루프를 일찍 종료했을 때 인덱스 변수의 값이 필요할 때가 있습니다.&lt;br /&gt;
for 루프가 끝나도 인덱스 변수의 값은 그대로 유지된다는 점을 활용할 수 있습니다.&lt;br /&gt;
&lt;strong&gt;이 패턴은 break 문을 써서 루프를 끝내도록 해야만 사용할 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
예를 들어 이 패턴을 써서 배열에 들어 있는 첫 번째 소수의 인덱스를 찾을 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bigArrayOfNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isPrime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bigArrayOfNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bigArrayOfNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;No prime numbers!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`First prime number found at position &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">break 문을 써서 루프를 일찍 종료했을 때 인덱스 변수의 값이 필요할 때가 있습니다. for 루프가 끝나도 인덱스 변수의 값은 그대로 유지된다는 점을 활용할 수 있습니다. 이 패턴은 break 문을 써서 루프를 끝내도록 해야만 사용할 수 있습니다. 예를 들어 이 패턴을 써서 배열에 들어 있는 첫 번째 소수의 인덱스를 찾을 수 있습니다. let i = 0; for(; i &amp;lt; bigArrayOfNumbers.length; i++){ if(isPrime(bigArrayOfNumbers[i])) break; } if(i === bigArrayOfNumbers.length) console.log('No prime numbers!'); else console.log(`First prime number found at position ${i}`);</summary></entry><entry><title type="html">4.3.2 break나 return 문을 써서 불필요한 연산 줄이기</title><link href="http://localhost:4000/javascript/2020/04/19/javascript75/" rel="alternate" type="text/html" title="4.3.2 break나 return 문을 써서 불필요한 연산 줄이기" /><published>2020-04-19T23:47:00+09:00</published><updated>2020-04-19T23:47:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/19/javascript75</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/19/javascript75/">&lt;p&gt;뭔가를 찾기 위해서 루프를 실행했다면, 찾으려는 것을 이미 찾은 후에는 루프 바디를 계속 실행할 필요가 없습니다.&lt;/p&gt;

&lt;p&gt;예를 들어 봅시다. 어떤 숫자가 소수(prime)인지 판단하는 작업은 CPU 부하가 비교적 높은 일 중 하나입니다.&lt;br /&gt;
숫자 수천개의 리스트에서 가장 앞에 있는 소수를 찾는다고 했을 때, 다음 코드는 일단 원하는 작업을 하기는 합니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;firstPrime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bigArrayOfNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isPrime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;firstPrime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;firstPrime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;bigArrayOfNumbers에 들어 있는 숫자가 백만 개쯤 되고, 소수는 그 리스트의 마지막쯤에 있다면 이 방법을 써도 상관은 없습니다.&lt;br /&gt;
하지만 첫 번째 숫자가 소수였다면?&lt;br /&gt;
아니면, 다섯 번째나 열다섯 번째쯤 있었다면 어떨까요?&lt;br /&gt;
쓸모없는 작업을 백만번이나 한 셈입니다.&lt;br /&gt;
생각만 해도 힘이 빠지는 소리군요.&lt;br /&gt;
break 문을 쓰면 원하는 것을 찾은 즉시 루프에서 빠져나갈 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;firstPrime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bitArrayOfNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isPrime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;firstPrime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;이 루프가 함수 안에 있었다면 break 대신 return 문을 써도 됩니다.&lt;/strong&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">뭔가를 찾기 위해서 루프를 실행했다면, 찾으려는 것을 이미 찾은 후에는 루프 바디를 계속 실행할 필요가 없습니다. 예를 들어 봅시다. 어떤 숫자가 소수(prime)인지 판단하는 작업은 CPU 부하가 비교적 높은 일 중 하나입니다. 숫자 수천개의 리스트에서 가장 앞에 있는 소수를 찾는다고 했을 때, 다음 코드는 일단 원하는 작업을 하기는 합니다. let firstPrime = null; for(let n of bigArrayOfNumbers){ if(isPrime(n) &amp;amp;&amp;amp; firstPrime === null) firstPrime = n; } bigArrayOfNumbers에 들어 있는 숫자가 백만 개쯤 되고, 소수는 그 리스트의 마지막쯤에 있다면 이 방법을 써도 상관은 없습니다. 하지만 첫 번째 숫자가 소수였다면? 아니면, 다섯 번째나 열다섯 번째쯤 있었다면 어떨까요? 쓸모없는 작업을 백만번이나 한 셈입니다. 생각만 해도 힘이 빠지는 소리군요. break 문을 쓰면 원하는 것을 찾은 즉시 루프에서 빠져나갈 수 있습니다. let firstPrime = null; for(let n of bitArrayOfNumbers){ if(isPrime(n)){ firstPrime = n; break; } } 이 루프가 함수 안에 있었다면 break 대신 return 문을 써도 됩니다.</summary></entry><entry><title type="html">4.3.1 continue 문을 사용하여 조건 중첩 줄이기</title><link href="http://localhost:4000/javascript/2020/04/19/javascript74/" rel="alternate" type="text/html" title="4.3.1 continue 문을 사용하여 조건 중첩 줄이기" /><published>2020-04-19T23:38:00+09:00</published><updated>2020-04-19T23:38:00+09:00</updated><id>http://localhost:4000/javascript/2020/04/19/javascript74</id><content type="html" xml:base="http://localhost:4000/javascript/2020/04/19/javascript74/">&lt;p&gt;특정 조건이 맞을 때만 루프 바디를 실행해야 할 때가 많습니다.&lt;br /&gt;
다시 말해 반복문 안에 조건문을 써야 하는 경우입니다.&lt;br /&gt;
다음 예제를 보십시오.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;funds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;funds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;totalBet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;funds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;totalBet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Unlucky! Skip this round....&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// 플레이...&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 경우를 &lt;strong&gt;제어문 중첩(nested control flow)&lt;/strong&gt; 이라 부릅니다.&lt;br /&gt;
while 루프의 바디에서 할 일은 대부분 else 절에 들어있고, if 절이 하는 일은 &lt;code class=&quot;highlighter-rouge&quot;&gt;console.log&lt;/code&gt;를 호출하는 것뿐입니다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;continue&lt;/code&gt; 문을 써서 이 구조를 간결하게 만들 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;funds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;funds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;totalBet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;funds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;totalBet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Unlucky! Skip this round...&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 플레이...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 단순한 예제에서는 대체 뭐가 좋아졌다는 건지 실감이 잘 안 나겠지만, 루프 바디가 20행 쯤 된다고 생각해 보십시오.&lt;br /&gt;
중첩을 제거하면 코드를 읽고 이해하기 쉬워집니다.&lt;/p&gt;</content><author><name></name></author><summary type="html">특정 조건이 맞을 때만 루프 바디를 실행해야 할 때가 많습니다. 다시 말해 반복문 안에 조건문을 써야 하는 경우입니다. 다음 예제를 보십시오. while(funds &amp;gt; 1 &amp;amp;&amp;amp; funds &amp;lt; 100) { let totalBet = rand(1, funds); if (totalBet === 13) { console.log(&quot;Unlucky! Skip this round....&quot;); } else { // 플레이... } } 이런 경우를 제어문 중첩(nested control flow) 이라 부릅니다. while 루프의 바디에서 할 일은 대부분 else 절에 들어있고, if 절이 하는 일은 console.log를 호출하는 것뿐입니다. continue 문을 써서 이 구조를 간결하게 만들 수 있습니다. while(funds &amp;gt; 1 &amp;amp;&amp;amp; funds &amp;lt; 100) { let totalBet = rand(1, funds); if (totalBet === 13) { console.log(&quot;Unlucky! Skip this round...&quot;); continue; } // 플레이... } 이 단순한 예제에서는 대체 뭐가 좋아졌다는 건지 실감이 잘 안 나겠지만, 루프 바디가 20행 쯤 된다고 생각해 보십시오. 중첩을 제거하면 코드를 읽고 이해하기 쉬워집니다.</summary></entry></feed>