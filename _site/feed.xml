<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LEE HYUNG JU</title>
    <description>Jekyll Blog</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 28 Sep 2020 19:00:23 +0900</pubDate>
    <lastBuildDate>Mon, 28 Sep 2020 19:00:23 +0900</lastBuildDate>
    <generator>Jekyll v4.0.1</generator>
    
      <item>
        <title>19. 'map', 'filter', and 'reduce' Methods</title>
        <description>&lt;h2 id=&quot;19-map-filter-and-reduce-methods&quot;&gt;19. ‘map’, ‘filter’, and ‘reduce’ Methods&lt;/h2&gt;

&lt;p&gt;이 세 가지 방법은 배열 조작에 매우 유용합니다.&lt;br /&gt;
그것들은 Array 프로토타입에 있습니다.&lt;/p&gt;

&lt;p&gt;배열이 있고 모든 요소에 대해 무언가를 수행하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt; 메서드를 사용합니다.&lt;br /&gt;
배열이 있고 모든 요소에 대해 조건을 실행하고 조건을 통과하는 값을 얻으려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt; 메서드를 사용합니다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce&lt;/code&gt; 메서드는 배열의 모든 요소에 대해 감속기 기능을 수행하고 마지막으로 하나의 값을 반환합니다.&lt;br /&gt;
완벽한 예는 배열의 모든 요소의 합을 찾는 것입니다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;numbers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;reduced&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;reduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;accumulator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;accumulator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;reduced&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 21&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 세 가지 방법은 원래 배열의 값을 변경하지 않습니다.&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Sep 2020 18:53:00 +0900</pubDate>
        <link>http://localhost:4000/js/2020/09/28/javascript19.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2020/09/28/javascript19.html</guid>
        
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>18. Object Creation With 'new', 'Object.create', and 'Object.assign'</title>
        <description>&lt;h2 id=&quot;18-object-creation-with-new-objectcreate-and-objectassign&quot;&gt;18. Object Creation With ‘new’, ‘Object.create’, and ‘Object.assign’&lt;/h2&gt;

&lt;p&gt;JavaScript에서 개체를 만드는 방법은 여러 가지가 있습니다.&lt;br /&gt;
그러나 누군가가 &lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt; 키워드 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.create&lt;/code&gt; 메서드를 선택하는 이유가 있습니다.&lt;br /&gt;
&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.create&lt;/code&gt; 메서드를 사용하면 기존 개체를 새로 만든 개체의 프로토타입으로 사용할 수 있습니다.&lt;/strong&gt;&lt;br /&gt;
이를 통해 OOP의 상속 개념과 유사하게 기존 개체의 속성과 기능을 재사용 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.assign&lt;/code&gt; 메서드를 사용하면 하나 이상의 &lt;strong&gt;[원본 개체(source object)]&lt;/strong&gt;에서 &lt;strong&gt;[대상(target) 개체]&lt;/strong&gt;로 열거 가능한 고유 속성을 복사 할 수 있습니다.&lt;br /&gt;
이 상황에서 &lt;strong&gt;[대상(target) 개체]&lt;/strong&gt;의 프로토타입에는 &lt;strong&gt;[원본 개체(source object)]&lt;/strong&gt;의 속성이 포함되지 않습니다.&lt;br /&gt;
이것이 이 두 가지 방법의 주요 차이점입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;create(만들다)와 assign(할당)의 차이인 것 같다.
create로 만들면 기존(원본) 객체와 prototype으로 연결되고, assign(할당)하면 속성은 받지만 prototype으로 연결되진 않고..&lt;br /&gt;
그런 뜻인 것 같다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이러한 세 가지 개체 생성 방법을 이해하면 사용 사례에 따라 응용 프로그램 내에서 적절하게 사용하여 메모리 효율적인 프로그램을 만들 수 있습니다.&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Sep 2020 18:34:00 +0900</pubDate>
        <link>http://localhost:4000/js/2020/09/28/javascript18.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2020/09/28/javascript18.html</guid>
        
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>17. Prototypes</title>
        <description>&lt;h2 id=&quot;17-prototypes&quot;&gt;17. Prototypes&lt;/h2&gt;

&lt;p&gt;이것은 10 년의 경험이있는 사람에게도 JavaScript에서 가장 혼란스러운 개념 중 하나입니다.&lt;/p&gt;

&lt;p&gt;JavaScript의 프로토 타입은 객체간에 공통 기능을 공유하는 메커니즘입니다.&lt;br /&gt;
&lt;strong&gt;JavaScript의 거의 모든 객체는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;의 인스턴스입니다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;일반적인 개체는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.prototype&lt;/code&gt;의 모든 속성과 메서드를 상속합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;간단히 말해서 프로토타입은 JavaScript 객체가 메서드와 속성을 상속하는 객체입니다.&lt;/p&gt;

&lt;p&gt;프로토타입을 더 잘 이해함으로써 효율적이고 빠른 애플리케이션을 구축 할 수 있습니다.&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Sep 2020 18:28:00 +0900</pubDate>
        <link>http://localhost:4000/js/2020/09/28/javascript17.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2020/09/28/javascript17.html</guid>
        
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>16. Constructor Functions and ‘instanceOf’ Operator (생성자 함수 및 'instanceOf' 연산자)</title>
        <description>&lt;h2 id=&quot;16-constructor-functions-and-instanceof-operator-생성자-함수-및-instanceof-연산자&quot;&gt;16. Constructor Functions and ‘instanceOf’ Operator (생성자 함수 및 ‘instanceOf’ 연산자)&lt;/h2&gt;

&lt;p&gt;생성자 함수는 일반 함수와 같습니다.&lt;br /&gt;
그러나 그들은 몇가지 차이점이 있습니다.&lt;br /&gt;
관례적으로, 생성자 함수의 이름은 대문자로 시작하며 &lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt; 연산자로만 실행되어야 합니다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt; 키워드는 OOP 배경 지식이 있는 프로그래머에게 친숙할 것입니다.&lt;/p&gt;

&lt;p&gt;객체의 유형을 올바르게 식별하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;instanceOf&lt;/code&gt; 연산자를 사용합니다.&lt;br /&gt;
간단히 말해서 개체가 다른 개체의 인스턴스인지 확인합니다.&lt;/p&gt;

&lt;p&gt;이렇게하면 객체가 서로 어떻게 상속되는지 이해하는 데 도움이됩니다.&lt;br /&gt;
상속은 &lt;strong&gt;프로토타입&lt;/strong&gt;을 통해 이루어집니다.&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Sep 2020 18:18:00 +0900</pubDate>
        <link>http://localhost:4000/js/2020/09/28/javascript16.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2020/09/28/javascript16.html</guid>
        
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>15. 'this' Keyword and 'apply', 'call', and 'bind' Methods</title>
        <description>&lt;h2 id=&quot;15-this-keyword-and-apply-call-and-bind-methods&quot;&gt;15. ‘this’ Keyword and ‘apply’, ‘call’, and ‘bind’ Methods&lt;/h2&gt;

&lt;p&gt;개인적으로 JS 개발자는 이 키워드에 대한 이해도가 있어야 된다고 생각합니다.&lt;br /&gt;
제대로 이해하지 못하면 나중에 응용 프로그램에서 다양한 문제가 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt; 키워드를 잘 이해하고 있다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;apply&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; 및 &lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt; 메서드에 집중할 수 있습니다.&lt;br /&gt;
&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;이러한 메서드들은 적절한 컨텍스트로 함수를 호출하는 데 필요합니다.&lt;/span&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;에 액세스하는 콜백을 전달할 때 특히 &lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt; 메서드가 필요합니다.&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Sep 2020 18:12:00 +0900</pubDate>
        <link>http://localhost:4000/js/2020/09/28/javascript15.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2020/09/28/javascript15.html</guid>
        
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>14. Classes and Factories</title>
        <description>&lt;h2 id=&quot;14-classes-and-factories&quot;&gt;14. Classes and Factories&lt;/h2&gt;

&lt;p&gt;JavaScript는 객체 지향 언어가 아닙니다.&lt;br /&gt;
&lt;strong&gt;그러나 OOP 속성을 모방하기 위해 생성자 함수가 사용되었습니다.&lt;/strong&gt;&lt;br /&gt;
Tania에 따르면 &lt;strong&gt;자바스크립트의 클래스&lt;/strong&gt;는 &lt;strong&gt;실제로 추가 기능을 제공하지 않으며 더 깨끗하고 우아한 구문을 제공한다는 점에서 프로토타입 및 상속보다 
구문적 이점을 제공하는 것으로 종종 설명됩니다.&lt;/strong&gt;&lt;br /&gt;
다른 프로그래밍 언어는 클래스를 사용하기 때문에, 자바스크립트의 클래스 구문을 사용하면 개발자가 언어를 보다 더 쉽게 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;팩토리 함수&lt;/strong&gt;는 객체를 반환하는 클래스 또는 생성자가 아닌 함수입니다.&lt;br /&gt;
JS 전문가인 Eric Elliot에 따르면, 자바스크립트에서는 모든 함수가 새로운 객체를 반환할 수 있다고 합니다.&lt;br /&gt;
이러한 함수(생성자 함수나 클래스가 아닌 경우에 객체를 반환하는 함수)를 팩토리 함수라고 합니다.&lt;/p&gt;

&lt;p&gt;특히 크기와 규모가 더 큰 애플리케이션 개발을 시작할 때 이 두 개념을 잘 이해하고 있어야합니다.&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Sep 2020 17:16:00 +0900</pubDate>
        <link>http://localhost:4000/js/2020/09/28/javascript14.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2020/09/28/javascript14.html</guid>
        
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>13. DOM and Layout Trees (DOM 및 레이아웃 트리)</title>
        <description>&lt;h2 id=&quot;13-dom-and-layout-trees-dom-및-레이아웃-트리&quot;&gt;13. DOM and Layout Trees (DOM 및 레이아웃 트리)&lt;/h2&gt;

&lt;p&gt;우리 중 대부분은 DOM(Document Object Model)에 대해 들어봤지만 깊이 알고있는 사람은 극소수에 불과합니다.&lt;br /&gt;
브라우저에서 보는 것이 DOM이 아니라는 것을 알고 있습니까?&lt;br /&gt;
&lt;strong&gt;실제로는 DOM과 CSSOM의 조합인 렌더 트리입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DOM의 작동 방식, 구조화 방식, 페이지 렌더링 방식을 이해함으로써 자바스크립트를 사용하여 웹 페이지를 동적으로 조작할 수 있습니다.&lt;br /&gt;
이것은 우리의 응용 프로그램 성능이 높은 수준을 유지하기 위해 특히 필요합니다.&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Sep 2020 17:13:00 +0900</pubDate>
        <link>http://localhost:4000/js/2020/09/28/javascript13.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2020/09/28/javascript13.html</guid>
        
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>12. Bitwise Operations (비트 연산)</title>
        <description>&lt;h2 id=&quot;12-bitwise-operations-비트-연산&quot;&gt;12. Bitwise Operations (비트 연산)&lt;/h2&gt;

&lt;p&gt;이러한 연산은 값을 10진수, 16진수 또는 8진수가 아닌 2진수 비트(0 및 1)로 처리합니다.&lt;br /&gt;
비트 연산자는 이러한 2진 표현에서 작업을 수행하지만 표준 자바스크립트 숫자값을 반환합니다.&lt;/p&gt;

&lt;p&gt;일반적으로 이러한 작업은 코드에서 사용하지 않지만 몇 가지 사용 사례가 있습니다.&lt;br /&gt;
짝수 및 홀수값, 색상 변환, 색상 추출 및 구성 플래그를 찾는데 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이러한 비트 연산을 철저히 알고 있으면 많은 픽셀 조작이 포함된 WebGL과 같은 기술로 작업할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Sep 2020 17:10:00 +0900</pubDate>
        <link>http://localhost:4000/js/2020/09/28/javascript12.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2020/09/28/javascript12.html</guid>
        
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>11. JavaScript Engines</title>
        <description>&lt;h2 id=&quot;11-javascript-engines&quot;&gt;11. JavaScript Engines&lt;/h2&gt;

&lt;p&gt;우리는 지금 자바스크립트에 대해 더 깊이 들어가고 있습니다.&lt;br /&gt;
자바스크립트 엔진은 자바스크립트 코드를 실행하는 컴퓨터 프로그램 또는 인터프리터입니다.&lt;br /&gt;
자바스크립트 엔진은 다양한 언어로 작성할 수 있습니다.&lt;br /&gt;
예를 들어 크롬 브라우저를 구동하는 V8 엔진은 C++로 작성되었으며, 파이어폭스 브라우저를 구동하는 SpiderMonkey 엔진은 C 및 C++ 로 작성되었습니다.&lt;/p&gt;

&lt;p&gt;효율적인 코드를 작성하기 위해 작업중인 자바스크립트 엔진을 이해하는 것이 중요합니다.&lt;br /&gt;
웹뷰를 사용하는 모바일 개발자는 특히 이것을 알고 있어야 합니다.&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Sep 2020 17:08:00 +0900</pubDate>
        <link>http://localhost:4000/js/2020/09/28/javascript11.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2020/09/28/javascript11.html</guid>
        
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>10. Time Intervals</title>
        <description>&lt;h2 id=&quot;10-time-intervals&quot;&gt;10. Time Intervals&lt;/h2&gt;

&lt;p&gt;JavaScript에서 호출 또는 함수를 예약하려면 두 가지 방법을 사용합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setTimeout&lt;/code&gt;을 사용하면 특정 시간 간격 후에 한 번 함수를 실행할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setInterval&lt;/code&gt;을 사용하면 특정 시간 간격 이후에 시작하여 해당 간격으로 계속 반복하여 함수를 반복적으로 실행할 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이는 메시지 큐 및 이벤트 핸들러의 이전 개념과 다소 관련이 있습니다.&lt;br /&gt;
따라서 시간 간격 작동 방식을 이해하면 사용 사례에서 효율적으로 사용할 수 있습니다.&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Sep 2020 17:04:00 +0900</pubDate>
        <link>http://localhost:4000/js/2020/09/28/javascript10.html</link>
        <guid isPermaLink="true">http://localhost:4000/js/2020/09/28/javascript10.html</guid>
        
        
        <category>js</category>
        
      </item>
    
  </channel>
</rss>
